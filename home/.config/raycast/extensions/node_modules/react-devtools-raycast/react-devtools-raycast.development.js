var window = global;

var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode, NOOP } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {Buffer} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {Buffer} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require("utf-8-validate");
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {String} [binaryType=nodebuffer] The type for binary data
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Boolean} [isServer=false] Specifies whether to operate in client or
       *     server mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(
              RangeError,
              "invalid payload length 1",
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       */
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {Buffer} data The data to frame
       * @param {Object} options Options object
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {Buffer[]} The framed data as a list of `Buffer` instances
       * @public
       */
      static frame(data, options) {
        const merge = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {String} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      /**
       * Frames and sends a close message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @private
       */
      doClose(data, mask2, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 8,
            mask: mask2,
            readOnly: false
          }),
          cb
        );
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      /**
       * Frames and sends a ping message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
       * @param {Function} [cb] Callback
       * @private
       */
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 9,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      /**
       * Frames and sends a pong message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
       * @param {Function} [cb] Callback
       * @private
       */
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 10,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender.frame(buf, {
              fin: options.fin,
              rsv1: false,
              opcode,
              mask: options.mask,
              readOnly: toBuffer.readOnly
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a data message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @param {Object} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {Number} code The status code explaining why the connection is being
       *     closed
       * @param {String} reason A human-readable string explaining why the
       *     connection is closing
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      /**
       * Create a new `OpenEvent`.
       *
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {Object} error The error that generated this event
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {Function} listener The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, listener, options) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options && options.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {Function} listener The listener to remove
       * @public
       */
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var { addEventListener, removeEventListener } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return void 0;
      }
      /* istanbul ignore next */
      set onclose(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return void 0;
      }
      /* istanbul ignore next */
      set onerror(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return void 0;
      }
      /* istanbul ignore next */
      set onopen(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return void 0;
      }
      /* istanbul ignore next */
      set onmessage(listener) {
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Number} [maxPayload=0] The maximum allowed message size
       * @private
       */
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(
          this.binaryType,
          this._extensions,
          this._isServer,
          maxPayload
        );
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {String} [data] A string explaining why the connection is closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        const err = new Error(`Invalid URL: ${websocket.url}`);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https.get : http.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalUnixSocket = isUnixSocket;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else {
          const isSameHost = isUnixSocket ? websocket._originalUnixSocket ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalUnixSocket ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL(location, address);
          } catch (err) {
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/react-devtools-core/dist/backend.js
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === "object" && typeof module === "object")
    module.exports = factory();
  else if (typeof define === "function" && define.amd)
    define([], factory);
  else if (typeof exports === "object")
    exports["ReactDevToolsBackend"] = factory();
  else
    root["ReactDevToolsBackend"] = factory();
})(window, () => {
  return (
    /******/
    (() => {
      var __webpack_modules__ = {
        /***/
        602: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            var __webpack_unused_export__;
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            var h = __webpack_require__2(206), p = __webpack_require__2(189), q = Object.assign, w = p.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, x = [], y = null;
            function z() {
              if (null === y) {
                var a = /* @__PURE__ */ new Map();
                try {
                  A.useContext({
                    _currentValue: null
                  }), A.useState(null), A.useReducer(function(c) {
                    return c;
                  }, null), A.useRef(null), "function" === typeof A.useCacheRefresh && A.useCacheRefresh(), A.useLayoutEffect(function() {
                  }), A.useInsertionEffect(function() {
                  }), A.useEffect(function() {
                  }), A.useImperativeHandle(void 0, function() {
                    return null;
                  }), A.useDebugValue(null), A.useCallback(function() {
                  }), A.useMemo(function() {
                    return null;
                  }), "function" === typeof A.useMemoCache && A.useMemoCache(0);
                } finally {
                  var b = x;
                  x = [];
                }
                for (var e = 0; e < b.length; e++) {
                  var f = b[e];
                  a.set(f.primitive, h.parse(f.stackError));
                }
                y = a;
              }
              return y;
            }
            var B = null;
            function C() {
              var a = B;
              null !== a && (B = a.next);
              return a;
            }
            var A = {
              use: function use() {
                throw Error("Support for `use` not yet implemented in react-debug-tools.");
              },
              readContext: function readContext(a) {
                return a._currentValue;
              },
              useCacheRefresh: function useCacheRefresh() {
                var a = C();
                x.push({
                  primitive: "CacheRefresh",
                  stackError: Error(),
                  value: null !== a ? a.memoizedState : function() {
                  }
                });
                return function() {
                };
              },
              useCallback: function useCallback(a) {
                var b = C();
                x.push({
                  primitive: "Callback",
                  stackError: Error(),
                  value: null !== b ? b.memoizedState[0] : a
                });
                return a;
              },
              useContext: function useContext(a) {
                x.push({
                  primitive: "Context",
                  stackError: Error(),
                  value: a._currentValue
                });
                return a._currentValue;
              },
              useEffect: function useEffect(a) {
                C();
                x.push({
                  primitive: "Effect",
                  stackError: Error(),
                  value: a
                });
              },
              useImperativeHandle: function useImperativeHandle(a) {
                C();
                var b = void 0;
                null !== a && "object" === _typeof(a) && (b = a.current);
                x.push({
                  primitive: "ImperativeHandle",
                  stackError: Error(),
                  value: b
                });
              },
              useDebugValue: function useDebugValue(a, b) {
                x.push({
                  primitive: "DebugValue",
                  stackError: Error(),
                  value: "function" === typeof b ? b(a) : a
                });
              },
              useLayoutEffect: function useLayoutEffect(a) {
                C();
                x.push({
                  primitive: "LayoutEffect",
                  stackError: Error(),
                  value: a
                });
              },
              useInsertionEffect: function useInsertionEffect(a) {
                C();
                x.push({
                  primitive: "InsertionEffect",
                  stackError: Error(),
                  value: a
                });
              },
              useMemo: function useMemo(a) {
                var b = C();
                a = null !== b ? b.memoizedState[0] : a();
                x.push({
                  primitive: "Memo",
                  stackError: Error(),
                  value: a
                });
                return a;
              },
              useMemoCache: function useMemoCache(a) {
                var b = C();
                b = null !== b && null !== b.updateQueue && null != b.updateQueue.memoCache ? b.updateQueue.memoCache : {
                  data: [],
                  index: 0
                };
                b = b.data[b.index];
                if (void 0 === b) {
                  var e = Symbol.for("react.memo_cache_sentinel");
                  b = Array(a);
                  for (var f = 0; f < a; f++) {
                    b[f] = e;
                  }
                }
                x.push({
                  primitive: "MemoCache",
                  stackError: Error(),
                  value: b
                });
                return b;
              },
              useReducer: function useReducer(a, b, e) {
                a = C();
                b = null !== a ? a.memoizedState : void 0 !== e ? e(b) : b;
                x.push({
                  primitive: "Reducer",
                  stackError: Error(),
                  value: b
                });
                return [b, function() {
                }];
              },
              useRef: function useRef(a) {
                var b = C();
                a = null !== b ? b.memoizedState : {
                  current: a
                };
                x.push({
                  primitive: "Ref",
                  stackError: Error(),
                  value: a.current
                });
                return a;
              },
              useState: function useState(a) {
                var b = C();
                a = null !== b ? b.memoizedState : "function" === typeof a ? a() : a;
                x.push({
                  primitive: "State",
                  stackError: Error(),
                  value: a
                });
                return [a, function() {
                }];
              },
              useTransition: function useTransition() {
                C();
                C();
                x.push({
                  primitive: "Transition",
                  stackError: Error(),
                  value: void 0
                });
                return [false, function() {
                }];
              },
              useSyncExternalStore: function useSyncExternalStore(a, b) {
                C();
                C();
                a = b();
                x.push({
                  primitive: "SyncExternalStore",
                  stackError: Error(),
                  value: a
                });
                return a;
              },
              useDeferredValue: function useDeferredValue(a) {
                var b = C();
                x.push({
                  primitive: "DeferredValue",
                  stackError: Error(),
                  value: null !== b ? b.memoizedState : a
                });
                return a;
              },
              useId: function useId() {
                var a = C();
                a = null !== a ? a.memoizedState : "";
                x.push({
                  primitive: "Id",
                  stackError: Error(),
                  value: a
                });
                return a;
              }
            }, D = {
              get: function get(a, b) {
                if (a.hasOwnProperty(b))
                  return a[b];
                a = Error("Missing method in Dispatcher: " + b);
                a.name = "ReactDebugToolsUnsupportedHookError";
                throw a;
              }
            }, E = "undefined" === typeof Proxy ? A : new Proxy(A, D), F = 0;
            function G(a, b, e) {
              var f = b[e].source, c = 0;
              a:
                for (; c < a.length; c++) {
                  if (a[c].source === f) {
                    for (var k = e + 1, r = c + 1; k < b.length && r < a.length; k++, r++) {
                      if (a[r].source !== b[k].source)
                        continue a;
                    }
                    return c;
                  }
                }
              return -1;
            }
            function H(a, b) {
              if (!a)
                return false;
              b = "use" + b;
              return a.length < b.length ? false : a.lastIndexOf(b) === a.length - b.length;
            }
            function I(a, b, e) {
              for (var f = [], c = null, k = f, r = 0, t = [], v = 0; v < b.length; v++) {
                var u = b[v];
                var d = a;
                var l = h.parse(u.stackError);
                b: {
                  var m = l, n = G(m, d, F);
                  if (-1 !== n)
                    d = n;
                  else {
                    for (var g = 0; g < d.length && 5 > g; g++) {
                      if (n = G(m, d, g), -1 !== n) {
                        F = g;
                        d = n;
                        break b;
                      }
                    }
                    d = -1;
                  }
                }
                b: {
                  m = l;
                  n = z().get(u.primitive);
                  if (void 0 !== n)
                    for (g = 0; g < n.length && g < m.length; g++) {
                      if (n[g].source !== m[g].source) {
                        g < m.length - 1 && H(m[g].functionName, u.primitive) && g++;
                        g < m.length - 1 && H(m[g].functionName, u.primitive) && g++;
                        m = g;
                        break b;
                      }
                    }
                  m = -1;
                }
                l = -1 === d || -1 === m || 2 > d - m ? null : l.slice(m, d - 1);
                if (null !== l) {
                  d = 0;
                  if (null !== c) {
                    for (; d < l.length && d < c.length && l[l.length - d - 1].source === c[c.length - d - 1].source; ) {
                      d++;
                    }
                    for (c = c.length - 1; c > d; c--) {
                      k = t.pop();
                    }
                  }
                  for (c = l.length - d - 1; 1 <= c; c--) {
                    d = [], m = l[c], (n = l[c - 1].functionName) ? (g = n.lastIndexOf("."), -1 === g && (g = 0), "use" === n.slice(g, g + 3) && (g += 3), n = n.slice(g)) : n = "", n = {
                      id: null,
                      isStateEditable: false,
                      name: n,
                      value: void 0,
                      subHooks: d
                    }, e && (n.hookSource = {
                      lineNumber: m.lineNumber,
                      columnNumber: m.columnNumber,
                      functionName: m.functionName,
                      fileName: m.fileName
                    }), k.push(n), t.push(k), k = d;
                  }
                  c = l;
                }
                d = u.primitive;
                u = {
                  id: "Context" === d || "DebugValue" === d ? null : r++,
                  isStateEditable: "Reducer" === d || "State" === d,
                  name: d,
                  value: u.value,
                  subHooks: []
                };
                e && (d = {
                  lineNumber: null,
                  functionName: null,
                  fileName: null,
                  columnNumber: null
                }, l && 1 <= l.length && (l = l[0], d.lineNumber = l.lineNumber, d.functionName = l.functionName, d.fileName = l.fileName, d.columnNumber = l.columnNumber), u.hookSource = d);
                k.push(u);
              }
              J(f, null);
              return f;
            }
            function J(a, b) {
              for (var e = [], f = 0; f < a.length; f++) {
                var c = a[f];
                "DebugValue" === c.name && 0 === c.subHooks.length ? (a.splice(f, 1), f--, e.push(c)) : J(c.subHooks, c);
              }
              null !== b && (1 === e.length ? b.value = e[0].value : 1 < e.length && (b.value = e.map(function(k) {
                return k.value;
              })));
            }
            function K(a) {
              if (a instanceof Error && "ReactDebugToolsUnsupportedHookError" === a.name)
                throw a;
              var b = Error("Error rendering inspected component", {
                cause: a
              });
              b.name = "ReactDebugToolsRenderError";
              b.cause = a;
              throw b;
            }
            function L(a, b, e) {
              var f = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : false;
              null == e && (e = w.ReactCurrentDispatcher);
              var c = e.current;
              e.current = E;
              try {
                var k = Error();
                a(b);
              } catch (t) {
                K(t);
              } finally {
                var r = x;
                x = [];
                e.current = c;
              }
              c = h.parse(k);
              return I(c, r, f);
            }
            function M(a) {
              a.forEach(function(b, e) {
                return e._currentValue = b;
              });
            }
            __webpack_unused_export__ = L;
            exports2.inspectHooksOfFiber = function(a, b) {
              var e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : false;
              null == b && (b = w.ReactCurrentDispatcher);
              if (0 !== a.tag && 15 !== a.tag && 11 !== a.tag)
                throw Error("Unknown Fiber. Needs to be a function component to inspect hooks.");
              z();
              var f = a.type, c = a.memoizedProps;
              if (f !== a.elementType && f && f.defaultProps) {
                c = q({}, c);
                var k = f.defaultProps;
                for (r in k) {
                  void 0 === c[r] && (c[r] = k[r]);
                }
              }
              B = a.memoizedState;
              var r = /* @__PURE__ */ new Map();
              try {
                for (k = a; k; ) {
                  if (10 === k.tag) {
                    var t = k.type._context;
                    r.has(t) || (r.set(t, t._currentValue), t._currentValue = k.memoizedProps.value);
                  }
                  k = k.return;
                }
                if (11 === a.tag) {
                  var v = f.render;
                  f = c;
                  var u = a.ref;
                  t = b;
                  var d = t.current;
                  t.current = E;
                  try {
                    var l = Error();
                    v(f, u);
                  } catch (g) {
                    K(g);
                  } finally {
                    var m = x;
                    x = [];
                    t.current = d;
                  }
                  var n = h.parse(l);
                  return I(n, m, e);
                }
                return L(f, c, b, e);
              } finally {
                B = null, M(r);
              }
            };
          }
        ),
        /***/
        987: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            if (true) {
              module2.exports = __webpack_require__2(602);
            } else {
            }
          }
        ),
        /***/
        9: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            var __webpack_unused_export__;
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u = Symbol.for("react.cache"), v = Symbol.for("react.client.reference");
            function w(a) {
              if ("object" === _typeof(a) && null !== a) {
                var r = a.$$typeof;
                switch (r) {
                  case b:
                    switch (a = a.type, a) {
                      case d:
                      case f:
                      case e:
                      case m:
                      case n:
                        return a;
                      default:
                        switch (a = a && a.$$typeof, a) {
                          case k:
                          case h:
                          case l:
                          case q:
                          case p:
                          case g:
                            return a;
                          default:
                            return r;
                        }
                    }
                  case c:
                    return r;
                }
              }
            }
            exports2.ContextConsumer = h;
            exports2.ContextProvider = g;
            __webpack_unused_export__ = b;
            exports2.ForwardRef = l;
            exports2.Fragment = d;
            exports2.Lazy = q;
            exports2.Memo = p;
            exports2.Portal = c;
            exports2.Profiler = f;
            exports2.StrictMode = e;
            exports2.Suspense = m;
            __webpack_unused_export__ = n;
            __webpack_unused_export__ = function() {
              return false;
            };
            __webpack_unused_export__ = function() {
              return false;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === h;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === g;
            };
            exports2.isElement = function(a) {
              return "object" === _typeof(a) && null !== a && a.$$typeof === b;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === l;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === d;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === q;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === p;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === c;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === f;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === e;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === m;
            };
            __webpack_unused_export__ = function(a) {
              return w(a) === n;
            };
            __webpack_unused_export__ = function(a) {
              return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || a === u || "object" === _typeof(a) && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === v || void 0 !== a.getModuleId) ? true : false;
            };
            exports2.typeOf = w;
          }
        ),
        /***/
        550: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            if (true) {
              module2.exports = __webpack_require__2(9);
            } else {
            }
          }
        ),
        /***/
        978: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.server_context"), w = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), z = Symbol.for("react.memo"), A = Symbol.for("react.lazy"), B = Symbol.for("react.debug_trace_mode"), aa = Symbol.for("react.offscreen"), ba = Symbol.for("react.cache"), C = Symbol.for("react.default_value"), ca = Symbol.for("react.postpone"), D = Symbol.iterator;
            function da(a) {
              if (null === a || "object" !== _typeof(a))
                return null;
              a = D && a[D] || a["@@iterator"];
              return "function" === typeof a ? a : null;
            }
            var E = {
              isMounted: function isMounted() {
                return false;
              },
              enqueueForceUpdate: function enqueueForceUpdate() {
              },
              enqueueReplaceState: function enqueueReplaceState() {
              },
              enqueueSetState: function enqueueSetState() {
              }
            }, F = Object.assign, G = {};
            function H(a, b, c) {
              this.props = a;
              this.context = b;
              this.refs = G;
              this.updater = c || E;
            }
            H.prototype.isReactComponent = {};
            H.prototype.setState = function(a, b) {
              if ("object" !== _typeof(a) && "function" !== typeof a && null != a)
                throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
              this.updater.enqueueSetState(this, a, b, "setState");
            };
            H.prototype.forceUpdate = function(a) {
              this.updater.enqueueForceUpdate(this, a, "forceUpdate");
            };
            function I() {
            }
            I.prototype = H.prototype;
            function J(a, b, c) {
              this.props = a;
              this.context = b;
              this.refs = G;
              this.updater = c || E;
            }
            var K = J.prototype = new I();
            K.constructor = J;
            F(K, H.prototype);
            K.isPureReactComponent = true;
            var L = Array.isArray, M = Object.prototype.hasOwnProperty, N = {
              current: null
            }, O = {
              key: true,
              ref: true,
              __self: true,
              __source: true
            };
            function P(a, b, c) {
              var d, e = {}, f = null, g = null;
              if (null != b)
                for (d in void 0 !== b.ref && (g = b.ref), void 0 !== b.key && (f = "" + b.key), b) {
                  M.call(b, d) && !O.hasOwnProperty(d) && (e[d] = b[d]);
                }
              var h = arguments.length - 2;
              if (1 === h)
                e.children = c;
              else if (1 < h) {
                for (var k = Array(h), m = 0; m < h; m++) {
                  k[m] = arguments[m + 2];
                }
                e.children = k;
              }
              if (a && a.defaultProps)
                for (d in h = a.defaultProps, h) {
                  void 0 === e[d] && (e[d] = h[d]);
                }
              return {
                $$typeof: l,
                type: a,
                key: f,
                ref: g,
                props: e,
                _owner: N.current
              };
            }
            function ea(a, b) {
              return {
                $$typeof: l,
                type: a.type,
                key: b,
                ref: a.ref,
                props: a.props,
                _owner: a._owner
              };
            }
            function Q(a) {
              return "object" === _typeof(a) && null !== a && a.$$typeof === l;
            }
            function escape(a) {
              var b = {
                "=": "=0",
                ":": "=2"
              };
              return "$" + a.replace(/[=:]/g, function(c) {
                return b[c];
              });
            }
            var R = /\/+/g;
            function S(a, b) {
              return "object" === _typeof(a) && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
            }
            function T(a, b, c, d, e) {
              var f = _typeof(a);
              if ("undefined" === f || "boolean" === f)
                a = null;
              var g = false;
              if (null === a)
                g = true;
              else
                switch (f) {
                  case "string":
                  case "number":
                    g = true;
                    break;
                  case "object":
                    switch (a.$$typeof) {
                      case l:
                      case n:
                        g = true;
                    }
                }
              if (g)
                return g = a, e = e(g), a = "" === d ? "." + S(g, 0) : d, L(e) ? (c = "", null != a && (c = a.replace(R, "$&/") + "/"), T(e, b, c, "", function(m) {
                  return m;
                })) : null != e && (Q(e) && (e = ea(e, c + (!e.key || g && g.key === e.key ? "" : ("" + e.key).replace(R, "$&/") + "/") + a)), b.push(e)), 1;
              g = 0;
              d = "" === d ? "." : d + ":";
              if (L(a))
                for (var h = 0; h < a.length; h++) {
                  f = a[h];
                  var k = d + S(f, h);
                  g += T(f, b, c, k, e);
                }
              else if (k = da(a), "function" === typeof k)
                for (a = k.call(a), h = 0; !(f = a.next()).done; ) {
                  f = f.value, k = d + S(f, h++), g += T(f, b, c, k, e);
                }
              else if ("object" === f)
                throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
              return g;
            }
            function U(a, b, c) {
              if (null == a)
                return a;
              var d = [], e = 0;
              T(a, d, "", "", function(f) {
                return b.call(c, f, e++);
              });
              return d;
            }
            function fa(a) {
              if (-1 === a._status) {
                var b = a._result;
                b = b();
                b.then(function(c) {
                  if (0 === a._status || -1 === a._status)
                    a._status = 1, a._result = c;
                }, function(c) {
                  if (0 === a._status || -1 === a._status)
                    a._status = 2, a._result = c;
                });
                -1 === a._status && (a._status = 0, a._result = b);
              }
              if (1 === a._status)
                return a._result.default;
              throw a._result;
            }
            var V = {
              current: null
            };
            function ha() {
              return /* @__PURE__ */ new WeakMap();
            }
            function W() {
              return {
                s: 0,
                v: void 0,
                o: null,
                p: null
              };
            }
            var X = {
              current: null
            }, Y = {
              transition: null
            }, Z = {}, ia = {
              ReactCurrentDispatcher: X,
              ReactCurrentCache: V,
              ReactCurrentBatchConfig: Y,
              ReactCurrentOwner: N,
              ContextRegistry: Z
            };
            exports2.Children = {
              map: U,
              forEach: function forEach(a, b, c) {
                U(a, function() {
                  b.apply(this, arguments);
                }, c);
              },
              count: function count(a) {
                var b = 0;
                U(a, function() {
                  b++;
                });
                return b;
              },
              toArray: function toArray(a) {
                return U(a, function(b) {
                  return b;
                }) || [];
              },
              only: function only(a) {
                if (!Q(a))
                  throw Error("React.Children.only expected to receive a single React element child.");
                return a;
              }
            };
            exports2.Component = H;
            exports2.Fragment = p;
            exports2.Profiler = r;
            exports2.PureComponent = J;
            exports2.StrictMode = q;
            exports2.Suspense = x;
            exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ia;
            exports2.cache = function(a) {
              return function() {
                var b = V.current;
                if (!b)
                  return a.apply(null, arguments);
                var c = b.getCacheForType(ha);
                b = c.get(a);
                void 0 === b && (b = W(), c.set(a, b));
                c = 0;
                for (var d = arguments.length; c < d; c++) {
                  var e = arguments[c];
                  if ("function" === typeof e || "object" === _typeof(e) && null !== e) {
                    var f = b.o;
                    null === f && (b.o = f = /* @__PURE__ */ new WeakMap());
                    b = f.get(e);
                    void 0 === b && (b = W(), f.set(e, b));
                  } else
                    f = b.p, null === f && (b.p = f = /* @__PURE__ */ new Map()), b = f.get(e), void 0 === b && (b = W(), f.set(e, b));
                }
                if (1 === b.s)
                  return b.v;
                if (2 === b.s)
                  throw b.v;
                try {
                  var g = a.apply(null, arguments);
                  c = b;
                  c.s = 1;
                  return c.v = g;
                } catch (h) {
                  throw g = b, g.s = 2, g.v = h, h;
                }
              };
            };
            exports2.cloneElement = function(a, b, c) {
              if (null === a || void 0 === a)
                throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
              var d = F({}, a.props), e = a.key, f = a.ref, g = a._owner;
              if (null != b) {
                void 0 !== b.ref && (f = b.ref, g = N.current);
                void 0 !== b.key && (e = "" + b.key);
                if (a.type && a.type.defaultProps)
                  var h = a.type.defaultProps;
                for (k in b) {
                  M.call(b, k) && !O.hasOwnProperty(k) && (d[k] = void 0 === b[k] && void 0 !== h ? h[k] : b[k]);
                }
              }
              var k = arguments.length - 2;
              if (1 === k)
                d.children = c;
              else if (1 < k) {
                h = Array(k);
                for (var m = 0; m < k; m++) {
                  h[m] = arguments[m + 2];
                }
                d.children = h;
              }
              return {
                $$typeof: l,
                type: a.type,
                key: e,
                ref: f,
                props: d,
                _owner: g
              };
            };
            exports2.createContext = function(a) {
              a = {
                $$typeof: u,
                _currentValue: a,
                _currentValue2: a,
                _threadCount: 0,
                Provider: null,
                Consumer: null,
                _defaultValue: null,
                _globalName: null
              };
              a.Provider = {
                $$typeof: t,
                _context: a
              };
              return a.Consumer = a;
            };
            exports2.createElement = P;
            exports2.createFactory = function(a) {
              var b = P.bind(null, a);
              b.type = a;
              return b;
            };
            exports2.createRef = function() {
              return {
                current: null
              };
            };
            exports2.createServerContext = function(a, b) {
              var c = true;
              if (!Z[a]) {
                c = false;
                var d = {
                  $$typeof: v,
                  _currentValue: b,
                  _currentValue2: b,
                  _defaultValue: b,
                  _threadCount: 0,
                  Provider: null,
                  Consumer: null,
                  _globalName: a
                };
                d.Provider = {
                  $$typeof: t,
                  _context: d
                };
                Z[a] = d;
              }
              d = Z[a];
              if (d._defaultValue === C)
                d._defaultValue = b, d._currentValue === C && (d._currentValue = b), d._currentValue2 === C && (d._currentValue2 = b);
              else if (c)
                throw Error("ServerContext: " + a + " already defined");
              return d;
            };
            exports2.experimental_useEffectEvent = function(a) {
              return X.current.useEffectEvent(a);
            };
            exports2.experimental_useOptimistic = function(a, b) {
              return X.current.useOptimistic(a, b);
            };
            exports2.forwardRef = function(a) {
              return {
                $$typeof: w,
                render: a
              };
            };
            exports2.isValidElement = Q;
            exports2.lazy = function(a) {
              return {
                $$typeof: A,
                _payload: {
                  _status: -1,
                  _result: a
                },
                _init: fa
              };
            };
            exports2.memo = function(a, b) {
              return {
                $$typeof: z,
                type: a,
                compare: void 0 === b ? null : b
              };
            };
            exports2.startTransition = function(a) {
              var b = Y.transition;
              Y.transition = {};
              try {
                a();
              } finally {
                Y.transition = b;
              }
            };
            exports2.unstable_Cache = ba;
            exports2.unstable_DebugTracingMode = B;
            exports2.unstable_Offscreen = aa;
            exports2.unstable_SuspenseList = y;
            exports2.unstable_act = function() {
              throw Error("act(...) is not supported in production builds of React.");
            };
            exports2.unstable_getCacheForType = function(a) {
              var b = V.current;
              return b ? b.getCacheForType(a) : a();
            };
            exports2.unstable_getCacheSignal = function() {
              var a = V.current;
              return a ? a.getCacheSignal() : (a = new AbortController(), a.abort(Error("This CacheSignal was requested outside React which means that it is immediately aborted.")), a.signal);
            };
            exports2.unstable_postpone = function(a) {
              a = Error(a);
              a.$$typeof = ca;
              throw a;
            };
            exports2.unstable_useCacheRefresh = function() {
              return X.current.useCacheRefresh();
            };
            exports2.unstable_useMemoCache = function(a) {
              return X.current.useMemoCache(a);
            };
            exports2.use = function(a) {
              return X.current.use(a);
            };
            exports2.useCallback = function(a, b) {
              return X.current.useCallback(a, b);
            };
            exports2.useContext = function(a) {
              return X.current.useContext(a);
            };
            exports2.useDebugValue = function() {
            };
            exports2.useDeferredValue = function(a) {
              return X.current.useDeferredValue(a);
            };
            exports2.useEffect = function(a, b) {
              return X.current.useEffect(a, b);
            };
            exports2.useId = function() {
              return X.current.useId();
            };
            exports2.useImperativeHandle = function(a, b, c) {
              return X.current.useImperativeHandle(a, b, c);
            };
            exports2.useInsertionEffect = function(a, b) {
              return X.current.useInsertionEffect(a, b);
            };
            exports2.useLayoutEffect = function(a, b) {
              return X.current.useLayoutEffect(a, b);
            };
            exports2.useMemo = function(a, b) {
              return X.current.useMemo(a, b);
            };
            exports2.useReducer = function(a, b, c) {
              return X.current.useReducer(a, b, c);
            };
            exports2.useRef = function(a) {
              return X.current.useRef(a);
            };
            exports2.useState = function(a) {
              return X.current.useState(a);
            };
            exports2.useSyncExternalStore = function(a, b, c) {
              return X.current.useSyncExternalStore(a, b, c);
            };
            exports2.useTransition = function() {
              return X.current.useTransition();
            };
            exports2.version = "18.3.0-experimental-db69f95e4-20231002";
          }
        ),
        /***/
        189: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            if (true) {
              module2.exports = __webpack_require__2(978);
            } else {
            }
          }
        ),
        /***/
        206: (
          /***/
          function(module2, exports2, __webpack_require__2) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            (function(root, factory) {
              "use strict";
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__2(430)], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else {
              }
            })(this, function ErrorStackParser(StackFrame) {
              "use strict";
              var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
              var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
              var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
              return {
                /**
                 * Given an Error object, extract the most information from it.
                 *
                 * @param {Error} error object
                 * @return {Array} of StackFrames
                 */
                parse: function ErrorStackParser$$parse(error) {
                  if (typeof error.stacktrace !== "undefined" || typeof error["opera#sourceloc"] !== "undefined") {
                    return this.parseOpera(error);
                  } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                    return this.parseV8OrIE(error);
                  } else if (error.stack) {
                    return this.parseFFOrSafari(error);
                  } else {
                    throw new Error("Cannot parse given Error object");
                  }
                },
                // Separate line and column numbers from a string of the form: (URI:Line:Column)
                extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
                  if (urlLike.indexOf(":") === -1) {
                    return [urlLike];
                  }
                  var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
                  var parts = regExp.exec(urlLike.replace(/[()]/g, ""));
                  return [parts[1], parts[2] || void 0, parts[3] || void 0];
                },
                parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
                  var filtered = error.stack.split("\n").filter(function(line) {
                    return !!line.match(CHROME_IE_STACK_REGEXP);
                  }, this);
                  return filtered.map(function(line) {
                    if (line.indexOf("(eval ") > -1) {
                      line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(\),.*$)/g, "");
                    }
                    var sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(");
                    var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);
                    sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
                    var tokens = sanitizedLine.split(/\s+/).slice(1);
                    var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                    var functionName = tokens.join(" ") || void 0;
                    var fileName = ["eval", "<anonymous>"].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0];
                    return new StackFrame({
                      functionName,
                      fileName,
                      lineNumber: locationParts[1],
                      columnNumber: locationParts[2],
                      source: line
                    });
                  }, this);
                },
                parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
                  var filtered = error.stack.split("\n").filter(function(line) {
                    return !line.match(SAFARI_NATIVE_CODE_REGEXP);
                  }, this);
                  return filtered.map(function(line) {
                    if (line.indexOf(" > eval") > -1) {
                      line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
                    }
                    if (line.indexOf("@") === -1 && line.indexOf(":") === -1) {
                      return new StackFrame({
                        functionName: line
                      });
                    } else {
                      var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                      var matches = line.match(functionNameRegex);
                      var functionName = matches && matches[1] ? matches[1] : void 0;
                      var locationParts = this.extractLocation(line.replace(functionNameRegex, ""));
                      return new StackFrame({
                        functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                      });
                    }
                  }, this);
                },
                parseOpera: function ErrorStackParser$$parseOpera(e) {
                  if (!e.stacktrace || e.message.indexOf("\n") > -1 && e.message.split("\n").length > e.stacktrace.split("\n").length) {
                    return this.parseOpera9(e);
                  } else if (!e.stack) {
                    return this.parseOpera10(e);
                  } else {
                    return this.parseOpera11(e);
                  }
                },
                parseOpera9: function ErrorStackParser$$parseOpera9(e) {
                  var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
                  var lines = e.message.split("\n");
                  var result = [];
                  for (var i = 2, len = lines.length; i < len; i += 2) {
                    var match = lineRE.exec(lines[i]);
                    if (match) {
                      result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                      }));
                    }
                  }
                  return result;
                },
                parseOpera10: function ErrorStackParser$$parseOpera10(e) {
                  var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
                  var lines = e.stacktrace.split("\n");
                  var result = [];
                  for (var i = 0, len = lines.length; i < len; i += 2) {
                    var match = lineRE.exec(lines[i]);
                    if (match) {
                      result.push(new StackFrame({
                        functionName: match[3] || void 0,
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                      }));
                    }
                  }
                  return result;
                },
                // Opera 10.65+ Error.stack very similar to FF/Safari
                parseOpera11: function ErrorStackParser$$parseOpera11(error) {
                  var filtered = error.stack.split("\n").filter(function(line) {
                    return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
                  }, this);
                  return filtered.map(function(line) {
                    var tokens = line.split("@");
                    var locationParts = this.extractLocation(tokens.pop());
                    var functionCall = tokens.shift() || "";
                    var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
                    var argsRaw;
                    if (functionCall.match(/\(([^)]*)\)/)) {
                      argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
                    }
                    var args = argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(",");
                    return new StackFrame({
                      functionName,
                      args,
                      fileName: locationParts[0],
                      lineNumber: locationParts[1],
                      columnNumber: locationParts[2],
                      source: line
                    });
                  }, this);
                }
              };
            });
          }
        ),
        /***/
        172: (
          /***/
          (module2) => {
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            var FUNC_ERROR_TEXT = "Expected a function";
            var NAN = 0 / 0;
            var symbolTag = "[object Symbol]";
            var reTrim = /^\s+|\s+$/g;
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
            var reIsBinary = /^0b[01]+$/i;
            var reIsOctal = /^0o[0-7]+$/i;
            var freeParseInt = parseInt;
            var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global && global.Object === Object && global;
            var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == "object" && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            var objectProto = Object.prototype;
            var objectToString = objectProto.toString;
            var nativeMax = Math.max, nativeMin = Math.min;
            var now = function now2() {
              return root.Date.now();
            };
            function debounce(func, wait, options) {
              var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
              if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              wait = toNumber(wait) || 0;
              if (isObject(options)) {
                leading = !!options.leading;
                maxing = "maxWait" in options;
                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = "trailing" in options ? !!options.trailing : trailing;
              }
              function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                lastArgs = lastThis = void 0;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result;
              }
              function leadingEdge(time) {
                lastInvokeTime = time;
                timerId = setTimeout(timerExpired, wait);
                return leading ? invokeFunc(time) : result;
              }
              function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
                return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
              }
              function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
              }
              function timerExpired() {
                var time = now();
                if (shouldInvoke(time)) {
                  return trailingEdge(time);
                }
                timerId = setTimeout(timerExpired, remainingWait(time));
              }
              function trailingEdge(time) {
                timerId = void 0;
                if (trailing && lastArgs) {
                  return invokeFunc(time);
                }
                lastArgs = lastThis = void 0;
                return result;
              }
              function cancel() {
                if (timerId !== void 0) {
                  clearTimeout(timerId);
                }
                lastInvokeTime = 0;
                lastArgs = lastCallTime = lastThis = timerId = void 0;
              }
              function flush() {
                return timerId === void 0 ? result : trailingEdge(now());
              }
              function debounced() {
                var time = now(), isInvoking = shouldInvoke(time);
                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;
                if (isInvoking) {
                  if (timerId === void 0) {
                    return leadingEdge(lastCallTime);
                  }
                  if (maxing) {
                    timerId = setTimeout(timerExpired, wait);
                    return invokeFunc(lastCallTime);
                  }
                }
                if (timerId === void 0) {
                  timerId = setTimeout(timerExpired, wait);
                }
                return result;
              }
              debounced.cancel = cancel;
              debounced.flush = flush;
              return debounced;
            }
            function throttle(func, wait, options) {
              var leading = true, trailing = true;
              if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (isObject(options)) {
                leading = "leading" in options ? !!options.leading : leading;
                trailing = "trailing" in options ? !!options.trailing : trailing;
              }
              return debounce(func, wait, {
                "leading": leading,
                "maxWait": wait,
                "trailing": trailing
              });
            }
            function isObject(value) {
              var type = _typeof(value);
              return !!value && (type == "object" || type == "function");
            }
            function isObjectLike(value) {
              return !!value && _typeof(value) == "object";
            }
            function isSymbol(value) {
              return _typeof(value) == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
            }
            function toNumber(value) {
              if (typeof value == "number") {
                return value;
              }
              if (isSymbol(value)) {
                return NAN;
              }
              if (isObject(value)) {
                var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                value = isObject(other) ? other + "" : other;
              }
              if (typeof value != "string") {
                return value === 0 ? value : +value;
              }
              value = value.replace(reTrim, "");
              var isBinary = reIsBinary.test(value);
              return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
            }
            module2.exports = throttle;
          }
        ),
        /***/
        730: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var process2 = __webpack_require__2(169);
            module2.exports = LRUCache;
            var Map2 = __webpack_require__2(307);
            var util = __webpack_require__2(82);
            var Yallist = __webpack_require__2(695);
            var hasSymbol = typeof Symbol === "function" && process2.env._nodeLRUCacheForceNoSymbol !== "1";
            var makeSymbol;
            if (hasSymbol) {
              makeSymbol = function makeSymbol2(key) {
                return Symbol(key);
              };
            } else {
              makeSymbol = function makeSymbol2(key) {
                return "_" + key;
              };
            }
            var MAX = makeSymbol("max");
            var LENGTH = makeSymbol("length");
            var LENGTH_CALCULATOR = makeSymbol("lengthCalculator");
            var ALLOW_STALE = makeSymbol("allowStale");
            var MAX_AGE = makeSymbol("maxAge");
            var DISPOSE = makeSymbol("dispose");
            var NO_DISPOSE_ON_SET = makeSymbol("noDisposeOnSet");
            var LRU_LIST = makeSymbol("lruList");
            var CACHE = makeSymbol("cache");
            function naiveLength() {
              return 1;
            }
            function LRUCache(options) {
              if (!(this instanceof LRUCache)) {
                return new LRUCache(options);
              }
              if (typeof options === "number") {
                options = {
                  max: options
                };
              }
              if (!options) {
                options = {};
              }
              var max = this[MAX] = options.max;
              if (!max || !(typeof max === "number") || max <= 0) {
                this[MAX] = Infinity;
              }
              var lc = options.length || naiveLength;
              if (typeof lc !== "function") {
                lc = naiveLength;
              }
              this[LENGTH_CALCULATOR] = lc;
              this[ALLOW_STALE] = options.stale || false;
              this[MAX_AGE] = options.maxAge || 0;
              this[DISPOSE] = options.dispose;
              this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
              this.reset();
            }
            Object.defineProperty(LRUCache.prototype, "max", {
              set: function set(mL) {
                if (!mL || !(typeof mL === "number") || mL <= 0) {
                  mL = Infinity;
                }
                this[MAX] = mL;
                trim(this);
              },
              get: function get2() {
                return this[MAX];
              },
              enumerable: true
            });
            Object.defineProperty(LRUCache.prototype, "allowStale", {
              set: function set(allowStale) {
                this[ALLOW_STALE] = !!allowStale;
              },
              get: function get2() {
                return this[ALLOW_STALE];
              },
              enumerable: true
            });
            Object.defineProperty(LRUCache.prototype, "maxAge", {
              set: function set(mA) {
                if (!mA || !(typeof mA === "number") || mA < 0) {
                  mA = 0;
                }
                this[MAX_AGE] = mA;
                trim(this);
              },
              get: function get2() {
                return this[MAX_AGE];
              },
              enumerable: true
            });
            Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
              set: function set(lC) {
                if (typeof lC !== "function") {
                  lC = naiveLength;
                }
                if (lC !== this[LENGTH_CALCULATOR]) {
                  this[LENGTH_CALCULATOR] = lC;
                  this[LENGTH] = 0;
                  this[LRU_LIST].forEach(function(hit) {
                    hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
                    this[LENGTH] += hit.length;
                  }, this);
                }
                trim(this);
              },
              get: function get2() {
                return this[LENGTH_CALCULATOR];
              },
              enumerable: true
            });
            Object.defineProperty(LRUCache.prototype, "length", {
              get: function get2() {
                return this[LENGTH];
              },
              enumerable: true
            });
            Object.defineProperty(LRUCache.prototype, "itemCount", {
              get: function get2() {
                return this[LRU_LIST].length;
              },
              enumerable: true
            });
            LRUCache.prototype.rforEach = function(fn, thisp) {
              thisp = thisp || this;
              for (var walker = this[LRU_LIST].tail; walker !== null; ) {
                var prev = walker.prev;
                forEachStep(this, fn, walker, thisp);
                walker = prev;
              }
            };
            function forEachStep(self2, fn, node, thisp) {
              var hit = node.value;
              if (isStale(self2, hit)) {
                del(self2, node);
                if (!self2[ALLOW_STALE]) {
                  hit = void 0;
                }
              }
              if (hit) {
                fn.call(thisp, hit.value, hit.key, self2);
              }
            }
            LRUCache.prototype.forEach = function(fn, thisp) {
              thisp = thisp || this;
              for (var walker = this[LRU_LIST].head; walker !== null; ) {
                var next = walker.next;
                forEachStep(this, fn, walker, thisp);
                walker = next;
              }
            };
            LRUCache.prototype.keys = function() {
              return this[LRU_LIST].toArray().map(function(k) {
                return k.key;
              }, this);
            };
            LRUCache.prototype.values = function() {
              return this[LRU_LIST].toArray().map(function(k) {
                return k.value;
              }, this);
            };
            LRUCache.prototype.reset = function() {
              if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
                this[LRU_LIST].forEach(function(hit) {
                  this[DISPOSE](hit.key, hit.value);
                }, this);
              }
              this[CACHE] = new Map2();
              this[LRU_LIST] = new Yallist();
              this[LENGTH] = 0;
            };
            LRUCache.prototype.dump = function() {
              return this[LRU_LIST].map(function(hit) {
                if (!isStale(this, hit)) {
                  return {
                    k: hit.key,
                    v: hit.value,
                    e: hit.now + (hit.maxAge || 0)
                  };
                }
              }, this).toArray().filter(function(h) {
                return h;
              });
            };
            LRUCache.prototype.dumpLru = function() {
              return this[LRU_LIST];
            };
            LRUCache.prototype.inspect = function(n, opts) {
              var str = "LRUCache {";
              var extras = false;
              var as = this[ALLOW_STALE];
              if (as) {
                str += "\n  allowStale: true";
                extras = true;
              }
              var max = this[MAX];
              if (max && max !== Infinity) {
                if (extras) {
                  str += ",";
                }
                str += "\n  max: " + util.inspect(max, opts);
                extras = true;
              }
              var maxAge = this[MAX_AGE];
              if (maxAge) {
                if (extras) {
                  str += ",";
                }
                str += "\n  maxAge: " + util.inspect(maxAge, opts);
                extras = true;
              }
              var lc = this[LENGTH_CALCULATOR];
              if (lc && lc !== naiveLength) {
                if (extras) {
                  str += ",";
                }
                str += "\n  length: " + util.inspect(this[LENGTH], opts);
                extras = true;
              }
              var didFirst = false;
              this[LRU_LIST].forEach(function(item) {
                if (didFirst) {
                  str += ",\n  ";
                } else {
                  if (extras) {
                    str += ",\n";
                  }
                  didFirst = true;
                  str += "\n  ";
                }
                var key = util.inspect(item.key).split("\n").join("\n  ");
                var val = {
                  value: item.value
                };
                if (item.maxAge !== maxAge) {
                  val.maxAge = item.maxAge;
                }
                if (lc !== naiveLength) {
                  val.length = item.length;
                }
                if (isStale(this, item)) {
                  val.stale = true;
                }
                val = util.inspect(val, opts).split("\n").join("\n  ");
                str += key + " => " + val;
              });
              if (didFirst || extras) {
                str += "\n";
              }
              str += "}";
              return str;
            };
            LRUCache.prototype.set = function(key, value, maxAge) {
              maxAge = maxAge || this[MAX_AGE];
              var now = maxAge ? Date.now() : 0;
              var len = this[LENGTH_CALCULATOR](value, key);
              if (this[CACHE].has(key)) {
                if (len > this[MAX]) {
                  del(this, this[CACHE].get(key));
                  return false;
                }
                var node = this[CACHE].get(key);
                var item = node.value;
                if (this[DISPOSE]) {
                  if (!this[NO_DISPOSE_ON_SET]) {
                    this[DISPOSE](key, item.value);
                  }
                }
                item.now = now;
                item.maxAge = maxAge;
                item.value = value;
                this[LENGTH] += len - item.length;
                item.length = len;
                this.get(key);
                trim(this);
                return true;
              }
              var hit = new Entry(key, value, len, now, maxAge);
              if (hit.length > this[MAX]) {
                if (this[DISPOSE]) {
                  this[DISPOSE](key, value);
                }
                return false;
              }
              this[LENGTH] += hit.length;
              this[LRU_LIST].unshift(hit);
              this[CACHE].set(key, this[LRU_LIST].head);
              trim(this);
              return true;
            };
            LRUCache.prototype.has = function(key) {
              if (!this[CACHE].has(key))
                return false;
              var hit = this[CACHE].get(key).value;
              if (isStale(this, hit)) {
                return false;
              }
              return true;
            };
            LRUCache.prototype.get = function(key) {
              return get(this, key, true);
            };
            LRUCache.prototype.peek = function(key) {
              return get(this, key, false);
            };
            LRUCache.prototype.pop = function() {
              var node = this[LRU_LIST].tail;
              if (!node)
                return null;
              del(this, node);
              return node.value;
            };
            LRUCache.prototype.del = function(key) {
              del(this, this[CACHE].get(key));
            };
            LRUCache.prototype.load = function(arr) {
              this.reset();
              var now = Date.now();
              for (var l = arr.length - 1; l >= 0; l--) {
                var hit = arr[l];
                var expiresAt = hit.e || 0;
                if (expiresAt === 0) {
                  this.set(hit.k, hit.v);
                } else {
                  var maxAge = expiresAt - now;
                  if (maxAge > 0) {
                    this.set(hit.k, hit.v, maxAge);
                  }
                }
              }
            };
            LRUCache.prototype.prune = function() {
              var self2 = this;
              this[CACHE].forEach(function(value, key) {
                get(self2, key, false);
              });
            };
            function get(self2, key, doUse) {
              var node = self2[CACHE].get(key);
              if (node) {
                var hit = node.value;
                if (isStale(self2, hit)) {
                  del(self2, node);
                  if (!self2[ALLOW_STALE])
                    hit = void 0;
                } else {
                  if (doUse) {
                    self2[LRU_LIST].unshiftNode(node);
                  }
                }
                if (hit)
                  hit = hit.value;
              }
              return hit;
            }
            function isStale(self2, hit) {
              if (!hit || !hit.maxAge && !self2[MAX_AGE]) {
                return false;
              }
              var stale = false;
              var diff = Date.now() - hit.now;
              if (hit.maxAge) {
                stale = diff > hit.maxAge;
              } else {
                stale = self2[MAX_AGE] && diff > self2[MAX_AGE];
              }
              return stale;
            }
            function trim(self2) {
              if (self2[LENGTH] > self2[MAX]) {
                for (var walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
                  var prev = walker.prev;
                  del(self2, walker);
                  walker = prev;
                }
              }
            }
            function del(self2, node) {
              if (node) {
                var hit = node.value;
                if (self2[DISPOSE]) {
                  self2[DISPOSE](hit.key, hit.value);
                }
                self2[LENGTH] -= hit.length;
                self2[CACHE].delete(hit.key);
                self2[LRU_LIST].removeNode(node);
              }
            }
            function Entry(key, value, length, now, maxAge) {
              this.key = key;
              this.value = value;
              this.length = length;
              this.now = now;
              this.maxAge = maxAge || 0;
            }
          }
        ),
        /***/
        169: (
          /***/
          (module2) => {
            var process2 = module2.exports = {};
            var cachedSetTimeout;
            var cachedClearTimeout;
            function defaultSetTimout() {
              throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
              throw new Error("clearTimeout has not been defined");
            }
            (function() {
              try {
                if (typeof setTimeout === "function") {
                  cachedSetTimeout = setTimeout;
                } else {
                  cachedSetTimeout = defaultSetTimout;
                }
              } catch (e) {
                cachedSetTimeout = defaultSetTimout;
              }
              try {
                if (typeof clearTimeout === "function") {
                  cachedClearTimeout = clearTimeout;
                } else {
                  cachedClearTimeout = defaultClearTimeout;
                }
              } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
              }
            })();
            function runTimeout(fun) {
              if (cachedSetTimeout === setTimeout) {
                return setTimeout(fun, 0);
              }
              if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
              }
              try {
                return cachedSetTimeout(fun, 0);
              } catch (e) {
                try {
                  return cachedSetTimeout.call(null, fun, 0);
                } catch (e2) {
                  return cachedSetTimeout.call(this, fun, 0);
                }
              }
            }
            function runClearTimeout(marker) {
              if (cachedClearTimeout === clearTimeout) {
                return clearTimeout(marker);
              }
              if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
              }
              try {
                return cachedClearTimeout(marker);
              } catch (e) {
                try {
                  return cachedClearTimeout.call(null, marker);
                } catch (e2) {
                  return cachedClearTimeout.call(this, marker);
                }
              }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;
            function cleanUpNextTick() {
              if (!draining || !currentQueue) {
                return;
              }
              draining = false;
              if (currentQueue.length) {
                queue = currentQueue.concat(queue);
              } else {
                queueIndex = -1;
              }
              if (queue.length) {
                drainQueue();
              }
            }
            function drainQueue() {
              if (draining) {
                return;
              }
              var timeout = runTimeout(cleanUpNextTick);
              draining = true;
              var len = queue.length;
              while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                  if (currentQueue) {
                    currentQueue[queueIndex].run();
                  }
                }
                queueIndex = -1;
                len = queue.length;
              }
              currentQueue = null;
              draining = false;
              runClearTimeout(timeout);
            }
            process2.nextTick = function(fun) {
              var args = new Array(arguments.length - 1);
              if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                  args[i - 1] = arguments[i];
                }
              }
              queue.push(new Item(fun, args));
              if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
              }
            };
            function Item(fun, array) {
              this.fun = fun;
              this.array = array;
            }
            Item.prototype.run = function() {
              this.fun.apply(null, this.array);
            };
            process2.title = "browser";
            process2.browser = true;
            process2.env = {};
            process2.argv = [];
            process2.version = "";
            process2.versions = {};
            function noop() {
            }
            process2.on = noop;
            process2.addListener = noop;
            process2.once = noop;
            process2.off = noop;
            process2.removeListener = noop;
            process2.removeAllListeners = noop;
            process2.emit = noop;
            process2.prependListener = noop;
            process2.prependOnceListener = noop;
            process2.listeners = function(name) {
              return [];
            };
            process2.binding = function(name) {
              throw new Error("process.binding is not supported");
            };
            process2.cwd = function() {
              return "/";
            };
            process2.chdir = function(dir) {
              throw new Error("process.chdir is not supported");
            };
            process2.umask = function() {
              return 0;
            };
          }
        ),
        /***/
        307: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            var process2 = __webpack_require__2(169);
            if (process2.env.npm_package_name === "pseudomap" && process2.env.npm_lifecycle_script === "test")
              process2.env.TEST_PSEUDOMAP = "true";
            if (typeof Map === "function" && !process2.env.TEST_PSEUDOMAP) {
              module2.exports = Map;
            } else {
              module2.exports = __webpack_require__2(761);
            }
          }
        ),
        /***/
        761: (
          /***/
          (module2) => {
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            module2.exports = PseudoMap;
            function PseudoMap(set2) {
              if (!(this instanceof PseudoMap))
                throw new TypeError("Constructor PseudoMap requires 'new'");
              this.clear();
              if (set2) {
                if (set2 instanceof PseudoMap || typeof Map === "function" && set2 instanceof Map)
                  set2.forEach(function(value, key) {
                    this.set(key, value);
                  }, this);
                else if (Array.isArray(set2))
                  set2.forEach(function(kv) {
                    this.set(kv[0], kv[1]);
                  }, this);
                else
                  throw new TypeError("invalid argument");
              }
            }
            PseudoMap.prototype.forEach = function(fn, thisp) {
              thisp = thisp || this;
              Object.keys(this._data).forEach(function(k) {
                if (k !== "size")
                  fn.call(thisp, this._data[k].value, this._data[k].key);
              }, this);
            };
            PseudoMap.prototype.has = function(k) {
              return !!find(this._data, k);
            };
            PseudoMap.prototype.get = function(k) {
              var res = find(this._data, k);
              return res && res.value;
            };
            PseudoMap.prototype.set = function(k, v) {
              set(this._data, k, v);
            };
            PseudoMap.prototype.delete = function(k) {
              var res = find(this._data, k);
              if (res) {
                delete this._data[res._index];
                this._data.size--;
              }
            };
            PseudoMap.prototype.clear = function() {
              var data = /* @__PURE__ */ Object.create(null);
              data.size = 0;
              Object.defineProperty(this, "_data", {
                value: data,
                enumerable: false,
                configurable: true,
                writable: false
              });
            };
            Object.defineProperty(PseudoMap.prototype, "size", {
              get: function get() {
                return this._data.size;
              },
              set: function set2(n) {
              },
              enumerable: true,
              configurable: true
            });
            PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
              throw new Error("iterators are not implemented in this version");
            };
            function same(a, b) {
              return a === b || a !== a && b !== b;
            }
            function Entry(k, v, i) {
              this.key = k;
              this.value = v;
              this._index = i;
            }
            function find(data, k) {
              for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
                if (same(data[key].key, k))
                  return data[key];
              }
            }
            function set(data, k, v) {
              for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
                if (same(data[key].key, k)) {
                  data[key].value = v;
                  return;
                }
              }
              data.size++;
              data[key] = new Entry(k, v, key);
            }
          }
        ),
        /***/
        430: (
          /***/
          function(module2, exports2) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            (function(root, factory) {
              "use strict";
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else {
              }
            })(this, function() {
              "use strict";
              function _isNumber(n) {
                return !isNaN(parseFloat(n)) && isFinite(n);
              }
              function _capitalize(str) {
                return str.charAt(0).toUpperCase() + str.substring(1);
              }
              function _getter(p) {
                return function() {
                  return this[p];
                };
              }
              var booleanProps = ["isConstructor", "isEval", "isNative", "isToplevel"];
              var numericProps = ["columnNumber", "lineNumber"];
              var stringProps = ["fileName", "functionName", "source"];
              var arrayProps = ["args"];
              var props = booleanProps.concat(numericProps, stringProps, arrayProps);
              function StackFrame(obj) {
                if (!obj)
                  return;
                for (var i2 = 0; i2 < props.length; i2++) {
                  if (obj[props[i2]] !== void 0) {
                    this["set" + _capitalize(props[i2])](obj[props[i2]]);
                  }
                }
              }
              StackFrame.prototype = {
                getArgs: function getArgs() {
                  return this.args;
                },
                setArgs: function setArgs(v) {
                  if (Object.prototype.toString.call(v) !== "[object Array]") {
                    throw new TypeError("Args must be an Array");
                  }
                  this.args = v;
                },
                getEvalOrigin: function getEvalOrigin() {
                  return this.evalOrigin;
                },
                setEvalOrigin: function setEvalOrigin(v) {
                  if (v instanceof StackFrame) {
                    this.evalOrigin = v;
                  } else if (v instanceof Object) {
                    this.evalOrigin = new StackFrame(v);
                  } else {
                    throw new TypeError("Eval Origin must be an Object or StackFrame");
                  }
                },
                toString: function toString() {
                  var fileName = this.getFileName() || "";
                  var lineNumber = this.getLineNumber() || "";
                  var columnNumber = this.getColumnNumber() || "";
                  var functionName = this.getFunctionName() || "";
                  if (this.getIsEval()) {
                    if (fileName) {
                      return "[eval] (" + fileName + ":" + lineNumber + ":" + columnNumber + ")";
                    }
                    return "[eval]:" + lineNumber + ":" + columnNumber;
                  }
                  if (functionName) {
                    return functionName + " (" + fileName + ":" + lineNumber + ":" + columnNumber + ")";
                  }
                  return fileName + ":" + lineNumber + ":" + columnNumber;
                }
              };
              StackFrame.fromString = function StackFrame$$fromString(str) {
                var argsStartIndex = str.indexOf("(");
                var argsEndIndex = str.lastIndexOf(")");
                var functionName = str.substring(0, argsStartIndex);
                var args = str.substring(argsStartIndex + 1, argsEndIndex).split(",");
                var locationString = str.substring(argsEndIndex + 1);
                if (locationString.indexOf("@") === 0) {
                  var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, "");
                  var fileName = parts[1];
                  var lineNumber = parts[2];
                  var columnNumber = parts[3];
                }
                return new StackFrame({
                  functionName,
                  args: args || void 0,
                  fileName,
                  lineNumber: lineNumber || void 0,
                  columnNumber: columnNumber || void 0
                });
              };
              for (var i = 0; i < booleanProps.length; i++) {
                StackFrame.prototype["get" + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
                StackFrame.prototype["set" + _capitalize(booleanProps[i])] = function(p) {
                  return function(v) {
                    this[p] = Boolean(v);
                  };
                }(booleanProps[i]);
              }
              for (var j = 0; j < numericProps.length; j++) {
                StackFrame.prototype["get" + _capitalize(numericProps[j])] = _getter(numericProps[j]);
                StackFrame.prototype["set" + _capitalize(numericProps[j])] = function(p) {
                  return function(v) {
                    if (!_isNumber(v)) {
                      throw new TypeError(p + " must be a Number");
                    }
                    this[p] = Number(v);
                  };
                }(numericProps[j]);
              }
              for (var k = 0; k < stringProps.length; k++) {
                StackFrame.prototype["get" + _capitalize(stringProps[k])] = _getter(stringProps[k]);
                StackFrame.prototype["set" + _capitalize(stringProps[k])] = function(p) {
                  return function(v) {
                    this[p] = String(v);
                  };
                }(stringProps[k]);
              }
              return StackFrame;
            });
          }
        ),
        /***/
        718: (
          /***/
          (module2) => {
            if (typeof Object.create === "function") {
              module2.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
              };
            } else {
              module2.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function TempCtor2() {
                };
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
              };
            }
          }
        ),
        /***/
        715: (
          /***/
          (module2) => {
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            module2.exports = function isBuffer(arg) {
              return arg && _typeof(arg) === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
            };
          }
        ),
        /***/
        82: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            var process2 = __webpack_require__2(169);
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            var formatRegExp = /%[sdj%]/g;
            exports2.format = function(f) {
              if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(" ");
              }
              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function(x2) {
                if (x2 === "%%")
                  return "%";
                if (i >= len)
                  return x2;
                switch (x2) {
                  case "%s":
                    return String(args[i++]);
                  case "%d":
                    return Number(args[i++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return "[Circular]";
                    }
                  default:
                    return x2;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += " " + x;
                } else {
                  str += " " + inspect(x);
                }
              }
              return str;
            };
            exports2.deprecate = function(fn, msg) {
              if (isUndefined(global.process)) {
                return function() {
                  return exports2.deprecate(fn, msg).apply(this, arguments);
                };
              }
              if (process2.noDeprecation === true) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process2.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process2.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            };
            var debugs = {};
            var debugEnviron;
            exports2.debuglog = function(set) {
              if (isUndefined(debugEnviron))
                debugEnviron = process2.env.NODE_DEBUG || "";
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                  var pid = process2.pid;
                  debugs[set] = function() {
                    var msg = exports2.format.apply(exports2, arguments);
                    console.error("%s %d: %s", set, pid, msg);
                  };
                } else {
                  debugs[set] = function() {
                  };
                }
              }
              return debugs[set];
            };
            function inspect(obj, opts) {
              var ctx = {
                seen: [],
                stylize: stylizeNoColor
              };
              if (arguments.length >= 3)
                ctx.depth = arguments[2];
              if (arguments.length >= 4)
                ctx.colors = arguments[3];
              if (isBoolean(opts)) {
                ctx.showHidden = opts;
              } else if (opts) {
                exports2._extend(ctx, opts);
              }
              if (isUndefined(ctx.showHidden))
                ctx.showHidden = false;
              if (isUndefined(ctx.depth))
                ctx.depth = 2;
              if (isUndefined(ctx.colors))
                ctx.colors = false;
              if (isUndefined(ctx.customInspect))
                ctx.customInspect = true;
              if (ctx.colors)
                ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports2.inspect = inspect;
            inspect.colors = {
              "bold": [1, 22],
              "italic": [3, 23],
              "underline": [4, 24],
              "inverse": [7, 27],
              "white": [37, 39],
              "grey": [90, 39],
              "black": [30, 39],
              "blue": [34, 39],
              "cyan": [36, 39],
              "green": [32, 39],
              "magenta": [35, 39],
              "red": [31, 39],
              "yellow": [33, 39]
            };
            inspect.styles = {
              "special": "cyan",
              "number": "yellow",
              "boolean": "yellow",
              "undefined": "grey",
              "null": "bold",
              "string": "green",
              "date": "magenta",
              // "name": intentionally not styling
              "regexp": "red"
            };
            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];
              if (style) {
                return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
              } else {
                return str;
              }
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array) {
              var hash = {};
              array.forEach(function(val, idx) {
                hash[val] = true;
              });
              return hash;
            }
            function formatValue(ctx, value, recurseTimes) {
              if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
              value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);
              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }
              if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                return formatError(value);
              }
              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name + "]", "special");
                }
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                }
                if (isDate(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), "date");
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }
              var base = "", array = false, braces = ["{", "}"];
              if (isArray(value)) {
                array = true;
                braces = ["[", "]"];
              }
              if (isFunction(value)) {
                var n = value.name ? ": " + value.name : "";
                base = " [Function" + n + "]";
              }
              if (isRegExp(value)) {
                base = " " + RegExp.prototype.toString.call(value);
              }
              if (isDate(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
              }
              if (isError(value)) {
                base = " " + formatError(value);
              }
              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }
              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                } else {
                  return ctx.stylize("[Object]", "special");
                }
              }
              ctx.seen.push(value);
              var output;
              if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
              }
              ctx.seen.pop();
              return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize("undefined", "undefined");
              if (isString(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              }
              if (isNumber(value))
                return ctx.stylize("" + value, "number");
              if (isBoolean(value))
                return ctx.stylize("" + value, "boolean");
              if (isNull(value))
                return ctx.stylize("null", "null");
            }
            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                } else {
                  output.push("");
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                }
              });
              return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || {
                value: value[key]
              };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                  str = ctx.stylize("[Getter]", "special");
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize("[Setter]", "special");
                }
              }
              if (!hasOwnProperty(visibleKeys, key)) {
                name = "[" + key + "]";
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf("\n") > -1) {
                    if (array) {
                      str = str.split("\n").map(function(line) {
                        return "  " + line;
                      }).join("\n").substr(2);
                    } else {
                      str = "\n" + str.split("\n").map(function(line) {
                        return "   " + line;
                      }).join("\n");
                    }
                  }
                } else {
                  str = ctx.stylize("[Circular]", "special");
                }
              }
              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify("" + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, "name");
                } else {
                  name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, "string");
                }
              }
              return name + ": " + str;
            }
            function reduceToSingleString(output, base, braces) {
              var numLinesEst = 0;
              var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf("\n") >= 0)
                  numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              if (length > 60) {
                return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
              }
              return braces[0] + base + " " + output.join(", ") + " " + braces[1];
            }
            function isArray(ar) {
              return Array.isArray(ar);
            }
            exports2.isArray = isArray;
            function isBoolean(arg) {
              return typeof arg === "boolean";
            }
            exports2.isBoolean = isBoolean;
            function isNull(arg) {
              return arg === null;
            }
            exports2.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports2.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
              return typeof arg === "number";
            }
            exports2.isNumber = isNumber;
            function isString(arg) {
              return typeof arg === "string";
            }
            exports2.isString = isString;
            function isSymbol(arg) {
              return _typeof(arg) === "symbol";
            }
            exports2.isSymbol = isSymbol;
            function isUndefined(arg) {
              return arg === void 0;
            }
            exports2.isUndefined = isUndefined;
            function isRegExp(re) {
              return isObject(re) && objectToString(re) === "[object RegExp]";
            }
            exports2.isRegExp = isRegExp;
            function isObject(arg) {
              return _typeof(arg) === "object" && arg !== null;
            }
            exports2.isObject = isObject;
            function isDate(d) {
              return isObject(d) && objectToString(d) === "[object Date]";
            }
            exports2.isDate = isDate;
            function isError(e) {
              return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
            }
            exports2.isError = isError;
            function isFunction(arg) {
              return typeof arg === "function";
            }
            exports2.isFunction = isFunction;
            function isPrimitive(arg) {
              return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || _typeof(arg) === "symbol" || // ES6 symbol
              typeof arg === "undefined";
            }
            exports2.isPrimitive = isPrimitive;
            exports2.isBuffer = __webpack_require__2(715);
            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }
            function pad(n) {
              return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }
            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            function timestamp() {
              var d = /* @__PURE__ */ new Date();
              var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
              return [d.getDate(), months[d.getMonth()], time].join(" ");
            }
            exports2.log = function() {
              console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
            };
            exports2.inherits = __webpack_require__2(718);
            exports2._extend = function(origin, add) {
              if (!add || !isObject(add))
                return origin;
              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            };
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
          }
        ),
        /***/
        695: (
          /***/
          (module2) => {
            module2.exports = Yallist;
            Yallist.Node = Node2;
            Yallist.create = Yallist;
            function Yallist(list) {
              var self2 = this;
              if (!(self2 instanceof Yallist)) {
                self2 = new Yallist();
              }
              self2.tail = null;
              self2.head = null;
              self2.length = 0;
              if (list && typeof list.forEach === "function") {
                list.forEach(function(item) {
                  self2.push(item);
                });
              } else if (arguments.length > 0) {
                for (var i = 0, l = arguments.length; i < l; i++) {
                  self2.push(arguments[i]);
                }
              }
              return self2;
            }
            Yallist.prototype.removeNode = function(node) {
              if (node.list !== this) {
                throw new Error("removing node which does not belong to this list");
              }
              var next = node.next;
              var prev = node.prev;
              if (next) {
                next.prev = prev;
              }
              if (prev) {
                prev.next = next;
              }
              if (node === this.head) {
                this.head = next;
              }
              if (node === this.tail) {
                this.tail = prev;
              }
              node.list.length--;
              node.next = null;
              node.prev = null;
              node.list = null;
            };
            Yallist.prototype.unshiftNode = function(node) {
              if (node === this.head) {
                return;
              }
              if (node.list) {
                node.list.removeNode(node);
              }
              var head = this.head;
              node.list = this;
              node.next = head;
              if (head) {
                head.prev = node;
              }
              this.head = node;
              if (!this.tail) {
                this.tail = node;
              }
              this.length++;
            };
            Yallist.prototype.pushNode = function(node) {
              if (node === this.tail) {
                return;
              }
              if (node.list) {
                node.list.removeNode(node);
              }
              var tail = this.tail;
              node.list = this;
              node.prev = tail;
              if (tail) {
                tail.next = node;
              }
              this.tail = node;
              if (!this.head) {
                this.head = node;
              }
              this.length++;
            };
            Yallist.prototype.push = function() {
              for (var i = 0, l = arguments.length; i < l; i++) {
                push(this, arguments[i]);
              }
              return this.length;
            };
            Yallist.prototype.unshift = function() {
              for (var i = 0, l = arguments.length; i < l; i++) {
                unshift(this, arguments[i]);
              }
              return this.length;
            };
            Yallist.prototype.pop = function() {
              if (!this.tail) {
                return void 0;
              }
              var res = this.tail.value;
              this.tail = this.tail.prev;
              if (this.tail) {
                this.tail.next = null;
              } else {
                this.head = null;
              }
              this.length--;
              return res;
            };
            Yallist.prototype.shift = function() {
              if (!this.head) {
                return void 0;
              }
              var res = this.head.value;
              this.head = this.head.next;
              if (this.head) {
                this.head.prev = null;
              } else {
                this.tail = null;
              }
              this.length--;
              return res;
            };
            Yallist.prototype.forEach = function(fn, thisp) {
              thisp = thisp || this;
              for (var walker = this.head, i = 0; walker !== null; i++) {
                fn.call(thisp, walker.value, i, this);
                walker = walker.next;
              }
            };
            Yallist.prototype.forEachReverse = function(fn, thisp) {
              thisp = thisp || this;
              for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
                fn.call(thisp, walker.value, i, this);
                walker = walker.prev;
              }
            };
            Yallist.prototype.get = function(n) {
              for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
                walker = walker.next;
              }
              if (i === n && walker !== null) {
                return walker.value;
              }
            };
            Yallist.prototype.getReverse = function(n) {
              for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
                walker = walker.prev;
              }
              if (i === n && walker !== null) {
                return walker.value;
              }
            };
            Yallist.prototype.map = function(fn, thisp) {
              thisp = thisp || this;
              var res = new Yallist();
              for (var walker = this.head; walker !== null; ) {
                res.push(fn.call(thisp, walker.value, this));
                walker = walker.next;
              }
              return res;
            };
            Yallist.prototype.mapReverse = function(fn, thisp) {
              thisp = thisp || this;
              var res = new Yallist();
              for (var walker = this.tail; walker !== null; ) {
                res.push(fn.call(thisp, walker.value, this));
                walker = walker.prev;
              }
              return res;
            };
            Yallist.prototype.reduce = function(fn, initial) {
              var acc;
              var walker = this.head;
              if (arguments.length > 1) {
                acc = initial;
              } else if (this.head) {
                walker = this.head.next;
                acc = this.head.value;
              } else {
                throw new TypeError("Reduce of empty list with no initial value");
              }
              for (var i = 0; walker !== null; i++) {
                acc = fn(acc, walker.value, i);
                walker = walker.next;
              }
              return acc;
            };
            Yallist.prototype.reduceReverse = function(fn, initial) {
              var acc;
              var walker = this.tail;
              if (arguments.length > 1) {
                acc = initial;
              } else if (this.tail) {
                walker = this.tail.prev;
                acc = this.tail.value;
              } else {
                throw new TypeError("Reduce of empty list with no initial value");
              }
              for (var i = this.length - 1; walker !== null; i--) {
                acc = fn(acc, walker.value, i);
                walker = walker.prev;
              }
              return acc;
            };
            Yallist.prototype.toArray = function() {
              var arr = new Array(this.length);
              for (var i = 0, walker = this.head; walker !== null; i++) {
                arr[i] = walker.value;
                walker = walker.next;
              }
              return arr;
            };
            Yallist.prototype.toArrayReverse = function() {
              var arr = new Array(this.length);
              for (var i = 0, walker = this.tail; walker !== null; i++) {
                arr[i] = walker.value;
                walker = walker.prev;
              }
              return arr;
            };
            Yallist.prototype.slice = function(from, to) {
              to = to || this.length;
              if (to < 0) {
                to += this.length;
              }
              from = from || 0;
              if (from < 0) {
                from += this.length;
              }
              var ret = new Yallist();
              if (to < from || to < 0) {
                return ret;
              }
              if (from < 0) {
                from = 0;
              }
              if (to > this.length) {
                to = this.length;
              }
              for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
                walker = walker.next;
              }
              for (; walker !== null && i < to; i++, walker = walker.next) {
                ret.push(walker.value);
              }
              return ret;
            };
            Yallist.prototype.sliceReverse = function(from, to) {
              to = to || this.length;
              if (to < 0) {
                to += this.length;
              }
              from = from || 0;
              if (from < 0) {
                from += this.length;
              }
              var ret = new Yallist();
              if (to < from || to < 0) {
                return ret;
              }
              if (from < 0) {
                from = 0;
              }
              if (to > this.length) {
                to = this.length;
              }
              for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
                walker = walker.prev;
              }
              for (; walker !== null && i > from; i--, walker = walker.prev) {
                ret.push(walker.value);
              }
              return ret;
            };
            Yallist.prototype.reverse = function() {
              var head = this.head;
              var tail = this.tail;
              for (var walker = head; walker !== null; walker = walker.prev) {
                var p = walker.prev;
                walker.prev = walker.next;
                walker.next = p;
              }
              this.head = tail;
              this.tail = head;
              return this;
            };
            function push(self2, item) {
              self2.tail = new Node2(item, self2.tail, null, self2);
              if (!self2.head) {
                self2.head = self2.tail;
              }
              self2.length++;
            }
            function unshift(self2, item) {
              self2.head = new Node2(item, null, self2.head, self2);
              if (!self2.tail) {
                self2.tail = self2.head;
              }
              self2.length++;
            }
            function Node2(value, prev, next, list) {
              if (!(this instanceof Node2)) {
                return new Node2(value, prev, next, list);
              }
              this.list = list;
              this.value = value;
              if (prev) {
                prev.next = this;
                this.prev = prev;
              } else {
                this.prev = null;
              }
              if (next) {
                next.prev = this;
                this.next = next;
              } else {
                this.next = null;
              }
            }
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      (() => {
        __webpack_require__.n = (module2) => {
          var getter = module2 && module2.__esModule ? (
            /******/
            () => module2["default"]
          ) : (
            /******/
            () => module2
          );
          __webpack_require__.d(getter, { a: getter });
          return getter;
        };
      })();
      (() => {
        __webpack_require__.d = (exports2, definition) => {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      })();
      (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      })();
      (() => {
        __webpack_require__.r = (exports2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      })();
      var __webpack_exports__ = {};
      (() => {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
          "connectToDevTools": () => (
            /* binding */
            connectToDevTools
          )
        });
        ;
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var EventEmitter = /* @__PURE__ */ function() {
          function EventEmitter2() {
            _classCallCheck(this, EventEmitter2);
            _defineProperty(this, "listenersMap", /* @__PURE__ */ new Map());
          }
          _createClass(EventEmitter2, [{
            key: "addListener",
            value: function addListener(event, listener) {
              var listeners = this.listenersMap.get(event);
              if (listeners === void 0) {
                this.listenersMap.set(event, [listener]);
              } else {
                var index = listeners.indexOf(listener);
                if (index < 0) {
                  listeners.push(listener);
                }
              }
            }
          }, {
            key: "emit",
            value: function emit(event) {
              var listeners = this.listenersMap.get(event);
              if (listeners !== void 0) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                if (listeners.length === 1) {
                  var listener = listeners[0];
                  listener.apply(null, args);
                } else {
                  var didThrow = false;
                  var caughtError = null;
                  var clonedListeners = Array.from(listeners);
                  for (var i = 0; i < clonedListeners.length; i++) {
                    var _listener = clonedListeners[i];
                    try {
                      _listener.apply(null, args);
                    } catch (error) {
                      if (caughtError === null) {
                        didThrow = true;
                        caughtError = error;
                      }
                    }
                  }
                  if (didThrow) {
                    throw caughtError;
                  }
                }
              }
            }
          }, {
            key: "removeAllListeners",
            value: function removeAllListeners() {
              this.listenersMap.clear();
            }
          }, {
            key: "removeListener",
            value: function removeListener(event, listener) {
              var listeners = this.listenersMap.get(event);
              if (listeners !== void 0) {
                var index = listeners.indexOf(listener);
                if (index >= 0) {
                  listeners.splice(index, 1);
                }
              }
            }
          }]);
          return EventEmitter2;
        }();
        var lodash_throttle = __webpack_require__(172);
        var lodash_throttle_default = /* @__PURE__ */ __webpack_require__.n(lodash_throttle);
        ;
        var CHROME_WEBSTORE_EXTENSION_ID = "fmkadmapgofadopljbjfkapdkoienihi";
        var INTERNAL_EXTENSION_ID = "dnjnjgbfilfphmojnmhliehogmojhclc";
        var LOCAL_EXTENSION_ID = "ikiahnapldjmdmpkmfhjdjilojjhgcbf";
        var __DEBUG__ = false;
        var __PERFORMANCE_PROFILE__ = false;
        var TREE_OPERATION_ADD = 1;
        var TREE_OPERATION_REMOVE = 2;
        var TREE_OPERATION_REORDER_CHILDREN = 3;
        var TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;
        var TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = 5;
        var TREE_OPERATION_REMOVE_ROOT = 6;
        var TREE_OPERATION_SET_SUBTREE_MODE = 7;
        var PROFILING_FLAG_BASIC_SUPPORT = 1;
        var PROFILING_FLAG_TIMELINE_SUPPORT = 2;
        var LOCAL_STORAGE_DEFAULT_TAB_KEY = "React::DevTools::defaultTab";
        var constants_LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY = "React::DevTools::componentFilters";
        var SESSION_STORAGE_LAST_SELECTION_KEY = "React::DevTools::lastSelection";
        var constants_LOCAL_STORAGE_OPEN_IN_EDITOR_URL = "React::DevTools::openInEditorUrl";
        var LOCAL_STORAGE_OPEN_IN_EDITOR_URL_PRESET = "React::DevTools::openInEditorUrlPreset";
        var LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = "React::DevTools::parseHookNames";
        var SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = "React::DevTools::recordChangeDescriptions";
        var SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = "React::DevTools::reloadAndProfile";
        var constants_LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = "React::DevTools::breakOnConsoleErrors";
        var LOCAL_STORAGE_BROWSER_THEME = "React::DevTools::theme";
        var constants_LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY = "React::DevTools::appendComponentStack";
        var constants_LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY = "React::DevTools::showInlineWarningsAndErrors";
        var LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = "React::DevTools::traceUpdatesEnabled";
        var constants_LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE = "React::DevTools::hideConsoleLogsInStrictMode";
        var LOCAL_STORAGE_SUPPORTS_PROFILING_KEY = "React::DevTools::supportsProfiling";
        var PROFILER_EXPORT_VERSION = 5;
        ;
        function storage_localStorageGetItem(key) {
          try {
            return localStorage.getItem(key);
          } catch (error) {
            return null;
          }
        }
        function localStorageRemoveItem(key) {
          try {
            localStorage.removeItem(key);
          } catch (error) {
          }
        }
        function storage_localStorageSetItem(key, value) {
          try {
            return localStorage.setItem(key, value);
          } catch (error) {
          }
        }
        function sessionStorageGetItem(key) {
          try {
            return sessionStorage.getItem(key);
          } catch (error) {
            return null;
          }
        }
        function sessionStorageRemoveItem(key) {
          try {
            sessionStorage.removeItem(key);
          } catch (error) {
          }
        }
        function sessionStorageSetItem(key, value) {
          try {
            return sessionStorage.setItem(key, value);
          } catch (error) {
          }
        }
        ;
        var simpleIsEqual = function simpleIsEqual2(a, b) {
          return a === b;
        };
        function esm(resultFn) {
          var isEqual = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : simpleIsEqual;
          var lastThis = void 0;
          var lastArgs = [];
          var lastResult = void 0;
          var calledOnce = false;
          var isNewArgEqualToLast = function isNewArgEqualToLast2(newArg, index) {
            return isEqual(newArg, lastArgs[index]);
          };
          var result = function result2() {
            for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
              newArgs[_key] = arguments[_key];
            }
            if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {
              return lastResult;
            }
            calledOnce = true;
            lastThis = this;
            lastArgs = newArgs;
            lastResult = resultFn.apply(this, newArgs);
            return lastResult;
          };
          return result;
        }
        ;
        function getOwnerWindow(node) {
          if (!node.ownerDocument) {
            return null;
          }
          return node.ownerDocument.defaultView;
        }
        function getOwnerIframe(node) {
          var nodeWindow = getOwnerWindow(node);
          if (nodeWindow) {
            return nodeWindow.frameElement;
          }
          return null;
        }
        function getBoundingClientRectWithBorderOffset(node) {
          var dimensions = getElementDimensions(node);
          return mergeRectOffsets([node.getBoundingClientRect(), {
            top: dimensions.borderTop,
            left: dimensions.borderLeft,
            bottom: dimensions.borderBottom,
            right: dimensions.borderRight,
            // This width and height won't get used by mergeRectOffsets (since this
            // is not the first rect in the array), but we set them so that this
            // object type checks as a ClientRect.
            width: 0,
            height: 0
          }]);
        }
        function mergeRectOffsets(rects) {
          return rects.reduce(function(previousRect, rect) {
            if (previousRect == null) {
              return rect;
            }
            return {
              top: previousRect.top + rect.top,
              left: previousRect.left + rect.left,
              width: previousRect.width,
              height: previousRect.height,
              bottom: previousRect.bottom + rect.bottom,
              right: previousRect.right + rect.right
            };
          });
        }
        function getNestedBoundingClientRect(node, boundaryWindow) {
          var ownerIframe = getOwnerIframe(node);
          if (ownerIframe && ownerIframe !== boundaryWindow) {
            var rects = [node.getBoundingClientRect()];
            var currentIframe = ownerIframe;
            var onlyOneMore = false;
            while (currentIframe) {
              var rect = getBoundingClientRectWithBorderOffset(currentIframe);
              rects.push(rect);
              currentIframe = getOwnerIframe(currentIframe);
              if (onlyOneMore) {
                break;
              }
              if (currentIframe && getOwnerWindow(currentIframe) === boundaryWindow) {
                onlyOneMore = true;
              }
            }
            return mergeRectOffsets(rects);
          } else {
            return node.getBoundingClientRect();
          }
        }
        function getElementDimensions(domElement) {
          var calculatedStyle = window.getComputedStyle(domElement);
          return {
            borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),
            borderRight: parseInt(calculatedStyle.borderRightWidth, 10),
            borderTop: parseInt(calculatedStyle.borderTopWidth, 10),
            borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),
            marginLeft: parseInt(calculatedStyle.marginLeft, 10),
            marginRight: parseInt(calculatedStyle.marginRight, 10),
            marginTop: parseInt(calculatedStyle.marginTop, 10),
            marginBottom: parseInt(calculatedStyle.marginBottom, 10),
            paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),
            paddingRight: parseInt(calculatedStyle.paddingRight, 10),
            paddingTop: parseInt(calculatedStyle.paddingTop, 10),
            paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)
          };
        }
        ;
        function Overlay_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function Overlay_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function Overlay_createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            Overlay_defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            Overlay_defineProperties(Constructor, staticProps);
          return Constructor;
        }
        var Overlay_assign = Object.assign;
        var OverlayRect = /* @__PURE__ */ function() {
          function OverlayRect2(doc, container) {
            Overlay_classCallCheck(this, OverlayRect2);
            this.node = doc.createElement("div");
            this.border = doc.createElement("div");
            this.padding = doc.createElement("div");
            this.content = doc.createElement("div");
            this.border.style.borderColor = overlayStyles.border;
            this.padding.style.borderColor = overlayStyles.padding;
            this.content.style.backgroundColor = overlayStyles.background;
            Overlay_assign(this.node.style, {
              borderColor: overlayStyles.margin,
              pointerEvents: "none",
              position: "fixed"
            });
            this.node.style.zIndex = "10000000";
            this.node.appendChild(this.border);
            this.border.appendChild(this.padding);
            this.padding.appendChild(this.content);
            container.appendChild(this.node);
          }
          Overlay_createClass(OverlayRect2, [{
            key: "remove",
            value: function remove() {
              if (this.node.parentNode) {
                this.node.parentNode.removeChild(this.node);
              }
            }
          }, {
            key: "update",
            value: function update(box, dims) {
              boxWrap(dims, "margin", this.node);
              boxWrap(dims, "border", this.border);
              boxWrap(dims, "padding", this.padding);
              Overlay_assign(this.content.style, {
                height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + "px",
                width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + "px"
              });
              Overlay_assign(this.node.style, {
                top: box.top - dims.marginTop + "px",
                left: box.left - dims.marginLeft + "px"
              });
            }
          }]);
          return OverlayRect2;
        }();
        var OverlayTip = /* @__PURE__ */ function() {
          function OverlayTip2(doc, container) {
            Overlay_classCallCheck(this, OverlayTip2);
            this.tip = doc.createElement("div");
            Overlay_assign(this.tip.style, {
              display: "flex",
              flexFlow: "row nowrap",
              backgroundColor: "#333740",
              borderRadius: "2px",
              fontFamily: '"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace',
              fontWeight: "bold",
              padding: "3px 5px",
              pointerEvents: "none",
              position: "fixed",
              fontSize: "12px",
              whiteSpace: "nowrap"
            });
            this.nameSpan = doc.createElement("span");
            this.tip.appendChild(this.nameSpan);
            Overlay_assign(this.nameSpan.style, {
              color: "#ee78e6",
              borderRight: "1px solid #aaaaaa",
              paddingRight: "0.5rem",
              marginRight: "0.5rem"
            });
            this.dimSpan = doc.createElement("span");
            this.tip.appendChild(this.dimSpan);
            Overlay_assign(this.dimSpan.style, {
              color: "#d7d7d7"
            });
            this.tip.style.zIndex = "10000000";
            container.appendChild(this.tip);
          }
          Overlay_createClass(OverlayTip2, [{
            key: "remove",
            value: function remove() {
              if (this.tip.parentNode) {
                this.tip.parentNode.removeChild(this.tip);
              }
            }
          }, {
            key: "updateText",
            value: function updateText(name, width, height) {
              this.nameSpan.textContent = name;
              this.dimSpan.textContent = Math.round(width) + "px \xD7 " + Math.round(height) + "px";
            }
          }, {
            key: "updatePosition",
            value: function updatePosition(dims, bounds) {
              var tipRect = this.tip.getBoundingClientRect();
              var tipPos = findTipPos(dims, bounds, {
                width: tipRect.width,
                height: tipRect.height
              });
              Overlay_assign(this.tip.style, tipPos.style);
            }
          }]);
          return OverlayTip2;
        }();
        var Overlay = /* @__PURE__ */ function() {
          function Overlay2(agent2) {
            Overlay_classCallCheck(this, Overlay2);
            var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
            this.window = currentWindow;
            var tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
            this.tipBoundsWindow = tipBoundsWindow;
            var doc = currentWindow.document;
            this.container = doc.createElement("div");
            this.container.style.zIndex = "10000000";
            this.tip = new OverlayTip(doc, this.container);
            this.rects = [];
            this.agent = agent2;
            doc.body.appendChild(this.container);
          }
          Overlay_createClass(Overlay2, [{
            key: "remove",
            value: function remove() {
              this.tip.remove();
              this.rects.forEach(function(rect) {
                rect.remove();
              });
              this.rects.length = 0;
              if (this.container.parentNode) {
                this.container.parentNode.removeChild(this.container);
              }
            }
          }, {
            key: "inspect",
            value: function inspect(nodes, name) {
              var _this = this;
              var elements = nodes.filter(function(node2) {
                return node2.nodeType === Node.ELEMENT_NODE;
              });
              while (this.rects.length > elements.length) {
                var rect = this.rects.pop();
                rect.remove();
              }
              if (elements.length === 0) {
                return;
              }
              while (this.rects.length < elements.length) {
                this.rects.push(new OverlayRect(this.window.document, this.container));
              }
              var outerBox = {
                top: Number.POSITIVE_INFINITY,
                right: Number.NEGATIVE_INFINITY,
                bottom: Number.NEGATIVE_INFINITY,
                left: Number.POSITIVE_INFINITY
              };
              elements.forEach(function(element, index) {
                var box = getNestedBoundingClientRect(element, _this.window);
                var dims = getElementDimensions(element);
                outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);
                outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);
                outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);
                outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);
                var rect2 = _this.rects[index];
                rect2.update(box, dims);
              });
              if (!name) {
                name = elements[0].nodeName.toLowerCase();
                var node = elements[0];
                var rendererInterface = this.agent.getBestMatchingRendererInterface(node);
                if (rendererInterface) {
                  var id = rendererInterface.getFiberIDForNative(node, true);
                  if (id) {
                    var ownerName = rendererInterface.getDisplayNameForFiberID(id, true);
                    if (ownerName) {
                      name += " (in " + ownerName + ")";
                    }
                  }
                }
              }
              this.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);
              var tipBounds = getNestedBoundingClientRect(this.tipBoundsWindow.document.documentElement, this.window);
              this.tip.updatePosition({
                top: outerBox.top,
                left: outerBox.left,
                height: outerBox.bottom - outerBox.top,
                width: outerBox.right - outerBox.left
              }, {
                top: tipBounds.top + this.tipBoundsWindow.scrollY,
                left: tipBounds.left + this.tipBoundsWindow.scrollX,
                height: this.tipBoundsWindow.innerHeight,
                width: this.tipBoundsWindow.innerWidth
              });
            }
          }]);
          return Overlay2;
        }();
        function findTipPos(dims, bounds, tipSize) {
          var tipHeight = Math.max(tipSize.height, 20);
          var tipWidth = Math.max(tipSize.width, 60);
          var margin = 5;
          var top;
          if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {
            if (dims.top + dims.height < bounds.top + 0) {
              top = bounds.top + margin;
            } else {
              top = dims.top + dims.height + margin;
            }
          } else if (dims.top - tipHeight <= bounds.top + bounds.height) {
            if (dims.top - tipHeight - margin < bounds.top + margin) {
              top = bounds.top + margin;
            } else {
              top = dims.top - tipHeight - margin;
            }
          } else {
            top = bounds.top + bounds.height - tipHeight - margin;
          }
          var left = dims.left + margin;
          if (dims.left < bounds.left) {
            left = bounds.left + margin;
          }
          if (dims.left + tipWidth > bounds.left + bounds.width) {
            left = bounds.left + bounds.width - tipWidth - margin;
          }
          top += "px";
          left += "px";
          return {
            style: {
              top,
              left
            }
          };
        }
        function boxWrap(dims, what, node) {
          Overlay_assign(node.style, {
            borderTopWidth: dims[what + "Top"] + "px",
            borderLeftWidth: dims[what + "Left"] + "px",
            borderRightWidth: dims[what + "Right"] + "px",
            borderBottomWidth: dims[what + "Bottom"] + "px",
            borderStyle: "solid"
          });
        }
        var overlayStyles = {
          background: "rgba(120, 170, 210, 0.7)",
          padding: "rgba(77, 200, 0, 0.3)",
          margin: "rgba(255, 155, 0, 0.3)",
          border: "rgba(255, 200, 50, 0.3)"
        };
        ;
        var SHOW_DURATION = 2e3;
        var timeoutID = null;
        var overlay = null;
        function hideOverlay(agent2) {
          if (window.document == null) {
            agent2.emit("hideNativeHighlight");
            return;
          }
          timeoutID = null;
          if (overlay !== null) {
            overlay.remove();
            overlay = null;
          }
        }
        function showOverlay(elements, componentName, agent2, hideAfterTimeout) {
          if (window.document == null) {
            if (elements != null && elements[0] != null) {
              agent2.emit("showNativeHighlight", elements[0]);
            }
            return;
          }
          if (timeoutID !== null) {
            clearTimeout(timeoutID);
          }
          if (elements == null) {
            return;
          }
          if (overlay === null) {
            overlay = new Overlay(agent2);
          }
          overlay.inspect(elements, componentName);
          if (hideAfterTimeout) {
            timeoutID = setTimeout(function() {
              return hideOverlay(agent2);
            }, SHOW_DURATION);
          }
        }
        ;
        var iframesListeningTo = /* @__PURE__ */ new Set();
        function setupHighlighter(bridge, agent2) {
          bridge.addListener("clearNativeElementHighlight", clearNativeElementHighlight);
          bridge.addListener("highlightNativeElement", highlightNativeElement);
          bridge.addListener("shutdown", stopInspectingNative);
          bridge.addListener("startInspectingNative", startInspectingNative);
          bridge.addListener("stopInspectingNative", stopInspectingNative);
          function startInspectingNative() {
            registerListenersOnWindow(window);
          }
          function registerListenersOnWindow(window2) {
            if (window2 && typeof window2.addEventListener === "function") {
              window2.addEventListener("click", onClick, true);
              window2.addEventListener("mousedown", onMouseEvent, true);
              window2.addEventListener("mouseover", onMouseEvent, true);
              window2.addEventListener("mouseup", onMouseEvent, true);
              window2.addEventListener("pointerdown", onPointerDown, true);
              window2.addEventListener("pointermove", onPointerMove, true);
              window2.addEventListener("pointerup", onPointerUp, true);
            } else {
              agent2.emit("startInspectingNative");
            }
          }
          function stopInspectingNative() {
            hideOverlay(agent2);
            removeListenersOnWindow(window);
            iframesListeningTo.forEach(function(frame) {
              try {
                removeListenersOnWindow(frame.contentWindow);
              } catch (error) {
              }
            });
            iframesListeningTo = /* @__PURE__ */ new Set();
          }
          function removeListenersOnWindow(window2) {
            if (window2 && typeof window2.removeEventListener === "function") {
              window2.removeEventListener("click", onClick, true);
              window2.removeEventListener("mousedown", onMouseEvent, true);
              window2.removeEventListener("mouseover", onMouseEvent, true);
              window2.removeEventListener("mouseup", onMouseEvent, true);
              window2.removeEventListener("pointerdown", onPointerDown, true);
              window2.removeEventListener("pointermove", onPointerMove, true);
              window2.removeEventListener("pointerup", onPointerUp, true);
            } else {
              agent2.emit("stopInspectingNative");
            }
          }
          function clearNativeElementHighlight() {
            hideOverlay(agent2);
          }
          function highlightNativeElement(_ref) {
            var displayName = _ref.displayName, hideAfterTimeout = _ref.hideAfterTimeout, id = _ref.id, openNativeElementsPanel = _ref.openNativeElementsPanel, rendererID = _ref.rendererID, scrollIntoView = _ref.scrollIntoView;
            var renderer = agent2.rendererInterfaces[rendererID];
            if (renderer == null) {
              console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              hideOverlay(agent2);
              return;
            }
            if (!renderer.hasFiberWithId(id)) {
              hideOverlay(agent2);
              return;
            }
            var nodes = renderer.findNativeNodesForFiberID(id);
            if (nodes != null && nodes[0] != null) {
              var node = nodes[0];
              if (scrollIntoView && typeof node.scrollIntoView === "function") {
                node.scrollIntoView({
                  block: "nearest",
                  inline: "nearest"
                });
              }
              showOverlay(nodes, displayName, agent2, hideAfterTimeout);
              if (openNativeElementsPanel) {
                window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;
                bridge.send("syncSelectionToNativeElementsPanel");
              }
            } else {
              hideOverlay(agent2);
            }
          }
          function onClick(event) {
            event.preventDefault();
            event.stopPropagation();
            stopInspectingNative();
            bridge.send("stopInspectingNative", true);
          }
          function onMouseEvent(event) {
            event.preventDefault();
            event.stopPropagation();
          }
          function onPointerDown(event) {
            event.preventDefault();
            event.stopPropagation();
            selectFiberForNode(getEventTarget(event));
          }
          var lastHoveredNode = null;
          function onPointerMove(event) {
            event.preventDefault();
            event.stopPropagation();
            var target = getEventTarget(event);
            if (lastHoveredNode === target)
              return;
            lastHoveredNode = target;
            if (target.tagName === "IFRAME") {
              var iframe = target;
              try {
                if (!iframesListeningTo.has(iframe)) {
                  var _window = iframe.contentWindow;
                  registerListenersOnWindow(_window);
                  iframesListeningTo.add(iframe);
                }
              } catch (error) {
              }
            }
            showOverlay([target], null, agent2, false);
            selectFiberForNode(target);
          }
          function onPointerUp(event) {
            event.preventDefault();
            event.stopPropagation();
          }
          var selectFiberForNode = lodash_throttle_default()(
            esm(function(node) {
              var id = agent2.getIDForNode(node);
              if (id !== null) {
                bridge.send("selectFiber", id);
              }
            }),
            200,
            // Don't change the selection in the very first 200ms
            // because those are usually unintentional as you lift the cursor.
            {
              leading: false
            }
          );
          function getEventTarget(event) {
            if (event.composed) {
              return event.composedPath()[0];
            }
            return event.target;
          }
        }
        ;
        var OUTLINE_COLOR = "#f0f0f0";
        var COLORS = ["#37afa9", "#63b19e", "#80b393", "#97b488", "#abb67d", "#beb771", "#cfb965", "#dfba57", "#efbb49", "#febc38"];
        var canvas = null;
        function draw(nodeToData2, agent2) {
          if (window.document == null) {
            var nodesToDraw = [];
            iterateNodes(nodeToData2, function(_, color, node) {
              nodesToDraw.push({
                node,
                color
              });
            });
            agent2.emit("drawTraceUpdates", nodesToDraw);
            return;
          }
          if (canvas === null) {
            initialize();
          }
          var canvasFlow = canvas;
          canvasFlow.width = window.innerWidth;
          canvasFlow.height = window.innerHeight;
          var context = canvasFlow.getContext("2d");
          context.clearRect(0, 0, canvasFlow.width, canvasFlow.height);
          iterateNodes(nodeToData2, function(rect, color) {
            if (rect !== null) {
              drawBorder(context, rect, color);
            }
          });
        }
        function iterateNodes(nodeToData2, execute) {
          nodeToData2.forEach(function(_ref, node) {
            var count = _ref.count, rect = _ref.rect;
            var colorIndex = Math.min(COLORS.length - 1, count - 1);
            var color = COLORS[colorIndex];
            execute(rect, color, node);
          });
        }
        function drawBorder(context, rect, color) {
          var height = rect.height, left = rect.left, top = rect.top, width = rect.width;
          context.lineWidth = 1;
          context.strokeStyle = OUTLINE_COLOR;
          context.strokeRect(left - 1, top - 1, width + 2, height + 2);
          context.lineWidth = 1;
          context.strokeStyle = OUTLINE_COLOR;
          context.strokeRect(left + 1, top + 1, width - 1, height - 1);
          context.strokeStyle = color;
          context.setLineDash([0]);
          context.lineWidth = 1;
          context.strokeRect(left, top, width - 1, height - 1);
          context.setLineDash([0]);
        }
        function destroy(agent2) {
          if (window.document == null) {
            agent2.emit("disableTraceUpdates");
            return;
          }
          if (canvas !== null) {
            if (canvas.parentNode != null) {
              canvas.parentNode.removeChild(canvas);
            }
            canvas = null;
          }
        }
        function initialize() {
          canvas = window.document.createElement("canvas");
          canvas.style.cssText = "\n    xx-background-color: red;\n    xx-opacity: 0.5;\n    bottom: 0;\n    left: 0;\n    pointer-events: none;\n    position: fixed;\n    right: 0;\n    top: 0;\n    z-index: 1000000000;\n  ";
          var root = window.document.documentElement;
          root.insertBefore(canvas, root.firstChild);
        }
        ;
        function _typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof(obj);
        }
        var DISPLAY_DURATION = 250;
        var MAX_DISPLAY_DURATION = 3e3;
        var REMEASUREMENT_AFTER_DURATION = 250;
        var getCurrentTime = (
          // $FlowFixMe[method-unbinding]
          (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === "object" && typeof performance.now === "function" ? function() {
            return performance.now();
          } : function() {
            return Date.now();
          }
        );
        var nodeToData = /* @__PURE__ */ new Map();
        var agent = null;
        var drawAnimationFrameID = null;
        var isEnabled = false;
        var redrawTimeoutID = null;
        function TraceUpdates_initialize(injectedAgent) {
          agent = injectedAgent;
          agent.addListener("traceUpdates", traceUpdates);
        }
        function toggleEnabled(value) {
          isEnabled = value;
          if (!isEnabled) {
            nodeToData.clear();
            if (drawAnimationFrameID !== null) {
              cancelAnimationFrame(drawAnimationFrameID);
              drawAnimationFrameID = null;
            }
            if (redrawTimeoutID !== null) {
              clearTimeout(redrawTimeoutID);
              redrawTimeoutID = null;
            }
            destroy(agent);
          }
        }
        function traceUpdates(nodes) {
          if (!isEnabled) {
            return;
          }
          nodes.forEach(function(node) {
            var data = nodeToData.get(node);
            var now = getCurrentTime();
            var lastMeasuredAt = data != null ? data.lastMeasuredAt : 0;
            var rect = data != null ? data.rect : null;
            if (rect === null || lastMeasuredAt + REMEASUREMENT_AFTER_DURATION < now) {
              lastMeasuredAt = now;
              rect = measureNode(node);
            }
            nodeToData.set(node, {
              count: data != null ? data.count + 1 : 1,
              expirationTime: data != null ? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,
              lastMeasuredAt,
              rect
            });
          });
          if (redrawTimeoutID !== null) {
            clearTimeout(redrawTimeoutID);
            redrawTimeoutID = null;
          }
          if (drawAnimationFrameID === null) {
            drawAnimationFrameID = requestAnimationFrame(prepareToDraw);
          }
        }
        function prepareToDraw() {
          drawAnimationFrameID = null;
          redrawTimeoutID = null;
          var now = getCurrentTime();
          var earliestExpiration = Number.MAX_VALUE;
          nodeToData.forEach(function(data, node) {
            if (data.expirationTime < now) {
              nodeToData.delete(node);
            } else {
              earliestExpiration = Math.min(earliestExpiration, data.expirationTime);
            }
          });
          draw(nodeToData, agent);
          if (earliestExpiration !== Number.MAX_VALUE) {
            redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);
          }
        }
        function measureNode(node) {
          if (!node || typeof node.getBoundingClientRect !== "function") {
            return null;
          }
          var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
          return getNestedBoundingClientRect(node, currentWindow);
        }
        ;
        function esm_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            esm_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            esm_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return esm_typeof(obj);
        }
        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function _iterableToArrayLimit(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
            return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null)
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        var compareVersions = function compareVersions2(v1, v2) {
          var n1 = validateAndParse(v1);
          var n2 = validateAndParse(v2);
          var p1 = n1.pop();
          var p2 = n2.pop();
          var r = compareSegments(n1, n2);
          if (r !== 0)
            return r;
          if (p1 && p2) {
            return compareSegments(p1.split("."), p2.split("."));
          } else if (p1 || p2) {
            return p1 ? -1 : 1;
          }
          return 0;
        };
        var validate = function validate2(version) {
          return typeof version === "string" && /^[v\d]/.test(version) && semver.test(version);
        };
        var compare = function compare2(v1, v2, operator) {
          assertValidOperator(operator);
          var res = compareVersions(v1, v2);
          return operatorResMap[operator].includes(res);
        };
        var satisfies = function satisfies2(version, range) {
          var m = range.match(/^([<>=~^]+)/);
          var op = m ? m[1] : "=";
          if (op !== "^" && op !== "~")
            return compare(version, range, op);
          var _validateAndParse = validateAndParse(version), _validateAndParse2 = _slicedToArray(_validateAndParse, 5), v1 = _validateAndParse2[0], v2 = _validateAndParse2[1], v3 = _validateAndParse2[2], vp = _validateAndParse2[4];
          var _validateAndParse3 = validateAndParse(range), _validateAndParse4 = _slicedToArray(_validateAndParse3, 5), r1 = _validateAndParse4[0], r2 = _validateAndParse4[1], r3 = _validateAndParse4[2], rp = _validateAndParse4[4];
          var v = [v1, v2, v3];
          var r = [r1, r2 !== null && r2 !== void 0 ? r2 : "x", r3 !== null && r3 !== void 0 ? r3 : "x"];
          if (rp) {
            if (!vp)
              return false;
            if (compareSegments(v, r) !== 0)
              return false;
            if (compareSegments(vp.split("."), rp.split(".")) === -1)
              return false;
          }
          var nonZero = r.findIndex(function(v4) {
            return v4 !== "0";
          }) + 1;
          var i = op === "~" ? 2 : nonZero > 1 ? nonZero : 1;
          if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0)
            return false;
          if (compareSegments(v.slice(i), r.slice(i)) === -1)
            return false;
          return true;
        };
        var semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
        var validateAndParse = function validateAndParse2(version) {
          if (typeof version !== "string") {
            throw new TypeError("Invalid argument expected string");
          }
          var match = version.match(semver);
          if (!match) {
            throw new Error("Invalid argument not valid semver ('".concat(version, "' received)"));
          }
          match.shift();
          return match;
        };
        var isWildcard = function isWildcard2(s) {
          return s === "*" || s === "x" || s === "X";
        };
        var tryParse = function tryParse2(v) {
          var n = parseInt(v, 10);
          return isNaN(n) ? v : n;
        };
        var forceType = function forceType2(a, b) {
          return esm_typeof(a) !== esm_typeof(b) ? [String(a), String(b)] : [a, b];
        };
        var compareStrings = function compareStrings2(a, b) {
          if (isWildcard(a) || isWildcard(b))
            return 0;
          var _forceType = forceType(tryParse(a), tryParse(b)), _forceType2 = _slicedToArray(_forceType, 2), ap = _forceType2[0], bp = _forceType2[1];
          if (ap > bp)
            return 1;
          if (ap < bp)
            return -1;
          return 0;
        };
        var compareSegments = function compareSegments2(a, b) {
          for (var i = 0; i < Math.max(a.length, b.length); i++) {
            var r = compareStrings(a[i] || "0", b[i] || "0");
            if (r !== 0)
              return r;
          }
          return 0;
        };
        var operatorResMap = {
          ">": [1],
          ">=": [0, 1],
          "=": [0],
          "<=": [-1, 0],
          "<": [-1]
        };
        var allowedOperators = Object.keys(operatorResMap);
        var assertValidOperator = function assertValidOperator2(op) {
          if (typeof op !== "string") {
            throw new TypeError("Invalid operator type, expected string but got ".concat(esm_typeof(op)));
          }
          if (allowedOperators.indexOf(op) === -1) {
            throw new Error("Invalid operator, expected one of ".concat(allowedOperators.join("|")));
          }
        };
        var lru_cache = __webpack_require__(730);
        var lru_cache_default = /* @__PURE__ */ __webpack_require__.n(lru_cache);
        var react_is = __webpack_require__(550);
        ;
        function ReactSymbols_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            ReactSymbols_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            ReactSymbols_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return ReactSymbols_typeof(obj);
        }
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_CACHE_TYPE = Symbol.for("react.cache");
        var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        var REACT_POSTPONE_TYPE = Symbol.for("react.postpone");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || ReactSymbols_typeof(maybeIterable) !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        ;
        var types_ElementTypeClass = 1;
        var ElementTypeContext = 2;
        var types_ElementTypeFunction = 5;
        var types_ElementTypeForwardRef = 6;
        var ElementTypeHostComponent = 7;
        var types_ElementTypeMemo = 8;
        var ElementTypeOtherOrUnknown = 9;
        var ElementTypeProfiler = 10;
        var ElementTypeRoot = 11;
        var ElementTypeSuspense = 12;
        var ElementTypeSuspenseList = 13;
        var ElementTypeTracingMarker = 14;
        var ComponentFilterElementType = 1;
        var ComponentFilterDisplayName = 2;
        var ComponentFilterLocation = 3;
        var ComponentFilterHOC = 4;
        var StrictMode = 1;
        ;
        var isArray = Array.isArray;
        const src_isArray = isArray;
        ;
        var process2 = __webpack_require__(169);
        function utils_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            utils_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            utils_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return utils_typeof(obj);
        }
        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || utils_unsupportedIterableToArray(arr) || _nonIterableSpread();
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function utils_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return utils_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return utils_arrayLikeToArray(o, minLen);
        }
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
            return Array.from(iter);
        }
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return utils_arrayLikeToArray(arr);
        }
        function utils_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        var utils_hasOwnProperty = Object.prototype.hasOwnProperty;
        var cachedDisplayNames = /* @__PURE__ */ new WeakMap();
        var encodedStringCache = new (lru_cache_default())({
          max: 1e3
        });
        function alphaSortKeys(a, b) {
          if (a.toString() > b.toString()) {
            return 1;
          } else if (b.toString() > a.toString()) {
            return -1;
          } else {
            return 0;
          }
        }
        function getAllEnumerableKeys(obj) {
          var keys = /* @__PURE__ */ new Set();
          var current = obj;
          var _loop = function _loop2() {
            var currentKeys = [].concat(_toConsumableArray(Object.keys(current)), _toConsumableArray(Object.getOwnPropertySymbols(current)));
            var descriptors = Object.getOwnPropertyDescriptors(current);
            currentKeys.forEach(function(key) {
              if (descriptors[key].enumerable) {
                keys.add(key);
              }
            });
            current = Object.getPrototypeOf(current);
          };
          while (current != null) {
            _loop();
          }
          return keys;
        }
        function getWrappedDisplayName(outerType, innerType, wrapperName, fallbackName) {
          var displayName = outerType.displayName;
          return displayName || "".concat(wrapperName, "(").concat(getDisplayName(innerType, fallbackName), ")");
        }
        function getDisplayName(type) {
          var fallbackName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Anonymous";
          var nameFromCache = cachedDisplayNames.get(type);
          if (nameFromCache != null) {
            return nameFromCache;
          }
          var displayName = fallbackName;
          if (typeof type.displayName === "string") {
            displayName = type.displayName;
          } else if (typeof type.name === "string" && type.name !== "") {
            displayName = type.name;
          }
          cachedDisplayNames.set(type, displayName);
          return displayName;
        }
        var uidCounter = 0;
        function getUID() {
          return ++uidCounter;
        }
        function utfDecodeString(array) {
          var string = "";
          for (var i = 0; i < array.length; i++) {
            var char = array[i];
            string += String.fromCodePoint(char);
          }
          return string;
        }
        function surrogatePairToCodePoint(charCode1, charCode2) {
          return ((charCode1 & 1023) << 10) + (charCode2 & 1023) + 65536;
        }
        function utfEncodeString(string) {
          var cached = encodedStringCache.get(string);
          if (cached !== void 0) {
            return cached;
          }
          var encoded = [];
          var i = 0;
          var charCode;
          while (i < string.length) {
            charCode = string.charCodeAt(i);
            if ((charCode & 63488) === 55296) {
              encoded.push(surrogatePairToCodePoint(charCode, string.charCodeAt(++i)));
            } else {
              encoded.push(charCode);
            }
            ++i;
          }
          encodedStringCache.set(string, encoded);
          return encoded;
        }
        function printOperationsArray(operations) {
          var rendererID = operations[0];
          var rootID = operations[1];
          var logs = ["operations for renderer:".concat(rendererID, " and root:").concat(rootID)];
          var i = 2;
          var stringTable = [
            null
            // ID = 0 corresponds to the null string.
          ];
          var stringTableSize = operations[i++];
          var stringTableEnd = i + stringTableSize;
          while (i < stringTableEnd) {
            var nextLength = operations[i++];
            var nextString = utfDecodeString(operations.slice(i, i + nextLength));
            stringTable.push(nextString);
            i += nextLength;
          }
          while (i < operations.length) {
            var operation = operations[i];
            switch (operation) {
              case TREE_OPERATION_ADD: {
                var _id = operations[i + 1];
                var type = operations[i + 2];
                i += 3;
                if (type === ElementTypeRoot) {
                  logs.push("Add new root node ".concat(_id));
                  i++;
                  i++;
                  i++;
                  i++;
                } else {
                  var parentID = operations[i];
                  i++;
                  i++;
                  var displayNameStringID = operations[i];
                  var displayName = stringTable[displayNameStringID];
                  i++;
                  i++;
                  logs.push("Add node ".concat(_id, " (").concat(displayName || "null", ") as child of ").concat(parentID));
                }
                break;
              }
              case TREE_OPERATION_REMOVE: {
                var removeLength = operations[i + 1];
                i += 2;
                for (var removeIndex = 0; removeIndex < removeLength; removeIndex++) {
                  var _id2 = operations[i];
                  i += 1;
                  logs.push("Remove node ".concat(_id2));
                }
                break;
              }
              case TREE_OPERATION_REMOVE_ROOT: {
                i += 1;
                logs.push("Remove root ".concat(rootID));
                break;
              }
              case TREE_OPERATION_SET_SUBTREE_MODE: {
                var _id3 = operations[i + 1];
                var mode = operations[i + 1];
                i += 3;
                logs.push("Mode ".concat(mode, " set for subtree with root ").concat(_id3));
                break;
              }
              case TREE_OPERATION_REORDER_CHILDREN: {
                var _id4 = operations[i + 1];
                var numChildren = operations[i + 2];
                i += 3;
                var children = operations.slice(i, i + numChildren);
                i += numChildren;
                logs.push("Re-order node ".concat(_id4, " children ").concat(children.join(",")));
                break;
              }
              case TREE_OPERATION_UPDATE_TREE_BASE_DURATION:
                i += 3;
                break;
              case TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS:
                var id = operations[i + 1];
                var numErrors = operations[i + 2];
                var numWarnings = operations[i + 3];
                i += 4;
                logs.push("Node ".concat(id, " has ").concat(numErrors, " errors and ").concat(numWarnings, " warnings"));
                break;
              default:
                throw Error('Unsupported Bridge operation "'.concat(operation, '"'));
            }
          }
          console.log(logs.join("\n  "));
        }
        function getDefaultComponentFilters() {
          return [{
            type: ComponentFilterElementType,
            value: ElementTypeHostComponent,
            isEnabled: true
          }];
        }
        function getSavedComponentFilters() {
          try {
            var raw = localStorageGetItem(LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY);
            if (raw != null) {
              return JSON.parse(raw);
            }
          } catch (error) {
          }
          return getDefaultComponentFilters();
        }
        function setSavedComponentFilters(componentFilters) {
          localStorageSetItem(LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY, JSON.stringify(componentFilters));
        }
        function parseBool(s) {
          if (s === "true") {
            return true;
          }
          if (s === "false") {
            return false;
          }
        }
        function castBool(v) {
          if (v === true || v === false) {
            return v;
          }
        }
        function castBrowserTheme(v) {
          if (v === "light" || v === "dark" || v === "auto") {
            return v;
          }
        }
        function getAppendComponentStack() {
          var _parseBool;
          var raw = localStorageGetItem(LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY);
          return (_parseBool = parseBool(raw)) !== null && _parseBool !== void 0 ? _parseBool : true;
        }
        function getBreakOnConsoleErrors() {
          var _parseBool2;
          var raw = localStorageGetItem(LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS);
          return (_parseBool2 = parseBool(raw)) !== null && _parseBool2 !== void 0 ? _parseBool2 : false;
        }
        function getHideConsoleLogsInStrictMode() {
          var _parseBool3;
          var raw = localStorageGetItem(LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE);
          return (_parseBool3 = parseBool(raw)) !== null && _parseBool3 !== void 0 ? _parseBool3 : false;
        }
        function getShowInlineWarningsAndErrors() {
          var _parseBool4;
          var raw = localStorageGetItem(LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY);
          return (_parseBool4 = parseBool(raw)) !== null && _parseBool4 !== void 0 ? _parseBool4 : true;
        }
        function getDefaultOpenInEditorURL() {
          return typeof process2.env.EDITOR_URL === "string" ? process2.env.EDITOR_URL : "";
        }
        function getOpenInEditorURL() {
          try {
            var raw = localStorageGetItem(LOCAL_STORAGE_OPEN_IN_EDITOR_URL);
            if (raw != null) {
              return JSON.parse(raw);
            }
          } catch (error) {
          }
          return getDefaultOpenInEditorURL();
        }
        function separateDisplayNameAndHOCs(displayName, type) {
          if (displayName === null) {
            return [null, null];
          }
          var hocDisplayNames = null;
          switch (type) {
            case ElementTypeClass:
            case ElementTypeForwardRef:
            case ElementTypeFunction:
            case ElementTypeMemo:
              if (displayName.indexOf("(") >= 0) {
                var matches = displayName.match(/[^()]+/g);
                if (matches != null) {
                  displayName = matches.pop();
                  hocDisplayNames = matches;
                }
              }
              break;
            default:
              break;
          }
          return [displayName, hocDisplayNames];
        }
        function shallowDiffers(prev, next) {
          for (var attribute in prev) {
            if (!(attribute in next)) {
              return true;
            }
          }
          for (var _attribute in next) {
            if (prev[_attribute] !== next[_attribute]) {
              return true;
            }
          }
          return false;
        }
        function utils_getInObject(object, path) {
          return path.reduce(function(reduced, attr) {
            if (reduced) {
              if (utils_hasOwnProperty.call(reduced, attr)) {
                return reduced[attr];
              }
              if (typeof reduced[Symbol.iterator] === "function") {
                return Array.from(reduced)[attr];
              }
            }
            return null;
          }, object);
        }
        function deletePathInObject(object, path) {
          var length = path.length;
          var last = path[length - 1];
          if (object != null) {
            var parent = utils_getInObject(object, path.slice(0, length - 1));
            if (parent) {
              if (src_isArray(parent)) {
                parent.splice(last, 1);
              } else {
                delete parent[last];
              }
            }
          }
        }
        function renamePathInObject(object, oldPath, newPath) {
          var length = oldPath.length;
          if (object != null) {
            var parent = utils_getInObject(object, oldPath.slice(0, length - 1));
            if (parent) {
              var lastOld = oldPath[length - 1];
              var lastNew = newPath[length - 1];
              parent[lastNew] = parent[lastOld];
              if (src_isArray(parent)) {
                parent.splice(lastOld, 1);
              } else {
                delete parent[lastOld];
              }
            }
          }
        }
        function utils_setInObject(object, path, value) {
          var length = path.length;
          var last = path[length - 1];
          if (object != null) {
            var parent = utils_getInObject(object, path.slice(0, length - 1));
            if (parent) {
              parent[last] = value;
            }
          }
        }
        function getDataType(data) {
          if (data === null) {
            return "null";
          } else if (data === void 0) {
            return "undefined";
          }
          if ((0, react_is.isElement)(data)) {
            return "react_element";
          }
          if (typeof HTMLElement !== "undefined" && data instanceof HTMLElement) {
            return "html_element";
          }
          var type = utils_typeof(data);
          switch (type) {
            case "bigint":
              return "bigint";
            case "boolean":
              return "boolean";
            case "function":
              return "function";
            case "number":
              if (Number.isNaN(data)) {
                return "nan";
              } else if (!Number.isFinite(data)) {
                return "infinity";
              } else {
                return "number";
              }
            case "object":
              if (src_isArray(data)) {
                return "array";
              } else if (ArrayBuffer.isView(data)) {
                return utils_hasOwnProperty.call(data.constructor, "BYTES_PER_ELEMENT") ? "typed_array" : "data_view";
              } else if (data.constructor && data.constructor.name === "ArrayBuffer") {
                return "array_buffer";
              } else if (typeof data[Symbol.iterator] === "function") {
                var iterator = data[Symbol.iterator]();
                if (!iterator) {
                } else {
                  return iterator === data ? "opaque_iterator" : "iterator";
                }
              } else if (data.constructor && data.constructor.name === "RegExp") {
                return "regexp";
              } else {
                var toStringValue = Object.prototype.toString.call(data);
                if (toStringValue === "[object Date]") {
                  return "date";
                } else if (toStringValue === "[object HTMLAllCollection]") {
                  return "html_all_collection";
                }
              }
              if (!isPlainObject(data)) {
                return "class_instance";
              }
              return "object";
            case "string":
              return "string";
            case "symbol":
              return "symbol";
            case "undefined":
              if (
                // $FlowFixMe[method-unbinding]
                Object.prototype.toString.call(data) === "[object HTMLAllCollection]"
              ) {
                return "html_all_collection";
              }
              return "undefined";
            default:
              return "unknown";
          }
        }
        function getDisplayNameForReactElement(element) {
          var elementType = (0, react_is.typeOf)(element);
          switch (elementType) {
            case react_is.ContextConsumer:
              return "ContextConsumer";
            case react_is.ContextProvider:
              return "ContextProvider";
            case react_is.ForwardRef:
              return "ForwardRef";
            case react_is.Fragment:
              return "Fragment";
            case react_is.Lazy:
              return "Lazy";
            case react_is.Memo:
              return "Memo";
            case react_is.Portal:
              return "Portal";
            case react_is.Profiler:
              return "Profiler";
            case react_is.StrictMode:
              return "StrictMode";
            case react_is.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_TRACING_MARKER_TYPE:
              return "TracingMarker";
            default:
              var type = element.type;
              if (typeof type === "string") {
                return type;
              } else if (typeof type === "function") {
                return getDisplayName(type, "Anonymous");
              } else if (type != null) {
                return "NotImplementedInDevtools";
              } else {
                return "Element";
              }
          }
        }
        var MAX_PREVIEW_STRING_LENGTH = 50;
        function truncateForDisplay(string) {
          var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : MAX_PREVIEW_STRING_LENGTH;
          if (string.length > length) {
            return string.slice(0, length) + "\u2026";
          } else {
            return string;
          }
        }
        function formatDataForPreview(data, showFormattedValue) {
          if (data != null && utils_hasOwnProperty.call(data, meta.type)) {
            return showFormattedValue ? data[meta.preview_long] : data[meta.preview_short];
          }
          var type = getDataType(data);
          switch (type) {
            case "html_element":
              return "<".concat(truncateForDisplay(data.tagName.toLowerCase()), " />");
            case "function":
              return truncateForDisplay("\u0192 ".concat(typeof data.name === "function" ? "" : data.name, "() {}"));
            case "string":
              return '"'.concat(data, '"');
            case "bigint":
              return truncateForDisplay(data.toString() + "n");
            case "regexp":
              return truncateForDisplay(data.toString());
            case "symbol":
              return truncateForDisplay(data.toString());
            case "react_element":
              return "<".concat(truncateForDisplay(getDisplayNameForReactElement(data) || "Unknown"), " />");
            case "array_buffer":
              return "ArrayBuffer(".concat(data.byteLength, ")");
            case "data_view":
              return "DataView(".concat(data.buffer.byteLength, ")");
            case "array":
              if (showFormattedValue) {
                var formatted = "";
                for (var i = 0; i < data.length; i++) {
                  if (i > 0) {
                    formatted += ", ";
                  }
                  formatted += formatDataForPreview(data[i], false);
                  if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
                    break;
                  }
                }
                return "[".concat(truncateForDisplay(formatted), "]");
              } else {
                var length = utils_hasOwnProperty.call(data, meta.size) ? data[meta.size] : data.length;
                return "Array(".concat(length, ")");
              }
            case "typed_array":
              var shortName = "".concat(data.constructor.name, "(").concat(data.length, ")");
              if (showFormattedValue) {
                var _formatted = "";
                for (var _i = 0; _i < data.length; _i++) {
                  if (_i > 0) {
                    _formatted += ", ";
                  }
                  _formatted += data[_i];
                  if (_formatted.length > MAX_PREVIEW_STRING_LENGTH) {
                    break;
                  }
                }
                return "".concat(shortName, " [").concat(truncateForDisplay(_formatted), "]");
              } else {
                return shortName;
              }
            case "iterator":
              var name = data.constructor.name;
              if (showFormattedValue) {
                var array = Array.from(data);
                var _formatted2 = "";
                for (var _i2 = 0; _i2 < array.length; _i2++) {
                  var entryOrEntries = array[_i2];
                  if (_i2 > 0) {
                    _formatted2 += ", ";
                  }
                  if (src_isArray(entryOrEntries)) {
                    var key = formatDataForPreview(entryOrEntries[0], true);
                    var value = formatDataForPreview(entryOrEntries[1], false);
                    _formatted2 += "".concat(key, " => ").concat(value);
                  } else {
                    _formatted2 += formatDataForPreview(entryOrEntries, false);
                  }
                  if (_formatted2.length > MAX_PREVIEW_STRING_LENGTH) {
                    break;
                  }
                }
                return "".concat(name, "(").concat(data.size, ") {").concat(truncateForDisplay(_formatted2), "}");
              } else {
                return "".concat(name, "(").concat(data.size, ")");
              }
            case "opaque_iterator": {
              return data[Symbol.toStringTag];
            }
            case "date":
              return data.toString();
            case "class_instance":
              return data.constructor.name;
            case "object":
              if (showFormattedValue) {
                var keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);
                var _formatted3 = "";
                for (var _i3 = 0; _i3 < keys.length; _i3++) {
                  var _key = keys[_i3];
                  if (_i3 > 0) {
                    _formatted3 += ", ";
                  }
                  _formatted3 += "".concat(_key.toString(), ": ").concat(formatDataForPreview(data[_key], false));
                  if (_formatted3.length > MAX_PREVIEW_STRING_LENGTH) {
                    break;
                  }
                }
                return "{".concat(truncateForDisplay(_formatted3), "}");
              } else {
                return "{\u2026}";
              }
            case "boolean":
            case "number":
            case "infinity":
            case "nan":
            case "null":
            case "undefined":
              return data;
            default:
              try {
                return truncateForDisplay(String(data));
              } catch (error) {
                return "unserializable";
              }
          }
        }
        var isPlainObject = function isPlainObject2(object) {
          var objectPrototype = Object.getPrototypeOf(object);
          if (!objectPrototype)
            return true;
          var objectParentPrototype = Object.getPrototypeOf(objectPrototype);
          return !objectParentPrototype;
        };
        ;
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys(Object(source), true).forEach(function(key) {
                hydration_defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function hydration_defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var meta = {
          inspectable: Symbol("inspectable"),
          inspected: Symbol("inspected"),
          name: Symbol("name"),
          preview_long: Symbol("preview_long"),
          preview_short: Symbol("preview_short"),
          readonly: Symbol("readonly"),
          size: Symbol("size"),
          type: Symbol("type"),
          unserializable: Symbol("unserializable")
        };
        var LEVEL_THRESHOLD = 2;
        function createDehydrated(type, inspectable, data, cleaned, path) {
          cleaned.push(path);
          var dehydrated = {
            inspectable,
            type,
            preview_long: formatDataForPreview(data, true),
            preview_short: formatDataForPreview(data, false),
            name: !data.constructor || data.constructor.name === "Object" ? "" : data.constructor.name
          };
          if (type === "array" || type === "typed_array") {
            dehydrated.size = data.length;
          } else if (type === "object") {
            dehydrated.size = Object.keys(data).length;
          }
          if (type === "iterator" || type === "typed_array") {
            dehydrated.readonly = true;
          }
          return dehydrated;
        }
        function dehydrate(data, cleaned, unserializable, path, isPathAllowed) {
          var level = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
          var type = getDataType(data);
          var isPathAllowedCheck;
          switch (type) {
            case "html_element":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.tagName,
                type
              };
            case "function":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: typeof data.name === "function" || !data.name ? "function" : data.name,
                type
              };
            case "string":
              isPathAllowedCheck = isPathAllowed(path);
              if (isPathAllowedCheck) {
                return data;
              } else {
                return data.length <= 500 ? data : data.slice(0, 500) + "...";
              }
            case "bigint":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.toString(),
                type
              };
            case "symbol":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.toString(),
                type
              };
            case "react_element":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: getDisplayNameForReactElement(data) || "Unknown",
                type
              };
            case "array_buffer":
            case "data_view":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: type === "data_view" ? "DataView" : "ArrayBuffer",
                size: data.byteLength,
                type
              };
            case "array":
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                return createDehydrated(type, true, data, cleaned, path);
              }
              return data.map(function(item, i) {
                return dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              });
            case "html_all_collection":
            case "typed_array":
            case "iterator":
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                return createDehydrated(type, true, data, cleaned, path);
              } else {
                var unserializableValue = {
                  unserializable: true,
                  type,
                  readonly: true,
                  size: type === "typed_array" ? data.length : void 0,
                  preview_short: formatDataForPreview(data, false),
                  preview_long: formatDataForPreview(data, true),
                  name: !data.constructor || data.constructor.name === "Object" ? "" : data.constructor.name
                };
                Array.from(data).forEach(function(item, i) {
                  return unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
                });
                unserializable.push(path);
                return unserializableValue;
              }
            case "opaque_iterator":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data[Symbol.toStringTag],
                type
              };
            case "date":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.toString(),
                type
              };
            case "regexp":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.toString(),
                type
              };
            case "object":
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                return createDehydrated(type, true, data, cleaned, path);
              } else {
                var object = {};
                getAllEnumerableKeys(data).forEach(function(key) {
                  var name = key.toString();
                  object[name] = dehydrate(data[key], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
                });
                return object;
              }
            case "class_instance":
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                return createDehydrated(type, true, data, cleaned, path);
              }
              var value = {
                unserializable: true,
                type,
                readonly: true,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.constructor.name
              };
              getAllEnumerableKeys(data).forEach(function(key) {
                var keyAsString = key.toString();
                value[keyAsString] = dehydrate(data[key], cleaned, unserializable, path.concat([keyAsString]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              });
              unserializable.push(path);
              return value;
            case "infinity":
            case "nan":
            case "undefined":
              cleaned.push(path);
              return {
                type
              };
            default:
              return data;
          }
        }
        function fillInPath(object, data, path, value) {
          var target = getInObject(object, path);
          if (target != null) {
            if (!target[meta.unserializable]) {
              delete target[meta.inspectable];
              delete target[meta.inspected];
              delete target[meta.name];
              delete target[meta.preview_long];
              delete target[meta.preview_short];
              delete target[meta.readonly];
              delete target[meta.size];
              delete target[meta.type];
            }
          }
          if (value !== null && data.unserializable.length > 0) {
            var unserializablePath = data.unserializable[0];
            var isMatch = unserializablePath.length === path.length;
            for (var i = 0; i < path.length; i++) {
              if (path[i] !== unserializablePath[i]) {
                isMatch = false;
                break;
              }
            }
            if (isMatch) {
              upgradeUnserializable(value, value);
            }
          }
          setInObject(object, path, value);
        }
        function hydrate(object, cleaned, unserializable) {
          cleaned.forEach(function(path) {
            var length = path.length;
            var last = path[length - 1];
            var parent = getInObject(object, path.slice(0, length - 1));
            if (!parent || !parent.hasOwnProperty(last)) {
              return;
            }
            var value = parent[last];
            if (!value) {
              return;
            } else if (value.type === "infinity") {
              parent[last] = Infinity;
            } else if (value.type === "nan") {
              parent[last] = NaN;
            } else if (value.type === "undefined") {
              parent[last] = void 0;
            } else {
              var replaced = {};
              replaced[meta.inspectable] = !!value.inspectable;
              replaced[meta.inspected] = false;
              replaced[meta.name] = value.name;
              replaced[meta.preview_long] = value.preview_long;
              replaced[meta.preview_short] = value.preview_short;
              replaced[meta.size] = value.size;
              replaced[meta.readonly] = !!value.readonly;
              replaced[meta.type] = value.type;
              parent[last] = replaced;
            }
          });
          unserializable.forEach(function(path) {
            var length = path.length;
            var last = path[length - 1];
            var parent = getInObject(object, path.slice(0, length - 1));
            if (!parent || !parent.hasOwnProperty(last)) {
              return;
            }
            var node = parent[last];
            var replacement = _objectSpread({}, node);
            upgradeUnserializable(replacement, node);
            parent[last] = replacement;
          });
          return object;
        }
        function upgradeUnserializable(destination, source) {
          var _Object$definePropert;
          Object.defineProperties(destination, (_Object$definePropert = {}, hydration_defineProperty(_Object$definePropert, meta.inspected, {
            configurable: true,
            enumerable: false,
            value: !!source.inspected
          }), hydration_defineProperty(_Object$definePropert, meta.name, {
            configurable: true,
            enumerable: false,
            value: source.name
          }), hydration_defineProperty(_Object$definePropert, meta.preview_long, {
            configurable: true,
            enumerable: false,
            value: source.preview_long
          }), hydration_defineProperty(_Object$definePropert, meta.preview_short, {
            configurable: true,
            enumerable: false,
            value: source.preview_short
          }), hydration_defineProperty(_Object$definePropert, meta.size, {
            configurable: true,
            enumerable: false,
            value: source.size
          }), hydration_defineProperty(_Object$definePropert, meta.readonly, {
            configurable: true,
            enumerable: false,
            value: !!source.readonly
          }), hydration_defineProperty(_Object$definePropert, meta.type, {
            configurable: true,
            enumerable: false,
            value: source.type
          }), hydration_defineProperty(_Object$definePropert, meta.unserializable, {
            configurable: true,
            enumerable: false,
            value: !!source.unserializable
          }), _Object$definePropert));
          delete destination.inspected;
          delete destination.name;
          delete destination.preview_long;
          delete destination.preview_short;
          delete destination.size;
          delete destination.readonly;
          delete destination.type;
          delete destination.unserializable;
        }
        ;
        var isArrayImpl = Array.isArray;
        function isArray_isArray(a) {
          return isArrayImpl(a);
        }
        const shared_isArray = isArray_isArray;
        ;
        function utils_toConsumableArray(arr) {
          return utils_arrayWithoutHoles(arr) || utils_iterableToArray(arr) || backend_utils_unsupportedIterableToArray(arr) || utils_nonIterableSpread();
        }
        function utils_nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function backend_utils_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return backend_utils_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return backend_utils_arrayLikeToArray(o, minLen);
        }
        function utils_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
            return Array.from(iter);
        }
        function utils_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return backend_utils_arrayLikeToArray(arr);
        }
        function backend_utils_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function backend_utils_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            backend_utils_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            backend_utils_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return backend_utils_typeof(obj);
        }
        function utils_ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function utils_objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              utils_ownKeys(Object(source), true).forEach(function(key) {
                utils_defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              utils_ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function utils_defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER = "999.9.9";
        function hasAssignedBackend(version) {
          if (version == null || version === "") {
            return false;
          }
          return gte(version, FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER);
        }
        function cleanForBridge(data, isPathAllowed) {
          var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          if (data !== null) {
            var cleanedPaths = [];
            var unserializablePaths = [];
            var cleanedData = dehydrate(data, cleanedPaths, unserializablePaths, path, isPathAllowed);
            return {
              data: cleanedData,
              cleaned: cleanedPaths,
              unserializable: unserializablePaths
            };
          } else {
            return null;
          }
        }
        function copyWithDelete(obj, path) {
          var index = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          var key = path[index];
          var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);
          if (index + 1 === path.length) {
            if (shared_isArray(updated)) {
              updated.splice(key, 1);
            } else {
              delete updated[key];
            }
          } else {
            updated[key] = copyWithDelete(obj[key], path, index + 1);
          }
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          var oldKey = oldPath[index];
          var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);
          if (index + 1 === oldPath.length) {
            var newKey = newPath[index];
            updated[newKey] = updated[oldKey];
            if (shared_isArray(updated)) {
              updated.splice(oldKey, 1);
            } else {
              delete updated[oldKey];
            }
          } else {
            updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);
          }
          return updated;
        }
        function copyWithSet(obj, path, value) {
          var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          if (index >= path.length) {
            return value;
          }
          var key = path[index];
          var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);
          updated[key] = copyWithSet(obj[key], path, value, index + 1);
          return updated;
        }
        function getEffectDurations(root) {
          var effectDuration = null;
          var passiveEffectDuration = null;
          var hostRoot = root.current;
          if (hostRoot != null) {
            var stateNode = hostRoot.stateNode;
            if (stateNode != null) {
              effectDuration = stateNode.effectDuration != null ? stateNode.effectDuration : null;
              passiveEffectDuration = stateNode.passiveEffectDuration != null ? stateNode.passiveEffectDuration : null;
            }
          }
          return {
            effectDuration,
            passiveEffectDuration
          };
        }
        function serializeToString(data) {
          if (data === void 0) {
            return "undefined";
          }
          var cache = /* @__PURE__ */ new Set();
          return JSON.stringify(data, function(key, value) {
            if (backend_utils_typeof(value) === "object" && value !== null) {
              if (cache.has(value)) {
                return;
              }
              cache.add(value);
            }
            if (typeof value === "bigint") {
              return value.toString() + "n";
            }
            return value;
          }, 2);
        }
        function formatWithStyles(inputArgs, style) {
          if (inputArgs === void 0 || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c
          typeof inputArgs[0] === "string" && inputArgs[0].match(/([^%]|^)(%c)/g) || style === void 0) {
            return inputArgs;
          }
          var REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;
          if (typeof inputArgs[0] === "string" && inputArgs[0].match(REGEXP)) {
            return ["%c".concat(inputArgs[0]), style].concat(utils_toConsumableArray(inputArgs.slice(1)));
          } else {
            var firstArg = inputArgs.reduce(function(formatStr, elem, i) {
              if (i > 0) {
                formatStr += " ";
              }
              switch (backend_utils_typeof(elem)) {
                case "string":
                case "boolean":
                case "symbol":
                  return formatStr += "%s";
                case "number":
                  var formatting = Number.isInteger(elem) ? "%i" : "%f";
                  return formatStr += formatting;
                default:
                  return formatStr += "%o";
              }
            }, "%c");
            return [firstArg, style].concat(utils_toConsumableArray(inputArgs));
          }
        }
        function format(maybeMessage) {
          for (var _len = arguments.length, inputArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            inputArgs[_key - 1] = arguments[_key];
          }
          var args = inputArgs.slice();
          var formatted = String(maybeMessage);
          if (typeof maybeMessage === "string") {
            if (args.length) {
              var REGEXP = /(%?)(%([jds]))/g;
              formatted = formatted.replace(REGEXP, function(match, escaped, ptn, flag) {
                var arg = args.shift();
                switch (flag) {
                  case "s":
                    arg += "";
                    break;
                  case "d":
                  case "i":
                    arg = parseInt(arg, 10).toString();
                    break;
                  case "f":
                    arg = parseFloat(arg).toString();
                    break;
                }
                if (!escaped) {
                  return arg;
                }
                args.unshift(arg);
                return match;
              });
            }
          }
          if (args.length) {
            for (var i = 0; i < args.length; i++) {
              formatted += " " + String(args[i]);
            }
          }
          formatted = formatted.replace(/%{2,2}/g, "%");
          return String(formatted);
        }
        function isSynchronousXHRSupported() {
          return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature("sync-xhr"));
        }
        function gt() {
          var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          return compareVersions(a, b) === 1;
        }
        function gte() {
          var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          return compareVersions(a, b) > -1;
        }
        var react_debug_tools = __webpack_require__(987);
        ;
        var CONCURRENT_MODE_NUMBER = 60111;
        var CONCURRENT_MODE_SYMBOL_STRING = "Symbol(react.concurrent_mode)";
        var CONTEXT_NUMBER = 60110;
        var CONTEXT_SYMBOL_STRING = "Symbol(react.context)";
        var SERVER_CONTEXT_SYMBOL_STRING = "Symbol(react.server_context)";
        var DEPRECATED_ASYNC_MODE_SYMBOL_STRING = "Symbol(react.async_mode)";
        var ELEMENT_NUMBER = 60103;
        var ELEMENT_SYMBOL_STRING = "Symbol(react.element)";
        var DEBUG_TRACING_MODE_NUMBER = 60129;
        var DEBUG_TRACING_MODE_SYMBOL_STRING = "Symbol(react.debug_trace_mode)";
        var ReactSymbols_FORWARD_REF_NUMBER = 60112;
        var ReactSymbols_FORWARD_REF_SYMBOL_STRING = "Symbol(react.forward_ref)";
        var FRAGMENT_NUMBER = 60107;
        var FRAGMENT_SYMBOL_STRING = "Symbol(react.fragment)";
        var ReactSymbols_LAZY_NUMBER = 60116;
        var ReactSymbols_LAZY_SYMBOL_STRING = "Symbol(react.lazy)";
        var ReactSymbols_MEMO_NUMBER = 60115;
        var ReactSymbols_MEMO_SYMBOL_STRING = "Symbol(react.memo)";
        var PORTAL_NUMBER = 60106;
        var PORTAL_SYMBOL_STRING = "Symbol(react.portal)";
        var PROFILER_NUMBER = 60114;
        var PROFILER_SYMBOL_STRING = "Symbol(react.profiler)";
        var PROVIDER_NUMBER = 60109;
        var PROVIDER_SYMBOL_STRING = "Symbol(react.provider)";
        var SCOPE_NUMBER = 60119;
        var SCOPE_SYMBOL_STRING = "Symbol(react.scope)";
        var STRICT_MODE_NUMBER = 60108;
        var STRICT_MODE_SYMBOL_STRING = "Symbol(react.strict_mode)";
        var ReactSymbols_SUSPENSE_NUMBER = 60113;
        var ReactSymbols_SUSPENSE_SYMBOL_STRING = "Symbol(react.suspense)";
        var ReactSymbols_SUSPENSE_LIST_NUMBER = 60120;
        var ReactSymbols_SUSPENSE_LIST_SYMBOL_STRING = "Symbol(react.suspense_list)";
        var SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING = "Symbol(react.server_context.defaultValue)";
        ;
        var consoleManagedByDevToolsDuringStrictMode = false;
        var enableLogger = false;
        var enableStyleXFeatures = false;
        var isInternalFacebookBuild = false;
        null;
        ;
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = (
          // $FlowFixMe[method-unbinding]
          typeof Object.is === "function" ? Object.is : is
        );
        const shared_objectIs = objectIs;
        ;
        var hasOwnProperty_hasOwnProperty = Object.prototype.hasOwnProperty;
        const shared_hasOwnProperty = hasOwnProperty_hasOwnProperty;
        ;
        var cachedStyleNameToValueMap = /* @__PURE__ */ new Map();
        function getStyleXData(data) {
          var sources = /* @__PURE__ */ new Set();
          var resolvedStyles = {};
          crawlData(data, sources, resolvedStyles);
          return {
            sources: Array.from(sources).sort(),
            resolvedStyles
          };
        }
        function crawlData(data, sources, resolvedStyles) {
          if (data == null) {
            return;
          }
          if (src_isArray(data)) {
            data.forEach(function(entry) {
              if (entry == null) {
                return;
              }
              if (src_isArray(entry)) {
                crawlData(entry, sources, resolvedStyles);
              } else {
                crawlObjectProperties(entry, sources, resolvedStyles);
              }
            });
          } else {
            crawlObjectProperties(data, sources, resolvedStyles);
          }
          resolvedStyles = Object.fromEntries(Object.entries(resolvedStyles).sort());
        }
        function crawlObjectProperties(entry, sources, resolvedStyles) {
          var keys = Object.keys(entry);
          keys.forEach(function(key) {
            var value = entry[key];
            if (typeof value === "string") {
              if (key === value) {
                sources.add(key);
              } else {
                var propertyValue = getPropertyValueForStyleName(value);
                if (propertyValue != null) {
                  resolvedStyles[key] = propertyValue;
                }
              }
            } else {
              var nestedStyle = {};
              resolvedStyles[key] = nestedStyle;
              crawlData([value], sources, nestedStyle);
            }
          });
        }
        function getPropertyValueForStyleName(styleName) {
          if (cachedStyleNameToValueMap.has(styleName)) {
            return cachedStyleNameToValueMap.get(styleName);
          }
          for (var styleSheetIndex = 0; styleSheetIndex < document.styleSheets.length; styleSheetIndex++) {
            var styleSheet = document.styleSheets[styleSheetIndex];
            var rules = null;
            try {
              rules = styleSheet.cssRules;
            } catch (_e) {
              continue;
            }
            for (var ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {
              if (!(rules[ruleIndex] instanceof CSSStyleRule)) {
                continue;
              }
              var rule = rules[ruleIndex];
              var cssText = rule.cssText, selectorText = rule.selectorText, style = rule.style;
              if (selectorText != null) {
                if (selectorText.startsWith(".".concat(styleName))) {
                  var match = cssText.match(/{ *([a-z\-]+):/);
                  if (match !== null) {
                    var property = match[1];
                    var value = style.getPropertyValue(property);
                    cachedStyleNameToValueMap.set(styleName, value);
                    return value;
                  } else {
                    return null;
                  }
                }
              }
            }
          }
          return null;
        }
        ;
        var CHANGE_LOG_URL = "https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md";
        var UNSUPPORTED_VERSION_URL = "https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back";
        var REACT_DEVTOOLS_WORKPLACE_URL = "https://fburl.com/react-devtools-workplace-group";
        var THEME_STYLES = {
          light: {
            "--color-attribute-name": "#ef6632",
            "--color-attribute-name-not-editable": "#23272f",
            "--color-attribute-name-inverted": "rgba(255, 255, 255, 0.7)",
            "--color-attribute-value": "#1a1aa6",
            "--color-attribute-value-inverted": "#ffffff",
            "--color-attribute-editable-value": "#1a1aa6",
            "--color-background": "#ffffff",
            "--color-background-hover": "rgba(0, 136, 250, 0.1)",
            "--color-background-inactive": "#e5e5e5",
            "--color-background-invalid": "#fff0f0",
            "--color-background-selected": "#0088fa",
            "--color-button-background": "#ffffff",
            "--color-button-background-focus": "#ededed",
            "--color-button": "#5f6673",
            "--color-button-disabled": "#cfd1d5",
            "--color-button-active": "#0088fa",
            "--color-button-focus": "#23272f",
            "--color-button-hover": "#23272f",
            "--color-border": "#eeeeee",
            "--color-commit-did-not-render-fill": "#cfd1d5",
            "--color-commit-did-not-render-fill-text": "#000000",
            "--color-commit-did-not-render-pattern": "#cfd1d5",
            "--color-commit-did-not-render-pattern-text": "#333333",
            "--color-commit-gradient-0": "#37afa9",
            "--color-commit-gradient-1": "#63b19e",
            "--color-commit-gradient-2": "#80b393",
            "--color-commit-gradient-3": "#97b488",
            "--color-commit-gradient-4": "#abb67d",
            "--color-commit-gradient-5": "#beb771",
            "--color-commit-gradient-6": "#cfb965",
            "--color-commit-gradient-7": "#dfba57",
            "--color-commit-gradient-8": "#efbb49",
            "--color-commit-gradient-9": "#febc38",
            "--color-commit-gradient-text": "#000000",
            "--color-component-name": "#6a51b2",
            "--color-component-name-inverted": "#ffffff",
            "--color-component-badge-background": "rgba(0, 0, 0, 0.1)",
            "--color-component-badge-background-inverted": "rgba(255, 255, 255, 0.25)",
            "--color-component-badge-count": "#777d88",
            "--color-component-badge-count-inverted": "rgba(255, 255, 255, 0.7)",
            "--color-console-error-badge-text": "#ffffff",
            "--color-console-error-background": "#fff0f0",
            "--color-console-error-border": "#ffd6d6",
            "--color-console-error-icon": "#eb3941",
            "--color-console-error-text": "#fe2e31",
            "--color-console-warning-badge-text": "#000000",
            "--color-console-warning-background": "#fffbe5",
            "--color-console-warning-border": "#fff5c1",
            "--color-console-warning-icon": "#f4bd00",
            "--color-console-warning-text": "#64460c",
            "--color-context-background": "rgba(0,0,0,.9)",
            "--color-context-background-hover": "rgba(255, 255, 255, 0.1)",
            "--color-context-background-selected": "#178fb9",
            "--color-context-border": "#3d424a",
            "--color-context-text": "#ffffff",
            "--color-context-text-selected": "#ffffff",
            "--color-dim": "#777d88",
            "--color-dimmer": "#cfd1d5",
            "--color-dimmest": "#eff0f1",
            "--color-error-background": "hsl(0, 100%, 97%)",
            "--color-error-border": "hsl(0, 100%, 92%)",
            "--color-error-text": "#ff0000",
            "--color-expand-collapse-toggle": "#777d88",
            "--color-link": "#0000ff",
            "--color-modal-background": "rgba(255, 255, 255, 0.75)",
            "--color-bridge-version-npm-background": "#eff0f1",
            "--color-bridge-version-npm-text": "#000000",
            "--color-bridge-version-number": "#0088fa",
            "--color-primitive-hook-badge-background": "#e5e5e5",
            "--color-primitive-hook-badge-text": "#5f6673",
            "--color-record-active": "#fc3a4b",
            "--color-record-hover": "#3578e5",
            "--color-record-inactive": "#0088fa",
            "--color-resize-bar": "#eeeeee",
            "--color-resize-bar-active": "#dcdcdc",
            "--color-resize-bar-border": "#d1d1d1",
            "--color-resize-bar-dot": "#333333",
            "--color-timeline-internal-module": "#d1d1d1",
            "--color-timeline-internal-module-hover": "#c9c9c9",
            "--color-timeline-internal-module-text": "#444",
            "--color-timeline-native-event": "#ccc",
            "--color-timeline-native-event-hover": "#aaa",
            "--color-timeline-network-primary": "#fcf3dc",
            "--color-timeline-network-primary-hover": "#f0e7d1",
            "--color-timeline-network-secondary": "#efc457",
            "--color-timeline-network-secondary-hover": "#e3ba52",
            "--color-timeline-priority-background": "#f6f6f6",
            "--color-timeline-priority-border": "#eeeeee",
            "--color-timeline-user-timing": "#c9cacd",
            "--color-timeline-user-timing-hover": "#93959a",
            "--color-timeline-react-idle": "#d3e5f6",
            "--color-timeline-react-idle-hover": "#c3d9ef",
            "--color-timeline-react-render": "#9fc3f3",
            "--color-timeline-react-render-hover": "#83afe9",
            "--color-timeline-react-render-text": "#11365e",
            "--color-timeline-react-commit": "#c88ff0",
            "--color-timeline-react-commit-hover": "#b281d6",
            "--color-timeline-react-commit-text": "#3e2c4a",
            "--color-timeline-react-layout-effects": "#b281d6",
            "--color-timeline-react-layout-effects-hover": "#9d71bd",
            "--color-timeline-react-layout-effects-text": "#3e2c4a",
            "--color-timeline-react-passive-effects": "#b281d6",
            "--color-timeline-react-passive-effects-hover": "#9d71bd",
            "--color-timeline-react-passive-effects-text": "#3e2c4a",
            "--color-timeline-react-schedule": "#9fc3f3",
            "--color-timeline-react-schedule-hover": "#2683E2",
            "--color-timeline-react-suspense-rejected": "#f1cc14",
            "--color-timeline-react-suspense-rejected-hover": "#ffdf37",
            "--color-timeline-react-suspense-resolved": "#a6e59f",
            "--color-timeline-react-suspense-resolved-hover": "#89d281",
            "--color-timeline-react-suspense-unresolved": "#c9cacd",
            "--color-timeline-react-suspense-unresolved-hover": "#93959a",
            "--color-timeline-thrown-error": "#ee1638",
            "--color-timeline-thrown-error-hover": "#da1030",
            "--color-timeline-text-color": "#000000",
            "--color-timeline-text-dim-color": "#ccc",
            "--color-timeline-react-work-border": "#eeeeee",
            "--color-search-match": "yellow",
            "--color-search-match-current": "#f7923b",
            "--color-selected-tree-highlight-active": "rgba(0, 136, 250, 0.1)",
            "--color-selected-tree-highlight-inactive": "rgba(0, 0, 0, 0.05)",
            "--color-scroll-caret": "rgba(150, 150, 150, 0.5)",
            "--color-tab-selected-border": "#0088fa",
            "--color-text": "#000000",
            "--color-text-invalid": "#ff0000",
            "--color-text-selected": "#ffffff",
            "--color-toggle-background-invalid": "#fc3a4b",
            "--color-toggle-background-on": "#0088fa",
            "--color-toggle-background-off": "#cfd1d5",
            "--color-toggle-text": "#ffffff",
            "--color-warning-background": "#fb3655",
            "--color-warning-background-hover": "#f82042",
            "--color-warning-text-color": "#ffffff",
            "--color-warning-text-color-inverted": "#fd4d69",
            // The styles below should be kept in sync with 'root.css'
            // They are repeated there because they're used by e.g. tooltips or context menus
            // which get rendered outside of the DOM subtree (where normal theme/styles are written).
            "--color-scroll-thumb": "#c2c2c2",
            "--color-scroll-track": "#fafafa",
            "--color-tooltip-background": "rgba(0, 0, 0, 0.9)",
            "--color-tooltip-text": "#ffffff"
          },
          dark: {
            "--color-attribute-name": "#9d87d2",
            "--color-attribute-name-not-editable": "#ededed",
            "--color-attribute-name-inverted": "#282828",
            "--color-attribute-value": "#cedae0",
            "--color-attribute-value-inverted": "#ffffff",
            "--color-attribute-editable-value": "yellow",
            "--color-background": "#282c34",
            "--color-background-hover": "rgba(255, 255, 255, 0.1)",
            "--color-background-inactive": "#3d424a",
            "--color-background-invalid": "#5c0000",
            "--color-background-selected": "#178fb9",
            "--color-button-background": "#282c34",
            "--color-button-background-focus": "#3d424a",
            "--color-button": "#afb3b9",
            "--color-button-active": "#61dafb",
            "--color-button-disabled": "#4f5766",
            "--color-button-focus": "#a2e9fc",
            "--color-button-hover": "#ededed",
            "--color-border": "#3d424a",
            "--color-commit-did-not-render-fill": "#777d88",
            "--color-commit-did-not-render-fill-text": "#000000",
            "--color-commit-did-not-render-pattern": "#666c77",
            "--color-commit-did-not-render-pattern-text": "#ffffff",
            "--color-commit-gradient-0": "#37afa9",
            "--color-commit-gradient-1": "#63b19e",
            "--color-commit-gradient-2": "#80b393",
            "--color-commit-gradient-3": "#97b488",
            "--color-commit-gradient-4": "#abb67d",
            "--color-commit-gradient-5": "#beb771",
            "--color-commit-gradient-6": "#cfb965",
            "--color-commit-gradient-7": "#dfba57",
            "--color-commit-gradient-8": "#efbb49",
            "--color-commit-gradient-9": "#febc38",
            "--color-commit-gradient-text": "#000000",
            "--color-component-name": "#61dafb",
            "--color-component-name-inverted": "#282828",
            "--color-component-badge-background": "rgba(255, 255, 255, 0.25)",
            "--color-component-badge-background-inverted": "rgba(0, 0, 0, 0.25)",
            "--color-component-badge-count": "#8f949d",
            "--color-component-badge-count-inverted": "rgba(255, 255, 255, 0.7)",
            "--color-console-error-badge-text": "#000000",
            "--color-console-error-background": "#290000",
            "--color-console-error-border": "#5c0000",
            "--color-console-error-icon": "#eb3941",
            "--color-console-error-text": "#fc7f7f",
            "--color-console-warning-badge-text": "#000000",
            "--color-console-warning-background": "#332b00",
            "--color-console-warning-border": "#665500",
            "--color-console-warning-icon": "#f4bd00",
            "--color-console-warning-text": "#f5f2ed",
            "--color-context-background": "rgba(255,255,255,.95)",
            "--color-context-background-hover": "rgba(0, 136, 250, 0.1)",
            "--color-context-background-selected": "#0088fa",
            "--color-context-border": "#eeeeee",
            "--color-context-text": "#000000",
            "--color-context-text-selected": "#ffffff",
            "--color-dim": "#8f949d",
            "--color-dimmer": "#777d88",
            "--color-dimmest": "#4f5766",
            "--color-error-background": "#200",
            "--color-error-border": "#900",
            "--color-error-text": "#f55",
            "--color-expand-collapse-toggle": "#8f949d",
            "--color-link": "#61dafb",
            "--color-modal-background": "rgba(0, 0, 0, 0.75)",
            "--color-bridge-version-npm-background": "rgba(0, 0, 0, 0.25)",
            "--color-bridge-version-npm-text": "#ffffff",
            "--color-bridge-version-number": "yellow",
            "--color-primitive-hook-badge-background": "rgba(0, 0, 0, 0.25)",
            "--color-primitive-hook-badge-text": "rgba(255, 255, 255, 0.7)",
            "--color-record-active": "#fc3a4b",
            "--color-record-hover": "#a2e9fc",
            "--color-record-inactive": "#61dafb",
            "--color-resize-bar": "#282c34",
            "--color-resize-bar-active": "#31363f",
            "--color-resize-bar-border": "#3d424a",
            "--color-resize-bar-dot": "#cfd1d5",
            "--color-timeline-internal-module": "#303542",
            "--color-timeline-internal-module-hover": "#363b4a",
            "--color-timeline-internal-module-text": "#7f8899",
            "--color-timeline-native-event": "#b2b2b2",
            "--color-timeline-native-event-hover": "#949494",
            "--color-timeline-network-primary": "#fcf3dc",
            "--color-timeline-network-primary-hover": "#e3dbc5",
            "--color-timeline-network-secondary": "#efc457",
            "--color-timeline-network-secondary-hover": "#d6af4d",
            "--color-timeline-priority-background": "#1d2129",
            "--color-timeline-priority-border": "#282c34",
            "--color-timeline-user-timing": "#c9cacd",
            "--color-timeline-user-timing-hover": "#93959a",
            "--color-timeline-react-idle": "#3d485b",
            "--color-timeline-react-idle-hover": "#465269",
            "--color-timeline-react-render": "#2683E2",
            "--color-timeline-react-render-hover": "#1a76d4",
            "--color-timeline-react-render-text": "#11365e",
            "--color-timeline-react-commit": "#731fad",
            "--color-timeline-react-commit-hover": "#611b94",
            "--color-timeline-react-commit-text": "#e5c1ff",
            "--color-timeline-react-layout-effects": "#611b94",
            "--color-timeline-react-layout-effects-hover": "#51167a",
            "--color-timeline-react-layout-effects-text": "#e5c1ff",
            "--color-timeline-react-passive-effects": "#611b94",
            "--color-timeline-react-passive-effects-hover": "#51167a",
            "--color-timeline-react-passive-effects-text": "#e5c1ff",
            "--color-timeline-react-schedule": "#2683E2",
            "--color-timeline-react-schedule-hover": "#1a76d4",
            "--color-timeline-react-suspense-rejected": "#f1cc14",
            "--color-timeline-react-suspense-rejected-hover": "#e4c00f",
            "--color-timeline-react-suspense-resolved": "#a6e59f",
            "--color-timeline-react-suspense-resolved-hover": "#89d281",
            "--color-timeline-react-suspense-unresolved": "#c9cacd",
            "--color-timeline-react-suspense-unresolved-hover": "#93959a",
            "--color-timeline-thrown-error": "#fb3655",
            "--color-timeline-thrown-error-hover": "#f82042",
            "--color-timeline-text-color": "#282c34",
            "--color-timeline-text-dim-color": "#555b66",
            "--color-timeline-react-work-border": "#3d424a",
            "--color-search-match": "yellow",
            "--color-search-match-current": "#f7923b",
            "--color-selected-tree-highlight-active": "rgba(23, 143, 185, 0.15)",
            "--color-selected-tree-highlight-inactive": "rgba(255, 255, 255, 0.05)",
            "--color-scroll-caret": "#4f5766",
            "--color-shadow": "rgba(0, 0, 0, 0.5)",
            "--color-tab-selected-border": "#178fb9",
            "--color-text": "#ffffff",
            "--color-text-invalid": "#ff8080",
            "--color-text-selected": "#ffffff",
            "--color-toggle-background-invalid": "#fc3a4b",
            "--color-toggle-background-on": "#178fb9",
            "--color-toggle-background-off": "#777d88",
            "--color-toggle-text": "#ffffff",
            "--color-warning-background": "#ee1638",
            "--color-warning-background-hover": "#da1030",
            "--color-warning-text-color": "#ffffff",
            "--color-warning-text-color-inverted": "#ee1638",
            // The styles below should be kept in sync with 'root.css'
            // They are repeated there because they're used by e.g. tooltips or context menus
            // which get rendered outside of the DOM subtree (where normal theme/styles are written).
            "--color-scroll-thumb": "#afb3b9",
            "--color-scroll-track": "#313640",
            "--color-tooltip-background": "rgba(255, 255, 255, 0.95)",
            "--color-tooltip-text": "#000000"
          },
          compact: {
            "--font-size-monospace-small": "9px",
            "--font-size-monospace-normal": "11px",
            "--font-size-monospace-large": "15px",
            "--font-size-sans-small": "10px",
            "--font-size-sans-normal": "12px",
            "--font-size-sans-large": "14px",
            "--line-height-data": "18px"
          },
          comfortable: {
            "--font-size-monospace-small": "10px",
            "--font-size-monospace-normal": "13px",
            "--font-size-monospace-large": "17px",
            "--font-size-sans-small": "12px",
            "--font-size-sans-normal": "14px",
            "--font-size-sans-large": "16px",
            "--line-height-data": "22px"
          }
        };
        var COMFORTABLE_LINE_HEIGHT = parseInt(THEME_STYLES.comfortable["--line-height-data"], 10);
        var COMPACT_LINE_HEIGHT = parseInt(THEME_STYLES.compact["--line-height-data"], 10);
        ;
        var REACT_TOTAL_NUM_LANES = 31;
        var SCHEDULING_PROFILER_VERSION = 1;
        var SNAPSHOT_MAX_HEIGHT = 60;
        ;
        function DevToolsConsolePatching_ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function DevToolsConsolePatching_objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              DevToolsConsolePatching_ownKeys(Object(source), true).forEach(function(key) {
                DevToolsConsolePatching_defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              DevToolsConsolePatching_ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function DevToolsConsolePatching_defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevLog
              }),
              info: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevInfo
              }),
              warn: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevWarn
              }),
              error: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevError
              }),
              group: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevGroup
              }),
              groupCollapsed: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevGroupCollapsed
              }),
              groupEnd: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
        ;
        function DevToolsComponentStackFrame_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            DevToolsComponentStackFrame_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            DevToolsComponentStackFrame_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return DevToolsComponentStackFrame_typeof(obj);
        }
        var prefix;
        function describeBuiltInComponentFrame(name, ownerFn) {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
        var reentry = false;
        var componentFrameCache;
        if (false) {
          var PossiblyWeakMap;
        }
        function describeNativeComponentFrame(fn, construct, currentDispatcherRef) {
          if (!fn || reentry) {
            return "";
          }
          if (false) {
            var frame;
          }
          var control;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          reentry = true;
          var previousDispatcher = currentDispatcherRef.current;
          currentDispatcherRef.current = null;
          disableLogs();
          try {
            if (construct) {
              var Fake = function Fake2() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function set() {
                  throw Error();
                }
              });
              if ((typeof Reflect === "undefined" ? "undefined" : DevToolsComponentStackFrame_typeof(Reflect)) === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (false) {
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            Error.prepareStackTrace = previousPrepareStackTrace;
            currentDispatcherRef.current = previousDispatcher;
            reenableLogs();
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          if (false) {
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, ownerFn, currentDispatcherRef) {
          return describeNativeComponentFrame(ctor, true, currentDispatcherRef);
        }
        function describeFunctionComponentFrame(fn, ownerFn, currentDispatcherRef) {
          return describeNativeComponentFrame(fn, false, currentDispatcherRef);
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, ownerFn, currentDispatcherRef) {
          if (true) {
            return "";
          }
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            return describeNativeComponentFrame(type, shouldConstruct(type), currentDispatcherRef);
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type, ownerFn);
          }
          switch (type) {
            case SUSPENSE_NUMBER:
            case SUSPENSE_SYMBOL_STRING:
              return describeBuiltInComponentFrame("Suspense", ownerFn);
            case SUSPENSE_LIST_NUMBER:
            case SUSPENSE_LIST_SYMBOL_STRING:
              return describeBuiltInComponentFrame("SuspenseList", ownerFn);
          }
          if (DevToolsComponentStackFrame_typeof(type) === "object") {
            switch (type.$$typeof) {
              case FORWARD_REF_NUMBER:
              case FORWARD_REF_SYMBOL_STRING:
                return describeFunctionComponentFrame(type.render, ownerFn, currentDispatcherRef);
              case MEMO_NUMBER:
              case MEMO_SYMBOL_STRING:
                return describeUnknownElementTypeFrameInDEV(type.type, ownerFn, currentDispatcherRef);
              case LAZY_NUMBER:
              case LAZY_SYMBOL_STRING: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn, currentDispatcherRef);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        ;
        function describeFiber(workTagMap, workInProgress, currentDispatcherRef) {
          var HostComponent = workTagMap.HostComponent, LazyComponent = workTagMap.LazyComponent, SuspenseComponent = workTagMap.SuspenseComponent, SuspenseListComponent = workTagMap.SuspenseListComponent, FunctionComponent = workTagMap.FunctionComponent, IndeterminateComponent = workTagMap.IndeterminateComponent, SimpleMemoComponent = workTagMap.SimpleMemoComponent, ForwardRef = workTagMap.ForwardRef, ClassComponent = workTagMap.ClassComponent;
          var owner = false ? 0 : null;
          switch (workInProgress.tag) {
            case HostComponent:
              return describeBuiltInComponentFrame(workInProgress.type, owner);
            case LazyComponent:
              return describeBuiltInComponentFrame("Lazy", owner);
            case SuspenseComponent:
              return describeBuiltInComponentFrame("Suspense", owner);
            case SuspenseListComponent:
              return describeBuiltInComponentFrame("SuspenseList", owner);
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
              return describeFunctionComponentFrame(workInProgress.type, owner, currentDispatcherRef);
            case ForwardRef:
              return describeFunctionComponentFrame(workInProgress.type.render, owner, currentDispatcherRef);
            case ClassComponent:
              return describeClassComponentFrame(workInProgress.type, owner, currentDispatcherRef);
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {
          try {
            var info = "";
            var node = workInProgress;
            do {
              info += describeFiber(workTagMap, node, currentDispatcherRef);
              node = node.return;
            } while (node);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        ;
        function profilingHooks_slicedToArray(arr, i) {
          return profilingHooks_arrayWithHoles(arr) || profilingHooks_iterableToArrayLimit(arr, i) || profilingHooks_unsupportedIterableToArray(arr, i) || profilingHooks_nonIterableRest();
        }
        function profilingHooks_nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function profilingHooks_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return profilingHooks_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return profilingHooks_arrayLikeToArray(o, minLen);
        }
        function profilingHooks_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function profilingHooks_iterableToArrayLimit(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
            return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null)
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        function profilingHooks_arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        function profilingHooks_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            profilingHooks_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            profilingHooks_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return profilingHooks_typeof(obj);
        }
        var TIME_OFFSET = 10;
        var performanceTarget = null;
        var supportsUserTiming = typeof performance !== "undefined" && // $FlowFixMe[method-unbinding]
        typeof performance.mark === "function" && // $FlowFixMe[method-unbinding]
        typeof performance.clearMarks === "function";
        var supportsUserTimingV3 = false;
        if (supportsUserTiming) {
          var CHECK_V3_MARK = "__v3";
          var markOptions = {};
          Object.defineProperty(markOptions, "startTime", {
            get: function get() {
              supportsUserTimingV3 = true;
              return 0;
            },
            set: function set() {
            }
          });
          try {
            performance.mark(CHECK_V3_MARK, markOptions);
          } catch (error) {
          } finally {
            performance.clearMarks(CHECK_V3_MARK);
          }
        }
        if (supportsUserTimingV3) {
          performanceTarget = performance;
        }
        var profilingHooks_getCurrentTime = (
          // $FlowFixMe[method-unbinding]
          (typeof performance === "undefined" ? "undefined" : profilingHooks_typeof(performance)) === "object" && typeof performance.now === "function" ? function() {
            return performance.now();
          } : function() {
            return Date.now();
          }
        );
        function setPerformanceMock_ONLY_FOR_TESTING(performanceMock) {
          performanceTarget = performanceMock;
          supportsUserTiming = performanceMock !== null;
          supportsUserTimingV3 = performanceMock !== null;
        }
        function createProfilingHooks(_ref) {
          var getDisplayNameForFiber = _ref.getDisplayNameForFiber, getIsProfiling = _ref.getIsProfiling, getLaneLabelMap = _ref.getLaneLabelMap, workTagMap = _ref.workTagMap, currentDispatcherRef = _ref.currentDispatcherRef, reactVersion = _ref.reactVersion;
          var currentBatchUID = 0;
          var currentReactComponentMeasure = null;
          var currentReactMeasuresStack = [];
          var currentTimelineData = null;
          var currentFiberStacks = /* @__PURE__ */ new Map();
          var isProfiling = false;
          var nextRenderShouldStartNewBatch = false;
          function getRelativeTime() {
            var currentTime = profilingHooks_getCurrentTime();
            if (currentTimelineData) {
              if (currentTimelineData.startTime === 0) {
                currentTimelineData.startTime = currentTime - TIME_OFFSET;
              }
              return currentTime - currentTimelineData.startTime;
            }
            return 0;
          }
          function getInternalModuleRanges() {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges === "function") {
              var ranges = __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges();
              if (shared_isArray(ranges)) {
                return ranges;
              }
            }
            return null;
          }
          function getTimelineData() {
            return currentTimelineData;
          }
          function laneToLanesArray(lanes) {
            var lanesArray = [];
            var lane = 1;
            for (var index = 0; index < REACT_TOTAL_NUM_LANES; index++) {
              if (lane & lanes) {
                lanesArray.push(lane);
              }
              lane *= 2;
            }
            return lanesArray;
          }
          var laneToLabelMap = typeof getLaneLabelMap === "function" ? getLaneLabelMap() : null;
          function markMetadata() {
            markAndClear("--react-version-".concat(reactVersion));
            markAndClear("--profiler-version-".concat(SCHEDULING_PROFILER_VERSION));
            var ranges = getInternalModuleRanges();
            if (ranges) {
              for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (shared_isArray(range) && range.length === 2) {
                  var _ranges$i = profilingHooks_slicedToArray(ranges[i], 2), startStackFrame = _ranges$i[0], stopStackFrame = _ranges$i[1];
                  markAndClear("--react-internal-module-start-".concat(startStackFrame));
                  markAndClear("--react-internal-module-stop-".concat(stopStackFrame));
                }
              }
            }
            if (laneToLabelMap != null) {
              var labels = Array.from(laneToLabelMap.values()).join(",");
              markAndClear("--react-lane-labels-".concat(labels));
            }
          }
          function markAndClear(markName) {
            performanceTarget.mark(markName);
            performanceTarget.clearMarks(markName);
          }
          function recordReactMeasureStarted(type, lanes) {
            var depth = 0;
            if (currentReactMeasuresStack.length > 0) {
              var top = currentReactMeasuresStack[currentReactMeasuresStack.length - 1];
              depth = top.type === "render-idle" ? top.depth : top.depth + 1;
            }
            var lanesArray = laneToLanesArray(lanes);
            var reactMeasure = {
              type,
              batchUID: currentBatchUID,
              depth,
              lanes: lanesArray,
              timestamp: getRelativeTime(),
              duration: 0
            };
            currentReactMeasuresStack.push(reactMeasure);
            if (currentTimelineData) {
              var _currentTimelineData = currentTimelineData, batchUIDToMeasuresMap = _currentTimelineData.batchUIDToMeasuresMap, laneToReactMeasureMap = _currentTimelineData.laneToReactMeasureMap;
              var reactMeasures = batchUIDToMeasuresMap.get(currentBatchUID);
              if (reactMeasures != null) {
                reactMeasures.push(reactMeasure);
              } else {
                batchUIDToMeasuresMap.set(currentBatchUID, [reactMeasure]);
              }
              lanesArray.forEach(function(lane) {
                reactMeasures = laneToReactMeasureMap.get(lane);
                if (reactMeasures) {
                  reactMeasures.push(reactMeasure);
                }
              });
            }
          }
          function recordReactMeasureCompleted(type) {
            var currentTime = getRelativeTime();
            if (currentReactMeasuresStack.length === 0) {
              console.error('Unexpected type "%s" completed at %sms while currentReactMeasuresStack is empty.', type, currentTime);
              return;
            }
            var top = currentReactMeasuresStack.pop();
            if (top.type !== type) {
              console.error('Unexpected type "%s" completed at %sms before "%s" completed.', type, currentTime, top.type);
            }
            top.duration = currentTime - top.timestamp;
            if (currentTimelineData) {
              currentTimelineData.duration = getRelativeTime() + TIME_OFFSET;
            }
          }
          function markCommitStarted(lanes) {
            if (isProfiling) {
              recordReactMeasureStarted("commit", lanes);
              nextRenderShouldStartNewBatch = true;
            }
            if (supportsUserTimingV3) {
              markAndClear("--commit-start-".concat(lanes));
              markMetadata();
            }
          }
          function markCommitStopped() {
            if (isProfiling) {
              recordReactMeasureCompleted("commit");
              recordReactMeasureCompleted("render-idle");
            }
            if (supportsUserTimingV3) {
              markAndClear("--commit-stop");
            }
          }
          function markComponentRenderStarted(fiber) {
            if (isProfiling || supportsUserTimingV3) {
              var componentName = getDisplayNameForFiber(fiber) || "Unknown";
              if (isProfiling) {
                if (isProfiling) {
                  currentReactComponentMeasure = {
                    componentName,
                    duration: 0,
                    timestamp: getRelativeTime(),
                    type: "render",
                    warning: null
                  };
                }
              }
              if (supportsUserTimingV3) {
                markAndClear("--component-render-start-".concat(componentName));
              }
            }
          }
          function markComponentRenderStopped() {
            if (isProfiling) {
              if (currentReactComponentMeasure) {
                if (currentTimelineData) {
                  currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
                }
                currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
                getRelativeTime() - currentReactComponentMeasure.timestamp;
                currentReactComponentMeasure = null;
              }
            }
            if (supportsUserTimingV3) {
              markAndClear("--component-render-stop");
            }
          }
          function markComponentLayoutEffectMountStarted(fiber) {
            if (isProfiling || supportsUserTimingV3) {
              var componentName = getDisplayNameForFiber(fiber) || "Unknown";
              if (isProfiling) {
                if (isProfiling) {
                  currentReactComponentMeasure = {
                    componentName,
                    duration: 0,
                    timestamp: getRelativeTime(),
                    type: "layout-effect-mount",
                    warning: null
                  };
                }
              }
              if (supportsUserTimingV3) {
                markAndClear("--component-layout-effect-mount-start-".concat(componentName));
              }
            }
          }
          function markComponentLayoutEffectMountStopped() {
            if (isProfiling) {
              if (currentReactComponentMeasure) {
                if (currentTimelineData) {
                  currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
                }
                currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
                getRelativeTime() - currentReactComponentMeasure.timestamp;
                currentReactComponentMeasure = null;
              }
            }
            if (supportsUserTimingV3) {
              markAndClear("--component-layout-effect-mount-stop");
            }
          }
          function markComponentLayoutEffectUnmountStarted(fiber) {
            if (isProfiling || supportsUserTimingV3) {
              var componentName = getDisplayNameForFiber(fiber) || "Unknown";
              if (isProfiling) {
                if (isProfiling) {
                  currentReactComponentMeasure = {
                    componentName,
                    duration: 0,
                    timestamp: getRelativeTime(),
                    type: "layout-effect-unmount",
                    warning: null
                  };
                }
              }
              if (supportsUserTimingV3) {
                markAndClear("--component-layout-effect-unmount-start-".concat(componentName));
              }
            }
          }
          function markComponentLayoutEffectUnmountStopped() {
            if (isProfiling) {
              if (currentReactComponentMeasure) {
                if (currentTimelineData) {
                  currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
                }
                currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
                getRelativeTime() - currentReactComponentMeasure.timestamp;
                currentReactComponentMeasure = null;
              }
            }
            if (supportsUserTimingV3) {
              markAndClear("--component-layout-effect-unmount-stop");
            }
          }
          function markComponentPassiveEffectMountStarted(fiber) {
            if (isProfiling || supportsUserTimingV3) {
              var componentName = getDisplayNameForFiber(fiber) || "Unknown";
              if (isProfiling) {
                if (isProfiling) {
                  currentReactComponentMeasure = {
                    componentName,
                    duration: 0,
                    timestamp: getRelativeTime(),
                    type: "passive-effect-mount",
                    warning: null
                  };
                }
              }
              if (supportsUserTimingV3) {
                markAndClear("--component-passive-effect-mount-start-".concat(componentName));
              }
            }
          }
          function markComponentPassiveEffectMountStopped() {
            if (isProfiling) {
              if (currentReactComponentMeasure) {
                if (currentTimelineData) {
                  currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
                }
                currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
                getRelativeTime() - currentReactComponentMeasure.timestamp;
                currentReactComponentMeasure = null;
              }
            }
            if (supportsUserTimingV3) {
              markAndClear("--component-passive-effect-mount-stop");
            }
          }
          function markComponentPassiveEffectUnmountStarted(fiber) {
            if (isProfiling || supportsUserTimingV3) {
              var componentName = getDisplayNameForFiber(fiber) || "Unknown";
              if (isProfiling) {
                if (isProfiling) {
                  currentReactComponentMeasure = {
                    componentName,
                    duration: 0,
                    timestamp: getRelativeTime(),
                    type: "passive-effect-unmount",
                    warning: null
                  };
                }
              }
              if (supportsUserTimingV3) {
                markAndClear("--component-passive-effect-unmount-start-".concat(componentName));
              }
            }
          }
          function markComponentPassiveEffectUnmountStopped() {
            if (isProfiling) {
              if (currentReactComponentMeasure) {
                if (currentTimelineData) {
                  currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
                }
                currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
                getRelativeTime() - currentReactComponentMeasure.timestamp;
                currentReactComponentMeasure = null;
              }
            }
            if (supportsUserTimingV3) {
              markAndClear("--component-passive-effect-unmount-stop");
            }
          }
          function markComponentErrored(fiber, thrownValue, lanes) {
            if (isProfiling || supportsUserTimingV3) {
              var componentName = getDisplayNameForFiber(fiber) || "Unknown";
              var phase = fiber.alternate === null ? "mount" : "update";
              var message = "";
              if (thrownValue !== null && profilingHooks_typeof(thrownValue) === "object" && typeof thrownValue.message === "string") {
                message = thrownValue.message;
              } else if (typeof thrownValue === "string") {
                message = thrownValue;
              }
              if (isProfiling) {
                if (currentTimelineData) {
                  currentTimelineData.thrownErrors.push({
                    componentName,
                    message,
                    phase,
                    timestamp: getRelativeTime(),
                    type: "thrown-error"
                  });
                }
              }
              if (supportsUserTimingV3) {
                markAndClear("--error-".concat(componentName, "-").concat(phase, "-").concat(message));
              }
            }
          }
          var PossiblyWeakMap2 = typeof WeakMap === "function" ? WeakMap : Map;
          var wakeableIDs = new PossiblyWeakMap2();
          var wakeableID = 0;
          function getWakeableID(wakeable) {
            if (!wakeableIDs.has(wakeable)) {
              wakeableIDs.set(wakeable, wakeableID++);
            }
            return wakeableIDs.get(wakeable);
          }
          function markComponentSuspended(fiber, wakeable, lanes) {
            if (isProfiling || supportsUserTimingV3) {
              var eventType = wakeableIDs.has(wakeable) ? "resuspend" : "suspend";
              var id = getWakeableID(wakeable);
              var componentName = getDisplayNameForFiber(fiber) || "Unknown";
              var phase = fiber.alternate === null ? "mount" : "update";
              var displayName = wakeable.displayName || "";
              var suspenseEvent = null;
              if (isProfiling) {
                suspenseEvent = {
                  componentName,
                  depth: 0,
                  duration: 0,
                  id: "".concat(id),
                  phase,
                  promiseName: displayName,
                  resolution: "unresolved",
                  timestamp: getRelativeTime(),
                  type: "suspense",
                  warning: null
                };
                if (currentTimelineData) {
                  currentTimelineData.suspenseEvents.push(suspenseEvent);
                }
              }
              if (supportsUserTimingV3) {
                markAndClear("--suspense-".concat(eventType, "-").concat(id, "-").concat(componentName, "-").concat(phase, "-").concat(lanes, "-").concat(displayName));
              }
              wakeable.then(function() {
                if (suspenseEvent) {
                  suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;
                  suspenseEvent.resolution = "resolved";
                }
                if (supportsUserTimingV3) {
                  markAndClear("--suspense-resolved-".concat(id, "-").concat(componentName));
                }
              }, function() {
                if (suspenseEvent) {
                  suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;
                  suspenseEvent.resolution = "rejected";
                }
                if (supportsUserTimingV3) {
                  markAndClear("--suspense-rejected-".concat(id, "-").concat(componentName));
                }
              });
            }
          }
          function markLayoutEffectsStarted(lanes) {
            if (isProfiling) {
              recordReactMeasureStarted("layout-effects", lanes);
            }
            if (supportsUserTimingV3) {
              markAndClear("--layout-effects-start-".concat(lanes));
            }
          }
          function markLayoutEffectsStopped() {
            if (isProfiling) {
              recordReactMeasureCompleted("layout-effects");
            }
            if (supportsUserTimingV3) {
              markAndClear("--layout-effects-stop");
            }
          }
          function markPassiveEffectsStarted(lanes) {
            if (isProfiling) {
              recordReactMeasureStarted("passive-effects", lanes);
            }
            if (supportsUserTimingV3) {
              markAndClear("--passive-effects-start-".concat(lanes));
            }
          }
          function markPassiveEffectsStopped() {
            if (isProfiling) {
              recordReactMeasureCompleted("passive-effects");
            }
            if (supportsUserTimingV3) {
              markAndClear("--passive-effects-stop");
            }
          }
          function markRenderStarted(lanes) {
            if (isProfiling) {
              if (nextRenderShouldStartNewBatch) {
                nextRenderShouldStartNewBatch = false;
                currentBatchUID++;
              }
              if (currentReactMeasuresStack.length === 0 || currentReactMeasuresStack[currentReactMeasuresStack.length - 1].type !== "render-idle") {
                recordReactMeasureStarted("render-idle", lanes);
              }
              recordReactMeasureStarted("render", lanes);
            }
            if (supportsUserTimingV3) {
              markAndClear("--render-start-".concat(lanes));
            }
          }
          function markRenderYielded() {
            if (isProfiling) {
              recordReactMeasureCompleted("render");
            }
            if (supportsUserTimingV3) {
              markAndClear("--render-yield");
            }
          }
          function markRenderStopped() {
            if (isProfiling) {
              recordReactMeasureCompleted("render");
            }
            if (supportsUserTimingV3) {
              markAndClear("--render-stop");
            }
          }
          function markRenderScheduled(lane) {
            if (isProfiling) {
              if (currentTimelineData) {
                currentTimelineData.schedulingEvents.push({
                  lanes: laneToLanesArray(lane),
                  timestamp: getRelativeTime(),
                  type: "schedule-render",
                  warning: null
                });
              }
            }
            if (supportsUserTimingV3) {
              markAndClear("--schedule-render-".concat(lane));
            }
          }
          function markForceUpdateScheduled(fiber, lane) {
            if (isProfiling || supportsUserTimingV3) {
              var componentName = getDisplayNameForFiber(fiber) || "Unknown";
              if (isProfiling) {
                if (currentTimelineData) {
                  currentTimelineData.schedulingEvents.push({
                    componentName,
                    lanes: laneToLanesArray(lane),
                    timestamp: getRelativeTime(),
                    type: "schedule-force-update",
                    warning: null
                  });
                }
              }
              if (supportsUserTimingV3) {
                markAndClear("--schedule-forced-update-".concat(lane, "-").concat(componentName));
              }
            }
          }
          function getParentFibers(fiber) {
            var parents = [];
            var parent = fiber;
            while (parent !== null) {
              parents.push(parent);
              parent = parent.return;
            }
            return parents;
          }
          function markStateUpdateScheduled(fiber, lane) {
            if (isProfiling || supportsUserTimingV3) {
              var componentName = getDisplayNameForFiber(fiber) || "Unknown";
              if (isProfiling) {
                if (currentTimelineData) {
                  var event = {
                    componentName,
                    // Store the parent fibers so we can post process
                    // them after we finish profiling
                    lanes: laneToLanesArray(lane),
                    timestamp: getRelativeTime(),
                    type: "schedule-state-update",
                    warning: null
                  };
                  currentFiberStacks.set(event, getParentFibers(fiber));
                  currentTimelineData.schedulingEvents.push(event);
                }
              }
              if (supportsUserTimingV3) {
                markAndClear("--schedule-state-update-".concat(lane, "-").concat(componentName));
              }
            }
          }
          function toggleProfilingStatus(value) {
            if (isProfiling !== value) {
              isProfiling = value;
              if (isProfiling) {
                var internalModuleSourceToRanges = /* @__PURE__ */ new Map();
                if (supportsUserTimingV3) {
                  var ranges = getInternalModuleRanges();
                  if (ranges) {
                    for (var i = 0; i < ranges.length; i++) {
                      var range = ranges[i];
                      if (shared_isArray(range) && range.length === 2) {
                        var _ranges$i2 = profilingHooks_slicedToArray(ranges[i], 2), startStackFrame = _ranges$i2[0], stopStackFrame = _ranges$i2[1];
                        markAndClear("--react-internal-module-start-".concat(startStackFrame));
                        markAndClear("--react-internal-module-stop-".concat(stopStackFrame));
                      }
                    }
                  }
                }
                var laneToReactMeasureMap = /* @__PURE__ */ new Map();
                var lane = 1;
                for (var index = 0; index < REACT_TOTAL_NUM_LANES; index++) {
                  laneToReactMeasureMap.set(lane, []);
                  lane *= 2;
                }
                currentBatchUID = 0;
                currentReactComponentMeasure = null;
                currentReactMeasuresStack = [];
                currentFiberStacks = /* @__PURE__ */ new Map();
                currentTimelineData = {
                  // Session wide metadata; only collected once.
                  internalModuleSourceToRanges,
                  laneToLabelMap: laneToLabelMap || /* @__PURE__ */ new Map(),
                  reactVersion,
                  // Data logged by React during profiling session.
                  componentMeasures: [],
                  schedulingEvents: [],
                  suspenseEvents: [],
                  thrownErrors: [],
                  // Data inferred based on what React logs.
                  batchUIDToMeasuresMap: /* @__PURE__ */ new Map(),
                  duration: 0,
                  laneToReactMeasureMap,
                  startTime: 0,
                  // Data only available in Chrome profiles.
                  flamechart: [],
                  nativeEvents: [],
                  networkMeasures: [],
                  otherUserTimingMarks: [],
                  snapshots: [],
                  snapshotHeight: 0
                };
                nextRenderShouldStartNewBatch = true;
              } else {
                if (currentTimelineData !== null) {
                  currentTimelineData.schedulingEvents.forEach(function(event) {
                    if (event.type === "schedule-state-update") {
                      var fiberStack = currentFiberStacks.get(event);
                      if (fiberStack && currentDispatcherRef != null) {
                        event.componentStack = fiberStack.reduce(function(trace, fiber) {
                          return trace + describeFiber(workTagMap, fiber, currentDispatcherRef);
                        }, "");
                      }
                    }
                  });
                }
                currentFiberStacks.clear();
              }
            }
          }
          return {
            getTimelineData,
            profilingHooks: {
              markCommitStarted,
              markCommitStopped,
              markComponentRenderStarted,
              markComponentRenderStopped,
              markComponentPassiveEffectMountStarted,
              markComponentPassiveEffectMountStopped,
              markComponentPassiveEffectUnmountStarted,
              markComponentPassiveEffectUnmountStopped,
              markComponentLayoutEffectMountStarted,
              markComponentLayoutEffectMountStopped,
              markComponentLayoutEffectUnmountStarted,
              markComponentLayoutEffectUnmountStopped,
              markComponentErrored,
              markComponentSuspended,
              markLayoutEffectsStarted,
              markLayoutEffectsStopped,
              markPassiveEffectsStarted,
              markPassiveEffectsStopped,
              markRenderStarted,
              markRenderYielded,
              markRenderStopped,
              markRenderScheduled,
              markForceUpdateScheduled,
              markStateUpdateScheduled
            },
            toggleProfilingStatus
          };
        }
        ;
        function _objectWithoutProperties(source, excluded) {
          if (source == null)
            return {};
          var target = _objectWithoutPropertiesLoose(source, excluded);
          var key, i;
          if (Object.getOwnPropertySymbols) {
            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
            for (i = 0; i < sourceSymbolKeys.length; i++) {
              key = sourceSymbolKeys[i];
              if (excluded.indexOf(key) >= 0)
                continue;
              if (!Object.prototype.propertyIsEnumerable.call(source, key))
                continue;
              target[key] = source[key];
            }
          }
          return target;
        }
        function _objectWithoutPropertiesLoose(source, excluded) {
          if (source == null)
            return {};
          var target = {};
          var sourceKeys = Object.keys(source);
          var key, i;
          for (i = 0; i < sourceKeys.length; i++) {
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0)
              continue;
            target[key] = source[key];
          }
          return target;
        }
        function renderer_ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function renderer_objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              renderer_ownKeys(Object(source), true).forEach(function(key) {
                renderer_defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              renderer_ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function renderer_defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function renderer_slicedToArray(arr, i) {
          return renderer_arrayWithHoles(arr) || renderer_iterableToArrayLimit(arr, i) || renderer_unsupportedIterableToArray(arr, i) || renderer_nonIterableRest();
        }
        function renderer_nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function renderer_iterableToArrayLimit(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
            return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null)
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        function renderer_arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        function renderer_toConsumableArray(arr) {
          return renderer_arrayWithoutHoles(arr) || renderer_iterableToArray(arr) || renderer_unsupportedIterableToArray(arr) || renderer_nonIterableSpread();
        }
        function renderer_nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function renderer_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
            return Array.from(iter);
        }
        function renderer_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return renderer_arrayLikeToArray(arr);
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
          var it;
          if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
            if (Array.isArray(o) || (it = renderer_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it)
                o = it;
              var i = 0;
              var F = function F2() {
              };
              return { s: F, n: function n() {
                if (i >= o.length)
                  return { done: true };
                return { done: false, value: o[i++] };
              }, e: function e(_e2) {
                throw _e2;
              }, f: F };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true, didErr = false, err;
          return { s: function s() {
            it = o[Symbol.iterator]();
          }, n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          }, e: function e(_e3) {
            didErr = true;
            err = _e3;
          }, f: function f() {
            try {
              if (!normalCompletion && it.return != null)
                it.return();
            } finally {
              if (didErr)
                throw err;
            }
          } };
        }
        function renderer_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return renderer_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return renderer_arrayLikeToArray(o, minLen);
        }
        function renderer_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function renderer_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            renderer_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            renderer_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return renderer_typeof(obj);
        }
        function getFiberFlags(fiber) {
          return fiber.flags !== void 0 ? fiber.flags : fiber.effectTag;
        }
        var renderer_getCurrentTime = (
          // $FlowFixMe[method-unbinding]
          (typeof performance === "undefined" ? "undefined" : renderer_typeof(performance)) === "object" && typeof performance.now === "function" ? function() {
            return performance.now();
          } : function() {
            return Date.now();
          }
        );
        function getInternalReactConstants(version) {
          var ReactPriorityLevels = {
            ImmediatePriority: 99,
            UserBlockingPriority: 98,
            NormalPriority: 97,
            LowPriority: 96,
            IdlePriority: 95,
            NoPriority: 90
          };
          if (gt(version, "17.0.2")) {
            ReactPriorityLevels = {
              ImmediatePriority: 1,
              UserBlockingPriority: 2,
              NormalPriority: 3,
              LowPriority: 4,
              IdlePriority: 5,
              NoPriority: 0
            };
          }
          var StrictModeBits = 0;
          if (gte(version, "18.0.0-alpha")) {
            StrictModeBits = 24;
          } else if (gte(version, "16.9.0")) {
            StrictModeBits = 1;
          } else if (gte(version, "16.3.0")) {
            StrictModeBits = 2;
          }
          var ReactTypeOfWork = null;
          if (gt(version, "17.0.1")) {
            ReactTypeOfWork = {
              CacheComponent: 24,
              // Experimental
              ClassComponent: 1,
              ContextConsumer: 9,
              ContextProvider: 10,
              CoroutineComponent: -1,
              // Removed
              CoroutineHandlerPhase: -1,
              // Removed
              DehydratedSuspenseComponent: 18,
              // Behind a flag
              ForwardRef: 11,
              Fragment: 7,
              FunctionComponent: 0,
              HostComponent: 5,
              HostPortal: 4,
              HostRoot: 3,
              HostHoistable: 26,
              // In reality, 18.2+. But doesn't hurt to include it here
              HostSingleton: 27,
              // Same as above
              HostText: 6,
              IncompleteClassComponent: 17,
              IndeterminateComponent: 2,
              LazyComponent: 16,
              LegacyHiddenComponent: 23,
              MemoComponent: 14,
              Mode: 8,
              OffscreenComponent: 22,
              // Experimental
              Profiler: 12,
              ScopeComponent: 21,
              // Experimental
              SimpleMemoComponent: 15,
              SuspenseComponent: 13,
              SuspenseListComponent: 19,
              // Experimental
              TracingMarkerComponent: 25,
              // Experimental - This is technically in 18 but we don't
              // want to fork again so we're adding it here instead
              YieldComponent: -1
              // Removed
            };
          } else if (gte(version, "17.0.0-alpha")) {
            ReactTypeOfWork = {
              CacheComponent: -1,
              // Doesn't exist yet
              ClassComponent: 1,
              ContextConsumer: 9,
              ContextProvider: 10,
              CoroutineComponent: -1,
              // Removed
              CoroutineHandlerPhase: -1,
              // Removed
              DehydratedSuspenseComponent: 18,
              // Behind a flag
              ForwardRef: 11,
              Fragment: 7,
              FunctionComponent: 0,
              HostComponent: 5,
              HostPortal: 4,
              HostRoot: 3,
              HostHoistable: -1,
              // Doesn't exist yet
              HostSingleton: -1,
              // Doesn't exist yet
              HostText: 6,
              IncompleteClassComponent: 17,
              IndeterminateComponent: 2,
              LazyComponent: 16,
              LegacyHiddenComponent: 24,
              MemoComponent: 14,
              Mode: 8,
              OffscreenComponent: 23,
              // Experimental
              Profiler: 12,
              ScopeComponent: 21,
              // Experimental
              SimpleMemoComponent: 15,
              SuspenseComponent: 13,
              SuspenseListComponent: 19,
              // Experimental
              TracingMarkerComponent: -1,
              // Doesn't exist yet
              YieldComponent: -1
              // Removed
            };
          } else if (gte(version, "16.6.0-beta.0")) {
            ReactTypeOfWork = {
              CacheComponent: -1,
              // Doesn't exist yet
              ClassComponent: 1,
              ContextConsumer: 9,
              ContextProvider: 10,
              CoroutineComponent: -1,
              // Removed
              CoroutineHandlerPhase: -1,
              // Removed
              DehydratedSuspenseComponent: 18,
              // Behind a flag
              ForwardRef: 11,
              Fragment: 7,
              FunctionComponent: 0,
              HostComponent: 5,
              HostPortal: 4,
              HostRoot: 3,
              HostHoistable: -1,
              // Doesn't exist yet
              HostSingleton: -1,
              // Doesn't exist yet
              HostText: 6,
              IncompleteClassComponent: 17,
              IndeterminateComponent: 2,
              LazyComponent: 16,
              LegacyHiddenComponent: -1,
              MemoComponent: 14,
              Mode: 8,
              OffscreenComponent: -1,
              // Experimental
              Profiler: 12,
              ScopeComponent: -1,
              // Experimental
              SimpleMemoComponent: 15,
              SuspenseComponent: 13,
              SuspenseListComponent: 19,
              // Experimental
              TracingMarkerComponent: -1,
              // Doesn't exist yet
              YieldComponent: -1
              // Removed
            };
          } else if (gte(version, "16.4.3-alpha")) {
            ReactTypeOfWork = {
              CacheComponent: -1,
              // Doesn't exist yet
              ClassComponent: 2,
              ContextConsumer: 11,
              ContextProvider: 12,
              CoroutineComponent: -1,
              // Removed
              CoroutineHandlerPhase: -1,
              // Removed
              DehydratedSuspenseComponent: -1,
              // Doesn't exist yet
              ForwardRef: 13,
              Fragment: 9,
              FunctionComponent: 0,
              HostComponent: 7,
              HostPortal: 6,
              HostRoot: 5,
              HostHoistable: -1,
              // Doesn't exist yet
              HostSingleton: -1,
              // Doesn't exist yet
              HostText: 8,
              IncompleteClassComponent: -1,
              // Doesn't exist yet
              IndeterminateComponent: 4,
              LazyComponent: -1,
              // Doesn't exist yet
              LegacyHiddenComponent: -1,
              MemoComponent: -1,
              // Doesn't exist yet
              Mode: 10,
              OffscreenComponent: -1,
              // Experimental
              Profiler: 15,
              ScopeComponent: -1,
              // Experimental
              SimpleMemoComponent: -1,
              // Doesn't exist yet
              SuspenseComponent: 16,
              SuspenseListComponent: -1,
              // Doesn't exist yet
              TracingMarkerComponent: -1,
              // Doesn't exist yet
              YieldComponent: -1
              // Removed
            };
          } else {
            ReactTypeOfWork = {
              CacheComponent: -1,
              // Doesn't exist yet
              ClassComponent: 2,
              ContextConsumer: 12,
              ContextProvider: 13,
              CoroutineComponent: 7,
              CoroutineHandlerPhase: 8,
              DehydratedSuspenseComponent: -1,
              // Doesn't exist yet
              ForwardRef: 14,
              Fragment: 10,
              FunctionComponent: 1,
              HostComponent: 5,
              HostPortal: 4,
              HostRoot: 3,
              HostHoistable: -1,
              // Doesn't exist yet
              HostSingleton: -1,
              // Doesn't exist yet
              HostText: 6,
              IncompleteClassComponent: -1,
              // Doesn't exist yet
              IndeterminateComponent: 0,
              LazyComponent: -1,
              // Doesn't exist yet
              LegacyHiddenComponent: -1,
              MemoComponent: -1,
              // Doesn't exist yet
              Mode: 11,
              OffscreenComponent: -1,
              // Experimental
              Profiler: 15,
              ScopeComponent: -1,
              // Experimental
              SimpleMemoComponent: -1,
              // Doesn't exist yet
              SuspenseComponent: 16,
              SuspenseListComponent: -1,
              // Doesn't exist yet
              TracingMarkerComponent: -1,
              // Doesn't exist yet
              YieldComponent: 9
            };
          }
          function getTypeSymbol(type) {
            var symbolOrNumber = renderer_typeof(type) === "object" && type !== null ? type.$$typeof : type;
            return renderer_typeof(symbolOrNumber) === "symbol" ? (
              // $FlowFixMe[incompatible-return] `toString()` doesn't match the type signature?
              symbolOrNumber.toString()
            ) : symbolOrNumber;
          }
          var _ReactTypeOfWork = ReactTypeOfWork, CacheComponent = _ReactTypeOfWork.CacheComponent, ClassComponent = _ReactTypeOfWork.ClassComponent, IncompleteClassComponent = _ReactTypeOfWork.IncompleteClassComponent, FunctionComponent = _ReactTypeOfWork.FunctionComponent, IndeterminateComponent = _ReactTypeOfWork.IndeterminateComponent, ForwardRef = _ReactTypeOfWork.ForwardRef, HostRoot = _ReactTypeOfWork.HostRoot, HostHoistable = _ReactTypeOfWork.HostHoistable, HostSingleton = _ReactTypeOfWork.HostSingleton, HostComponent = _ReactTypeOfWork.HostComponent, HostPortal = _ReactTypeOfWork.HostPortal, HostText = _ReactTypeOfWork.HostText, Fragment = _ReactTypeOfWork.Fragment, LazyComponent = _ReactTypeOfWork.LazyComponent, LegacyHiddenComponent = _ReactTypeOfWork.LegacyHiddenComponent, MemoComponent = _ReactTypeOfWork.MemoComponent, OffscreenComponent = _ReactTypeOfWork.OffscreenComponent, Profiler = _ReactTypeOfWork.Profiler, ScopeComponent = _ReactTypeOfWork.ScopeComponent, SimpleMemoComponent = _ReactTypeOfWork.SimpleMemoComponent, SuspenseComponent = _ReactTypeOfWork.SuspenseComponent, SuspenseListComponent = _ReactTypeOfWork.SuspenseListComponent, TracingMarkerComponent = _ReactTypeOfWork.TracingMarkerComponent;
          function resolveFiberType(type) {
            var typeSymbol = getTypeSymbol(type);
            switch (typeSymbol) {
              case ReactSymbols_MEMO_NUMBER:
              case ReactSymbols_MEMO_SYMBOL_STRING:
                return resolveFiberType(type.type);
              case ReactSymbols_FORWARD_REF_NUMBER:
              case ReactSymbols_FORWARD_REF_SYMBOL_STRING:
                return type.render;
              default:
                return type;
            }
          }
          function getDisplayNameForFiber(fiber) {
            var elementType = fiber.elementType, type = fiber.type, tag = fiber.tag;
            var resolvedType = type;
            if (renderer_typeof(type) === "object" && type !== null) {
              resolvedType = resolveFiberType(type);
            }
            var resolvedContext = null;
            switch (tag) {
              case CacheComponent:
                return "Cache";
              case ClassComponent:
              case IncompleteClassComponent:
                return getDisplayName(resolvedType);
              case FunctionComponent:
              case IndeterminateComponent:
                return getDisplayName(resolvedType);
              case ForwardRef:
                return getWrappedDisplayName(elementType, resolvedType, "ForwardRef", "Anonymous");
              case HostRoot:
                var fiberRoot = fiber.stateNode;
                if (fiberRoot != null && fiberRoot._debugRootType !== null) {
                  return fiberRoot._debugRootType;
                }
                return null;
              case HostComponent:
              case HostSingleton:
              case HostHoistable:
                return type;
              case HostPortal:
              case HostText:
                return null;
              case Fragment:
                return "Fragment";
              case LazyComponent:
                return "Lazy";
              case MemoComponent:
              case SimpleMemoComponent:
                return getWrappedDisplayName(elementType, resolvedType, "Memo", "Anonymous");
              case SuspenseComponent:
                return "Suspense";
              case LegacyHiddenComponent:
                return "LegacyHidden";
              case OffscreenComponent:
                return "Offscreen";
              case ScopeComponent:
                return "Scope";
              case SuspenseListComponent:
                return "SuspenseList";
              case Profiler:
                return "Profiler";
              case TracingMarkerComponent:
                return "TracingMarker";
              default:
                var typeSymbol = getTypeSymbol(type);
                switch (typeSymbol) {
                  case CONCURRENT_MODE_NUMBER:
                  case CONCURRENT_MODE_SYMBOL_STRING:
                  case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
                    return null;
                  case PROVIDER_NUMBER:
                  case PROVIDER_SYMBOL_STRING:
                    resolvedContext = fiber.type._context || fiber.type.context;
                    return "".concat(resolvedContext.displayName || "Context", ".Provider");
                  case CONTEXT_NUMBER:
                  case CONTEXT_SYMBOL_STRING:
                  case SERVER_CONTEXT_SYMBOL_STRING:
                    resolvedContext = fiber.type._context || fiber.type;
                    return "".concat(resolvedContext.displayName || "Context", ".Consumer");
                  case STRICT_MODE_NUMBER:
                  case STRICT_MODE_SYMBOL_STRING:
                    return null;
                  case PROFILER_NUMBER:
                  case PROFILER_SYMBOL_STRING:
                    return "Profiler(".concat(fiber.memoizedProps.id, ")");
                  case SCOPE_NUMBER:
                  case SCOPE_SYMBOL_STRING:
                    return "Scope";
                  default:
                    return null;
                }
            }
          }
          return {
            getDisplayNameForFiber,
            getTypeSymbol,
            ReactPriorityLevels,
            ReactTypeOfWork,
            StrictModeBits
          };
        }
        var fiberToIDMap = /* @__PURE__ */ new Map();
        var idToArbitraryFiberMap = /* @__PURE__ */ new Map();
        function attach(hook2, rendererID, renderer, global2) {
          var version = renderer.reconcilerVersion || renderer.version;
          var _getInternalReactCons = getInternalReactConstants(version), getDisplayNameForFiber = _getInternalReactCons.getDisplayNameForFiber, getTypeSymbol = _getInternalReactCons.getTypeSymbol, ReactPriorityLevels = _getInternalReactCons.ReactPriorityLevels, ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork, StrictModeBits = _getInternalReactCons.StrictModeBits;
          var CacheComponent = ReactTypeOfWork.CacheComponent, ClassComponent = ReactTypeOfWork.ClassComponent, ContextConsumer = ReactTypeOfWork.ContextConsumer, DehydratedSuspenseComponent = ReactTypeOfWork.DehydratedSuspenseComponent, ForwardRef = ReactTypeOfWork.ForwardRef, Fragment = ReactTypeOfWork.Fragment, FunctionComponent = ReactTypeOfWork.FunctionComponent, HostRoot = ReactTypeOfWork.HostRoot, HostHoistable = ReactTypeOfWork.HostHoistable, HostSingleton = ReactTypeOfWork.HostSingleton, HostPortal = ReactTypeOfWork.HostPortal, HostComponent = ReactTypeOfWork.HostComponent, HostText = ReactTypeOfWork.HostText, IncompleteClassComponent = ReactTypeOfWork.IncompleteClassComponent, IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent, LegacyHiddenComponent = ReactTypeOfWork.LegacyHiddenComponent, MemoComponent = ReactTypeOfWork.MemoComponent, OffscreenComponent = ReactTypeOfWork.OffscreenComponent, SimpleMemoComponent = ReactTypeOfWork.SimpleMemoComponent, SuspenseComponent = ReactTypeOfWork.SuspenseComponent, SuspenseListComponent = ReactTypeOfWork.SuspenseListComponent, TracingMarkerComponent = ReactTypeOfWork.TracingMarkerComponent;
          var ImmediatePriority = ReactPriorityLevels.ImmediatePriority, UserBlockingPriority = ReactPriorityLevels.UserBlockingPriority, NormalPriority = ReactPriorityLevels.NormalPriority, LowPriority = ReactPriorityLevels.LowPriority, IdlePriority = ReactPriorityLevels.IdlePriority, NoPriority = ReactPriorityLevels.NoPriority;
          var getLaneLabelMap = renderer.getLaneLabelMap, injectProfilingHooks = renderer.injectProfilingHooks, overrideHookState = renderer.overrideHookState, overrideHookStateDeletePath = renderer.overrideHookStateDeletePath, overrideHookStateRenamePath = renderer.overrideHookStateRenamePath, overrideProps = renderer.overrideProps, overridePropsDeletePath = renderer.overridePropsDeletePath, overridePropsRenamePath = renderer.overridePropsRenamePath, scheduleRefresh = renderer.scheduleRefresh, setErrorHandler = renderer.setErrorHandler, setSuspenseHandler = renderer.setSuspenseHandler, scheduleUpdate = renderer.scheduleUpdate;
          var supportsTogglingError = typeof setErrorHandler === "function" && typeof scheduleUpdate === "function";
          var supportsTogglingSuspense = typeof setSuspenseHandler === "function" && typeof scheduleUpdate === "function";
          if (typeof scheduleRefresh === "function") {
            renderer.scheduleRefresh = function() {
              try {
                hook2.emit("fastRefreshScheduled");
              } finally {
                return scheduleRefresh.apply(void 0, arguments);
              }
            };
          }
          var getTimelineData = null;
          var toggleProfilingStatus = null;
          if (typeof injectProfilingHooks === "function") {
            var response = createProfilingHooks({
              getDisplayNameForFiber,
              getIsProfiling: function getIsProfiling() {
                return isProfiling;
              },
              getLaneLabelMap,
              currentDispatcherRef: renderer.currentDispatcherRef,
              workTagMap: ReactTypeOfWork,
              reactVersion: version
            });
            injectProfilingHooks(response.profilingHooks);
            getTimelineData = response.getTimelineData;
            toggleProfilingStatus = response.toggleProfilingStatus;
          }
          var fibersWithChangedErrorOrWarningCounts = /* @__PURE__ */ new Set();
          var pendingFiberToErrorsMap = /* @__PURE__ */ new Map();
          var pendingFiberToWarningsMap = /* @__PURE__ */ new Map();
          var fiberIDToErrorsMap = /* @__PURE__ */ new Map();
          var fiberIDToWarningsMap = /* @__PURE__ */ new Map();
          function clearErrorsAndWarnings() {
            var _iterator = _createForOfIteratorHelper(fiberIDToErrorsMap.keys()), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var id = _step.value;
                var _fiber = idToArbitraryFiberMap.get(id);
                if (_fiber != null) {
                  fibersWithChangedErrorOrWarningCounts.add(_fiber);
                  updateMostRecentlyInspectedElementIfNecessary(id);
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            var _iterator2 = _createForOfIteratorHelper(fiberIDToWarningsMap.keys()), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var _id = _step2.value;
                var _fiber2 = idToArbitraryFiberMap.get(_id);
                if (_fiber2 != null) {
                  fibersWithChangedErrorOrWarningCounts.add(_fiber2);
                  updateMostRecentlyInspectedElementIfNecessary(_id);
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            fiberIDToErrorsMap.clear();
            fiberIDToWarningsMap.clear();
            flushPendingEvents();
          }
          function clearMessageCountHelper(fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {
            var fiber = idToArbitraryFiberMap.get(fiberID);
            if (fiber != null) {
              pendingFiberToErrorsMap.delete(fiber);
              if (fiberIDToMessageCountMap.has(fiberID)) {
                fiberIDToMessageCountMap.delete(fiberID);
                fibersWithChangedErrorOrWarningCounts.add(fiber);
                flushPendingEvents();
                updateMostRecentlyInspectedElementIfNecessary(fiberID);
              } else {
                fibersWithChangedErrorOrWarningCounts.delete(fiber);
              }
            }
          }
          function clearErrorsForFiberID(fiberID) {
            clearMessageCountHelper(fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);
          }
          function clearWarningsForFiberID(fiberID) {
            clearMessageCountHelper(fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);
          }
          function updateMostRecentlyInspectedElementIfNecessary(fiberID) {
            if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === fiberID) {
              hasElementUpdatedSinceLastInspected = true;
            }
          }
          function onErrorOrWarning(fiber, type, args) {
            if (type === "error") {
              var maybeID = getFiberIDUnsafe(fiber);
              if (maybeID != null && forceErrorForFiberIDs.get(maybeID) === true) {
                return;
              }
            }
            var message = format.apply(void 0, renderer_toConsumableArray(args));
            if (__DEBUG__) {
              debug2("onErrorOrWarning", fiber, null, "".concat(type, ': "').concat(message, '"'));
            }
            fibersWithChangedErrorOrWarningCounts.add(fiber);
            var fiberMap = type === "error" ? pendingFiberToErrorsMap : pendingFiberToWarningsMap;
            var messageMap = fiberMap.get(fiber);
            if (messageMap != null) {
              var count = messageMap.get(message) || 0;
              messageMap.set(message, count + 1);
            } else {
              fiberMap.set(fiber, /* @__PURE__ */ new Map([[message, 1]]));
            }
            flushPendingErrorsAndWarningsAfterDelay();
          }
          registerRenderer(renderer, onErrorOrWarning);
          patchConsoleUsingWindowValues();
          var debug2 = function debug3(name, fiber, parentFiber) {
            var extraString = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
            if (__DEBUG__) {
              var displayName = fiber.tag + ":" + (getDisplayNameForFiber(fiber) || "null");
              var maybeID = getFiberIDUnsafe(fiber) || "<no id>";
              var parentDisplayName = parentFiber ? parentFiber.tag + ":" + (getDisplayNameForFiber(parentFiber) || "null") : "";
              var maybeParentID = parentFiber ? getFiberIDUnsafe(parentFiber) || "<no-id>" : "";
              console.groupCollapsed("[renderer] %c".concat(name, " %c").concat(displayName, " (").concat(maybeID, ") %c").concat(parentFiber ? "".concat(parentDisplayName, " (").concat(maybeParentID, ")") : "", " %c").concat(extraString), "color: red; font-weight: bold;", "color: blue;", "color: purple;", "color: black;");
              console.log(new Error().stack.split("\n").slice(1).join("\n"));
              console.groupEnd();
            }
          };
          var hideElementsWithDisplayNames = /* @__PURE__ */ new Set();
          var hideElementsWithPaths = /* @__PURE__ */ new Set();
          var hideElementsWithTypes = /* @__PURE__ */ new Set();
          var traceUpdatesEnabled = false;
          var traceUpdatesForNodes = /* @__PURE__ */ new Set();
          function applyComponentFilters(componentFilters) {
            hideElementsWithTypes.clear();
            hideElementsWithDisplayNames.clear();
            hideElementsWithPaths.clear();
            componentFilters.forEach(function(componentFilter) {
              if (!componentFilter.isEnabled) {
                return;
              }
              switch (componentFilter.type) {
                case ComponentFilterDisplayName:
                  if (componentFilter.isValid && componentFilter.value !== "") {
                    hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, "i"));
                  }
                  break;
                case ComponentFilterElementType:
                  hideElementsWithTypes.add(componentFilter.value);
                  break;
                case ComponentFilterLocation:
                  if (componentFilter.isValid && componentFilter.value !== "") {
                    hideElementsWithPaths.add(new RegExp(componentFilter.value, "i"));
                  }
                  break;
                case ComponentFilterHOC:
                  hideElementsWithDisplayNames.add(new RegExp("\\("));
                  break;
                default:
                  console.warn('Invalid component filter type "'.concat(componentFilter.type, '"'));
                  break;
              }
            });
          }
          if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {
            applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);
          } else {
            applyComponentFilters(getDefaultComponentFilters());
          }
          function updateComponentFilters(componentFilters) {
            if (isProfiling) {
              throw Error("Cannot modify filter preferences while profiling");
            }
            hook2.getFiberRoots(rendererID).forEach(function(root) {
              currentRootID = getOrGenerateFiberID(root.current);
              pushOperation(TREE_OPERATION_REMOVE_ROOT);
              flushPendingEvents(root);
              currentRootID = -1;
            });
            applyComponentFilters(componentFilters);
            rootDisplayNameCounter.clear();
            hook2.getFiberRoots(rendererID).forEach(function(root) {
              currentRootID = getOrGenerateFiberID(root.current);
              setRootPseudoKey(currentRootID, root.current);
              mountFiberRecursively(root.current, null, false, false);
              flushPendingEvents(root);
              currentRootID = -1;
            });
            reevaluateErrorsAndWarnings();
            flushPendingEvents();
          }
          function shouldFilterFiber(fiber) {
            var _debugSource = fiber._debugSource, tag = fiber.tag, type = fiber.type, key = fiber.key;
            switch (tag) {
              case DehydratedSuspenseComponent:
                return true;
              case HostPortal:
              case HostText:
              case LegacyHiddenComponent:
              case OffscreenComponent:
                return true;
              case HostRoot:
                return false;
              case Fragment:
                return key === null;
              default:
                var typeSymbol = getTypeSymbol(type);
                switch (typeSymbol) {
                  case CONCURRENT_MODE_NUMBER:
                  case CONCURRENT_MODE_SYMBOL_STRING:
                  case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
                  case STRICT_MODE_NUMBER:
                  case STRICT_MODE_SYMBOL_STRING:
                    return true;
                  default:
                    break;
                }
            }
            var elementType = getElementTypeForFiber(fiber);
            if (hideElementsWithTypes.has(elementType)) {
              return true;
            }
            if (hideElementsWithDisplayNames.size > 0) {
              var displayName = getDisplayNameForFiber(fiber);
              if (displayName != null) {
                var _iterator3 = _createForOfIteratorHelper(hideElementsWithDisplayNames), _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                    var displayNameRegExp = _step3.value;
                    if (displayNameRegExp.test(displayName)) {
                      return true;
                    }
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              }
            }
            if (_debugSource != null && hideElementsWithPaths.size > 0) {
              var fileName = _debugSource.fileName;
              var _iterator4 = _createForOfIteratorHelper(hideElementsWithPaths), _step4;
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                  var pathRegExp = _step4.value;
                  if (pathRegExp.test(fileName)) {
                    return true;
                  }
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
            }
            return false;
          }
          function getElementTypeForFiber(fiber) {
            var type = fiber.type, tag = fiber.tag;
            switch (tag) {
              case ClassComponent:
              case IncompleteClassComponent:
                return types_ElementTypeClass;
              case FunctionComponent:
              case IndeterminateComponent:
                return types_ElementTypeFunction;
              case ForwardRef:
                return types_ElementTypeForwardRef;
              case HostRoot:
                return ElementTypeRoot;
              case HostComponent:
              case HostHoistable:
              case HostSingleton:
                return ElementTypeHostComponent;
              case HostPortal:
              case HostText:
              case Fragment:
                return ElementTypeOtherOrUnknown;
              case MemoComponent:
              case SimpleMemoComponent:
                return types_ElementTypeMemo;
              case SuspenseComponent:
                return ElementTypeSuspense;
              case SuspenseListComponent:
                return ElementTypeSuspenseList;
              case TracingMarkerComponent:
                return ElementTypeTracingMarker;
              default:
                var typeSymbol = getTypeSymbol(type);
                switch (typeSymbol) {
                  case CONCURRENT_MODE_NUMBER:
                  case CONCURRENT_MODE_SYMBOL_STRING:
                  case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
                    return ElementTypeOtherOrUnknown;
                  case PROVIDER_NUMBER:
                  case PROVIDER_SYMBOL_STRING:
                    return ElementTypeContext;
                  case CONTEXT_NUMBER:
                  case CONTEXT_SYMBOL_STRING:
                    return ElementTypeContext;
                  case STRICT_MODE_NUMBER:
                  case STRICT_MODE_SYMBOL_STRING:
                    return ElementTypeOtherOrUnknown;
                  case PROFILER_NUMBER:
                  case PROFILER_SYMBOL_STRING:
                    return ElementTypeProfiler;
                  default:
                    return ElementTypeOtherOrUnknown;
                }
            }
          }
          var idToTreeBaseDurationMap = /* @__PURE__ */ new Map();
          var idToRootMap = /* @__PURE__ */ new Map();
          var currentRootID = -1;
          function getOrGenerateFiberID(fiber) {
            var id = null;
            if (fiberToIDMap.has(fiber)) {
              id = fiberToIDMap.get(fiber);
            } else {
              var _alternate = fiber.alternate;
              if (_alternate !== null && fiberToIDMap.has(_alternate)) {
                id = fiberToIDMap.get(_alternate);
              }
            }
            var didGenerateID = false;
            if (id === null) {
              didGenerateID = true;
              id = getUID();
            }
            var refinedID = id;
            if (!fiberToIDMap.has(fiber)) {
              fiberToIDMap.set(fiber, refinedID);
              idToArbitraryFiberMap.set(refinedID, fiber);
            }
            var alternate = fiber.alternate;
            if (alternate !== null) {
              if (!fiberToIDMap.has(alternate)) {
                fiberToIDMap.set(alternate, refinedID);
              }
            }
            if (__DEBUG__) {
              if (didGenerateID) {
                debug2("getOrGenerateFiberID()", fiber, fiber.return, "Generated a new UID");
              }
            }
            return refinedID;
          }
          function getFiberIDThrows(fiber) {
            var maybeID = getFiberIDUnsafe(fiber);
            if (maybeID !== null) {
              return maybeID;
            }
            throw Error('Could not find ID for Fiber "'.concat(getDisplayNameForFiber(fiber) || "", '"'));
          }
          function getFiberIDUnsafe(fiber) {
            if (fiberToIDMap.has(fiber)) {
              return fiberToIDMap.get(fiber);
            } else {
              var alternate = fiber.alternate;
              if (alternate !== null && fiberToIDMap.has(alternate)) {
                return fiberToIDMap.get(alternate);
              }
            }
            return null;
          }
          function untrackFiberID(fiber) {
            if (__DEBUG__) {
              debug2("untrackFiberID()", fiber, fiber.return, "schedule after delay");
            }
            untrackFibersSet.add(fiber);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              untrackFibersSet.add(alternate);
            }
            if (untrackFibersTimeoutID === null) {
              untrackFibersTimeoutID = setTimeout(untrackFibers, 1e3);
            }
          }
          var untrackFibersSet = /* @__PURE__ */ new Set();
          var untrackFibersTimeoutID = null;
          function untrackFibers() {
            if (untrackFibersTimeoutID !== null) {
              clearTimeout(untrackFibersTimeoutID);
              untrackFibersTimeoutID = null;
            }
            untrackFibersSet.forEach(function(fiber) {
              var fiberID = getFiberIDUnsafe(fiber);
              if (fiberID !== null) {
                idToArbitraryFiberMap.delete(fiberID);
                clearErrorsForFiberID(fiberID);
                clearWarningsForFiberID(fiberID);
              }
              fiberToIDMap.delete(fiber);
              var alternate = fiber.alternate;
              if (alternate !== null) {
                fiberToIDMap.delete(alternate);
              }
              if (forceErrorForFiberIDs.has(fiberID)) {
                forceErrorForFiberIDs.delete(fiberID);
                if (forceErrorForFiberIDs.size === 0 && setErrorHandler != null) {
                  setErrorHandler(shouldErrorFiberAlwaysNull);
                }
              }
            });
            untrackFibersSet.clear();
          }
          function getChangeDescription(prevFiber, nextFiber) {
            switch (getElementTypeForFiber(nextFiber)) {
              case types_ElementTypeClass:
              case types_ElementTypeFunction:
              case types_ElementTypeMemo:
              case types_ElementTypeForwardRef:
                if (prevFiber === null) {
                  return {
                    context: null,
                    didHooksChange: false,
                    isFirstMount: true,
                    props: null,
                    state: null
                  };
                } else {
                  var data = {
                    context: getContextChangedKeys(nextFiber),
                    didHooksChange: false,
                    isFirstMount: false,
                    props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),
                    state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)
                  };
                  var indices = getChangedHooksIndices(prevFiber.memoizedState, nextFiber.memoizedState);
                  data.hooks = indices;
                  data.didHooksChange = indices !== null && indices.length > 0;
                  return data;
                }
              default:
                return null;
            }
          }
          function updateContextsForFiber(fiber) {
            switch (getElementTypeForFiber(fiber)) {
              case types_ElementTypeClass:
              case types_ElementTypeForwardRef:
              case types_ElementTypeFunction:
              case types_ElementTypeMemo:
                if (idToContextsMap !== null) {
                  var id = getFiberIDThrows(fiber);
                  var contexts = getContextsForFiber(fiber);
                  if (contexts !== null) {
                    idToContextsMap.set(id, contexts);
                  }
                }
                break;
              default:
                break;
            }
          }
          var NO_CONTEXT = {};
          function getContextsForFiber(fiber) {
            var legacyContext = NO_CONTEXT;
            var modernContext = NO_CONTEXT;
            switch (getElementTypeForFiber(fiber)) {
              case types_ElementTypeClass:
                var instance = fiber.stateNode;
                if (instance != null) {
                  if (instance.constructor && instance.constructor.contextType != null) {
                    modernContext = instance.context;
                  } else {
                    legacyContext = instance.context;
                    if (legacyContext && Object.keys(legacyContext).length === 0) {
                      legacyContext = NO_CONTEXT;
                    }
                  }
                }
                return [legacyContext, modernContext];
              case types_ElementTypeForwardRef:
              case types_ElementTypeFunction:
              case types_ElementTypeMemo:
                var dependencies = fiber.dependencies;
                if (dependencies && dependencies.firstContext) {
                  modernContext = dependencies.firstContext;
                }
                return [legacyContext, modernContext];
              default:
                return null;
            }
          }
          function crawlToInitializeContextsMap(fiber) {
            var id = getFiberIDUnsafe(fiber);
            if (id !== null) {
              updateContextsForFiber(fiber);
              var current = fiber.child;
              while (current !== null) {
                crawlToInitializeContextsMap(current);
                current = current.sibling;
              }
            }
          }
          function getContextChangedKeys(fiber) {
            if (idToContextsMap !== null) {
              var id = getFiberIDThrows(fiber);
              var prevContexts = idToContextsMap.has(id) ? (
                // $FlowFixMe[incompatible-use] found when upgrading Flow
                idToContextsMap.get(id)
              ) : null;
              var nextContexts = getContextsForFiber(fiber);
              if (prevContexts == null || nextContexts == null) {
                return null;
              }
              var _prevContexts = renderer_slicedToArray(prevContexts, 2), prevLegacyContext = _prevContexts[0], prevModernContext = _prevContexts[1];
              var _nextContexts = renderer_slicedToArray(nextContexts, 2), nextLegacyContext = _nextContexts[0], nextModernContext = _nextContexts[1];
              switch (getElementTypeForFiber(fiber)) {
                case types_ElementTypeClass:
                  if (prevContexts && nextContexts) {
                    if (nextLegacyContext !== NO_CONTEXT) {
                      return getChangedKeys(prevLegacyContext, nextLegacyContext);
                    } else if (nextModernContext !== NO_CONTEXT) {
                      return prevModernContext !== nextModernContext;
                    }
                  }
                  break;
                case types_ElementTypeForwardRef:
                case types_ElementTypeFunction:
                case types_ElementTypeMemo:
                  if (nextModernContext !== NO_CONTEXT) {
                    var prevContext = prevModernContext;
                    var nextContext = nextModernContext;
                    while (prevContext && nextContext) {
                      if (!shared_objectIs(prevContext.memoizedValue, nextContext.memoizedValue)) {
                        return true;
                      }
                      prevContext = prevContext.next;
                      nextContext = nextContext.next;
                    }
                    return false;
                  }
                  break;
                default:
                  break;
              }
            }
            return null;
          }
          function isHookThatCanScheduleUpdate(hookObject) {
            var queue = hookObject.queue;
            if (!queue) {
              return false;
            }
            var boundHasOwnProperty = shared_hasOwnProperty.bind(queue);
            if (boundHasOwnProperty("pending")) {
              return true;
            }
            return boundHasOwnProperty("value") && boundHasOwnProperty("getSnapshot") && typeof queue.getSnapshot === "function";
          }
          function didStatefulHookChange(prev, next) {
            var prevMemoizedState = prev.memoizedState;
            var nextMemoizedState = next.memoizedState;
            if (isHookThatCanScheduleUpdate(prev)) {
              return prevMemoizedState !== nextMemoizedState;
            }
            return false;
          }
          function getChangedHooksIndices(prev, next) {
            if (prev == null || next == null) {
              return null;
            }
            var indices = [];
            var index = 0;
            if (next.hasOwnProperty("baseState") && next.hasOwnProperty("memoizedState") && next.hasOwnProperty("next") && next.hasOwnProperty("queue")) {
              while (next !== null) {
                if (didStatefulHookChange(prev, next)) {
                  indices.push(index);
                }
                next = next.next;
                prev = prev.next;
                index++;
              }
            }
            return indices;
          }
          function getChangedKeys(prev, next) {
            if (prev == null || next == null) {
              return null;
            }
            if (next.hasOwnProperty("baseState") && next.hasOwnProperty("memoizedState") && next.hasOwnProperty("next") && next.hasOwnProperty("queue")) {
              return null;
            }
            var keys = new Set([].concat(renderer_toConsumableArray(Object.keys(prev)), renderer_toConsumableArray(Object.keys(next))));
            var changedKeys = [];
            var _iterator5 = _createForOfIteratorHelper(keys), _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                var key = _step5.value;
                if (prev[key] !== next[key]) {
                  changedKeys.push(key);
                }
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
            return changedKeys;
          }
          function didFiberRender(prevFiber, nextFiber) {
            switch (nextFiber.tag) {
              case ClassComponent:
              case FunctionComponent:
              case ContextConsumer:
              case MemoComponent:
              case SimpleMemoComponent:
              case ForwardRef:
                var PerformedWork = 1;
                return (getFiberFlags(nextFiber) & PerformedWork) === PerformedWork;
              default:
                return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;
            }
          }
          var pendingOperations = [];
          var pendingRealUnmountedIDs = [];
          var pendingSimulatedUnmountedIDs = [];
          var pendingOperationsQueue = [];
          var pendingStringTable = /* @__PURE__ */ new Map();
          var pendingStringTableLength = 0;
          var pendingUnmountedRootID = null;
          function pushOperation(op) {
            if (false) {
            }
            pendingOperations.push(op);
          }
          function shouldBailoutWithPendingOperations() {
            if (isProfiling) {
              if (currentCommitProfilingMetadata != null && currentCommitProfilingMetadata.durations.length > 0) {
                return false;
              }
            }
            return pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingSimulatedUnmountedIDs.length === 0 && pendingUnmountedRootID === null;
          }
          function flushOrQueueOperations(operations) {
            if (shouldBailoutWithPendingOperations()) {
              return;
            }
            if (pendingOperationsQueue !== null) {
              pendingOperationsQueue.push(operations);
            } else {
              hook2.emit("operations", operations);
            }
          }
          var flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;
          function clearPendingErrorsAndWarningsAfterDelay() {
            if (flushPendingErrorsAndWarningsAfterDelayTimeoutID !== null) {
              clearTimeout(flushPendingErrorsAndWarningsAfterDelayTimeoutID);
              flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;
            }
          }
          function flushPendingErrorsAndWarningsAfterDelay() {
            clearPendingErrorsAndWarningsAfterDelay();
            flushPendingErrorsAndWarningsAfterDelayTimeoutID = setTimeout(function() {
              flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;
              if (pendingOperations.length > 0) {
                return;
              }
              recordPendingErrorsAndWarnings();
              if (shouldBailoutWithPendingOperations()) {
                return;
              }
              var operations = new Array(3 + pendingOperations.length);
              operations[0] = rendererID;
              operations[1] = currentRootID;
              operations[2] = 0;
              for (var j = 0; j < pendingOperations.length; j++) {
                operations[3 + j] = pendingOperations[j];
              }
              flushOrQueueOperations(operations);
              pendingOperations.length = 0;
            }, 1e3);
          }
          function reevaluateErrorsAndWarnings() {
            fibersWithChangedErrorOrWarningCounts.clear();
            fiberIDToErrorsMap.forEach(function(countMap, fiberID) {
              var fiber = idToArbitraryFiberMap.get(fiberID);
              if (fiber != null) {
                fibersWithChangedErrorOrWarningCounts.add(fiber);
              }
            });
            fiberIDToWarningsMap.forEach(function(countMap, fiberID) {
              var fiber = idToArbitraryFiberMap.get(fiberID);
              if (fiber != null) {
                fibersWithChangedErrorOrWarningCounts.add(fiber);
              }
            });
            recordPendingErrorsAndWarnings();
          }
          function mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {
            var newCount = 0;
            var messageCountMap = fiberIDToMessageCountMap.get(fiberID);
            var pendingMessageCountMap = pendingFiberToMessageCountMap.get(fiber);
            if (pendingMessageCountMap != null) {
              if (messageCountMap == null) {
                messageCountMap = pendingMessageCountMap;
                fiberIDToMessageCountMap.set(fiberID, pendingMessageCountMap);
              } else {
                var refinedMessageCountMap = messageCountMap;
                pendingMessageCountMap.forEach(function(pendingCount, message) {
                  var previousCount = refinedMessageCountMap.get(message) || 0;
                  refinedMessageCountMap.set(message, previousCount + pendingCount);
                });
              }
            }
            if (!shouldFilterFiber(fiber)) {
              if (messageCountMap != null) {
                messageCountMap.forEach(function(count) {
                  newCount += count;
                });
              }
            }
            pendingFiberToMessageCountMap.delete(fiber);
            return newCount;
          }
          function recordPendingErrorsAndWarnings() {
            clearPendingErrorsAndWarningsAfterDelay();
            fibersWithChangedErrorOrWarningCounts.forEach(function(fiber) {
              var fiberID = getFiberIDUnsafe(fiber);
              if (fiberID === null) {
              } else {
                var errorCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);
                var warningCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);
                pushOperation(TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS);
                pushOperation(fiberID);
                pushOperation(errorCount);
                pushOperation(warningCount);
              }
              pendingFiberToErrorsMap.delete(fiber);
              pendingFiberToWarningsMap.delete(fiber);
            });
            fibersWithChangedErrorOrWarningCounts.clear();
          }
          function flushPendingEvents(root) {
            recordPendingErrorsAndWarnings();
            if (shouldBailoutWithPendingOperations()) {
              return;
            }
            var numUnmountIDs = pendingRealUnmountedIDs.length + pendingSimulatedUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
            var operations = new Array(
              // Identify which renderer this update is coming from.
              2 + // [rendererID, rootFiberID]
              // How big is the string table?
              1 + // [stringTableLength]
              // Then goes the actual string table.
              pendingStringTableLength + // All unmounts are batched in a single message.
              // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
              (numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Regular operations
              pendingOperations.length
            );
            var i = 0;
            operations[i++] = rendererID;
            operations[i++] = currentRootID;
            operations[i++] = pendingStringTableLength;
            pendingStringTable.forEach(function(entry, stringKey) {
              var encodedString = entry.encodedString;
              var length = encodedString.length;
              operations[i++] = length;
              for (var j2 = 0; j2 < length; j2++) {
                operations[i + j2] = encodedString[j2];
              }
              i += length;
            });
            if (numUnmountIDs > 0) {
              operations[i++] = TREE_OPERATION_REMOVE;
              operations[i++] = numUnmountIDs;
              for (var j = pendingRealUnmountedIDs.length - 1; j >= 0; j--) {
                operations[i++] = pendingRealUnmountedIDs[j];
              }
              for (var _j = 0; _j < pendingSimulatedUnmountedIDs.length; _j++) {
                operations[i + _j] = pendingSimulatedUnmountedIDs[_j];
              }
              i += pendingSimulatedUnmountedIDs.length;
              if (pendingUnmountedRootID !== null) {
                operations[i] = pendingUnmountedRootID;
                i++;
              }
            }
            for (var _j2 = 0; _j2 < pendingOperations.length; _j2++) {
              operations[i + _j2] = pendingOperations[_j2];
            }
            i += pendingOperations.length;
            flushOrQueueOperations(operations);
            pendingOperations.length = 0;
            pendingRealUnmountedIDs.length = 0;
            pendingSimulatedUnmountedIDs.length = 0;
            pendingUnmountedRootID = null;
            pendingStringTable.clear();
            pendingStringTableLength = 0;
          }
          function getStringID(string) {
            if (string === null) {
              return 0;
            }
            var existingEntry = pendingStringTable.get(string);
            if (existingEntry !== void 0) {
              return existingEntry.id;
            }
            var id = pendingStringTable.size + 1;
            var encodedString = utfEncodeString(string);
            pendingStringTable.set(string, {
              encodedString,
              id
            });
            pendingStringTableLength += encodedString.length + 1;
            return id;
          }
          function recordMount(fiber, parentFiber) {
            var isRoot = fiber.tag === HostRoot;
            var id = getOrGenerateFiberID(fiber);
            if (__DEBUG__) {
              debug2("recordMount()", fiber, parentFiber);
            }
            var hasOwnerMetadata = fiber.hasOwnProperty("_debugOwner");
            var isProfilingSupported = fiber.hasOwnProperty("treeBaseDuration");
            var profilingFlags = 0;
            if (isProfilingSupported) {
              profilingFlags = PROFILING_FLAG_BASIC_SUPPORT;
              if (typeof injectProfilingHooks === "function") {
                profilingFlags |= PROFILING_FLAG_TIMELINE_SUPPORT;
              }
            }
            if (isRoot) {
              pushOperation(TREE_OPERATION_ADD);
              pushOperation(id);
              pushOperation(ElementTypeRoot);
              pushOperation((fiber.mode & StrictModeBits) !== 0 ? 1 : 0);
              pushOperation(profilingFlags);
              pushOperation(StrictModeBits !== 0 ? 1 : 0);
              pushOperation(hasOwnerMetadata ? 1 : 0);
              if (isProfiling) {
                if (displayNamesByRootID !== null) {
                  displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));
                }
              }
            } else {
              var key = fiber.key;
              var displayName = getDisplayNameForFiber(fiber);
              var elementType = getElementTypeForFiber(fiber);
              var _debugOwner = fiber._debugOwner;
              var ownerID = _debugOwner != null ? getOrGenerateFiberID(_debugOwner) : 0;
              var parentID = parentFiber ? getFiberIDThrows(parentFiber) : 0;
              var displayNameStringID = getStringID(displayName);
              var keyString = key === null ? null : String(key);
              var keyStringID = getStringID(keyString);
              pushOperation(TREE_OPERATION_ADD);
              pushOperation(id);
              pushOperation(elementType);
              pushOperation(parentID);
              pushOperation(ownerID);
              pushOperation(displayNameStringID);
              pushOperation(keyStringID);
              if ((fiber.mode & StrictModeBits) !== 0 && (parentFiber.mode & StrictModeBits) === 0) {
                pushOperation(TREE_OPERATION_SET_SUBTREE_MODE);
                pushOperation(id);
                pushOperation(StrictMode);
              }
            }
            if (isProfilingSupported) {
              idToRootMap.set(id, currentRootID);
              recordProfilingDurations(fiber);
            }
          }
          function recordUnmount(fiber, isSimulated) {
            if (__DEBUG__) {
              debug2("recordUnmount()", fiber, null, isSimulated ? "unmount is simulated" : "");
            }
            if (trackedPathMatchFiber !== null) {
              if (fiber === trackedPathMatchFiber || fiber === trackedPathMatchFiber.alternate) {
                setTrackedPath(null);
              }
            }
            var unsafeID = getFiberIDUnsafe(fiber);
            if (unsafeID === null) {
              return;
            }
            var id = unsafeID;
            var isRoot = fiber.tag === HostRoot;
            if (isRoot) {
              pendingUnmountedRootID = id;
            } else if (!shouldFilterFiber(fiber)) {
              if (isSimulated) {
                pendingSimulatedUnmountedIDs.push(id);
              } else {
                pendingRealUnmountedIDs.push(id);
              }
            }
            if (!fiber._debugNeedsRemount) {
              untrackFiberID(fiber);
              var isProfilingSupported = fiber.hasOwnProperty("treeBaseDuration");
              if (isProfilingSupported) {
                idToRootMap.delete(id);
                idToTreeBaseDurationMap.delete(id);
              }
            }
          }
          function mountFiberRecursively(firstChild, parentFiber, traverseSiblings, traceNearestHostComponentUpdate) {
            var fiber = firstChild;
            while (fiber !== null) {
              getOrGenerateFiberID(fiber);
              if (__DEBUG__) {
                debug2("mountFiberRecursively()", fiber, parentFiber);
              }
              var mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber);
              var shouldIncludeInTree = !shouldFilterFiber(fiber);
              if (shouldIncludeInTree) {
                recordMount(fiber, parentFiber);
              }
              if (traceUpdatesEnabled) {
                if (traceNearestHostComponentUpdate) {
                  var elementType = getElementTypeForFiber(fiber);
                  if (elementType === ElementTypeHostComponent) {
                    traceUpdatesForNodes.add(fiber.stateNode);
                    traceNearestHostComponentUpdate = false;
                  }
                }
              }
              var isSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent;
              if (isSuspense) {
                var isTimedOut = fiber.memoizedState !== null;
                if (isTimedOut) {
                  var primaryChildFragment = fiber.child;
                  var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
                  var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;
                  if (fallbackChild !== null) {
                    mountFiberRecursively(fallbackChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
                  }
                } else {
                  var primaryChild = null;
                  var areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -1;
                  if (areSuspenseChildrenConditionallyWrapped) {
                    primaryChild = fiber.child;
                  } else if (fiber.child !== null) {
                    primaryChild = fiber.child.child;
                  }
                  if (primaryChild !== null) {
                    mountFiberRecursively(primaryChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
                  }
                }
              } else {
                if (fiber.child !== null) {
                  mountFiberRecursively(fiber.child, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
                }
              }
              updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);
              fiber = traverseSiblings ? fiber.sibling : null;
            }
          }
          function unmountFiberChildrenRecursively(fiber) {
            if (__DEBUG__) {
              debug2("unmountFiberChildrenRecursively()", fiber);
            }
            var isTimedOutSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent && fiber.memoizedState !== null;
            var child = fiber.child;
            if (isTimedOutSuspense) {
              var primaryChildFragment = fiber.child;
              var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
              child = fallbackChildFragment ? fallbackChildFragment.child : null;
            }
            while (child !== null) {
              if (child.return !== null) {
                unmountFiberChildrenRecursively(child);
                recordUnmount(child, true);
              }
              child = child.sibling;
            }
          }
          function recordProfilingDurations(fiber) {
            var id = getFiberIDThrows(fiber);
            var actualDuration = fiber.actualDuration, treeBaseDuration = fiber.treeBaseDuration;
            idToTreeBaseDurationMap.set(id, treeBaseDuration || 0);
            if (isProfiling) {
              var alternate = fiber.alternate;
              if (alternate == null || treeBaseDuration !== alternate.treeBaseDuration) {
                var convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1e3);
                pushOperation(TREE_OPERATION_UPDATE_TREE_BASE_DURATION);
                pushOperation(id);
                pushOperation(convertedTreeBaseDuration);
              }
              if (alternate == null || didFiberRender(alternate, fiber)) {
                if (actualDuration != null) {
                  var selfDuration = actualDuration;
                  var child = fiber.child;
                  while (child !== null) {
                    selfDuration -= child.actualDuration || 0;
                    child = child.sibling;
                  }
                  var metadata = currentCommitProfilingMetadata;
                  metadata.durations.push(id, actualDuration, selfDuration);
                  metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);
                  if (recordChangeDescriptions) {
                    var changeDescription = getChangeDescription(alternate, fiber);
                    if (changeDescription !== null) {
                      if (metadata.changeDescriptions !== null) {
                        metadata.changeDescriptions.set(id, changeDescription);
                      }
                    }
                    updateContextsForFiber(fiber);
                  }
                }
              }
            }
          }
          function recordResetChildren(fiber, childSet) {
            if (__DEBUG__) {
              debug2("recordResetChildren()", childSet, fiber);
            }
            var nextChildren = [];
            var child = childSet;
            while (child !== null) {
              findReorderedChildrenRecursively(child, nextChildren);
              child = child.sibling;
            }
            var numChildren = nextChildren.length;
            if (numChildren < 2) {
              return;
            }
            pushOperation(TREE_OPERATION_REORDER_CHILDREN);
            pushOperation(getFiberIDThrows(fiber));
            pushOperation(numChildren);
            for (var i = 0; i < nextChildren.length; i++) {
              pushOperation(nextChildren[i]);
            }
          }
          function findReorderedChildrenRecursively(fiber, nextChildren) {
            if (!shouldFilterFiber(fiber)) {
              nextChildren.push(getFiberIDThrows(fiber));
            } else {
              var child = fiber.child;
              var isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;
              if (isTimedOutSuspense) {
                var primaryChildFragment = fiber.child;
                var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
                var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;
                if (fallbackChild !== null) {
                  child = fallbackChild;
                }
              }
              while (child !== null) {
                findReorderedChildrenRecursively(child, nextChildren);
                child = child.sibling;
              }
            }
          }
          function updateFiberRecursively(nextFiber, prevFiber, parentFiber, traceNearestHostComponentUpdate) {
            var id = getOrGenerateFiberID(nextFiber);
            if (__DEBUG__) {
              debug2("updateFiberRecursively()", nextFiber, parentFiber);
            }
            if (traceUpdatesEnabled) {
              var elementType = getElementTypeForFiber(nextFiber);
              if (traceNearestHostComponentUpdate) {
                if (elementType === ElementTypeHostComponent) {
                  traceUpdatesForNodes.add(nextFiber.stateNode);
                  traceNearestHostComponentUpdate = false;
                }
              } else {
                if (elementType === types_ElementTypeFunction || elementType === types_ElementTypeClass || elementType === ElementTypeContext || elementType === types_ElementTypeMemo || elementType === types_ElementTypeForwardRef) {
                  traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);
                }
              }
            }
            if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id && didFiberRender(prevFiber, nextFiber)) {
              hasElementUpdatedSinceLastInspected = true;
            }
            var shouldIncludeInTree = !shouldFilterFiber(nextFiber);
            var isSuspense = nextFiber.tag === SuspenseComponent;
            var shouldResetChildren = false;
            var prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;
            var nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null;
            if (prevDidTimeout && nextDidTimeOut) {
              var nextFiberChild = nextFiber.child;
              var nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null;
              var prevFiberChild = prevFiber.child;
              var prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;
              if (prevFallbackChildSet == null && nextFallbackChildSet != null) {
                mountFiberRecursively(nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
                shouldResetChildren = true;
              }
              if (nextFallbackChildSet != null && prevFallbackChildSet != null && updateFiberRecursively(nextFallbackChildSet, prevFallbackChildSet, nextFiber, traceNearestHostComponentUpdate)) {
                shouldResetChildren = true;
              }
            } else if (prevDidTimeout && !nextDidTimeOut) {
              var nextPrimaryChildSet = nextFiber.child;
              if (nextPrimaryChildSet !== null) {
                mountFiberRecursively(nextPrimaryChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
              }
              shouldResetChildren = true;
            } else if (!prevDidTimeout && nextDidTimeOut) {
              unmountFiberChildrenRecursively(prevFiber);
              var _nextFiberChild = nextFiber.child;
              var _nextFallbackChildSet = _nextFiberChild ? _nextFiberChild.sibling : null;
              if (_nextFallbackChildSet != null) {
                mountFiberRecursively(_nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
                shouldResetChildren = true;
              }
            } else {
              if (nextFiber.child !== prevFiber.child) {
                var nextChild = nextFiber.child;
                var prevChildAtSameIndex = prevFiber.child;
                while (nextChild) {
                  if (nextChild.alternate) {
                    var prevChild = nextChild.alternate;
                    if (updateFiberRecursively(nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber, traceNearestHostComponentUpdate)) {
                      shouldResetChildren = true;
                    }
                    if (prevChild !== prevChildAtSameIndex) {
                      shouldResetChildren = true;
                    }
                  } else {
                    mountFiberRecursively(nextChild, shouldIncludeInTree ? nextFiber : parentFiber, false, traceNearestHostComponentUpdate);
                    shouldResetChildren = true;
                  }
                  nextChild = nextChild.sibling;
                  if (!shouldResetChildren && prevChildAtSameIndex !== null) {
                    prevChildAtSameIndex = prevChildAtSameIndex.sibling;
                  }
                }
                if (prevChildAtSameIndex !== null) {
                  shouldResetChildren = true;
                }
              } else {
                if (traceUpdatesEnabled) {
                  if (traceNearestHostComponentUpdate) {
                    var hostFibers = findAllCurrentHostFibers(getFiberIDThrows(nextFiber));
                    hostFibers.forEach(function(hostFiber) {
                      traceUpdatesForNodes.add(hostFiber.stateNode);
                    });
                  }
                }
              }
            }
            if (shouldIncludeInTree) {
              var isProfilingSupported = nextFiber.hasOwnProperty("treeBaseDuration");
              if (isProfilingSupported) {
                recordProfilingDurations(nextFiber);
              }
            }
            if (shouldResetChildren) {
              if (shouldIncludeInTree) {
                var nextChildSet = nextFiber.child;
                if (nextDidTimeOut) {
                  var _nextFiberChild2 = nextFiber.child;
                  nextChildSet = _nextFiberChild2 ? _nextFiberChild2.sibling : null;
                }
                if (nextChildSet != null) {
                  recordResetChildren(nextFiber, nextChildSet);
                }
                return false;
              } else {
                return true;
              }
            } else {
              return false;
            }
          }
          function cleanup() {
          }
          function rootSupportsProfiling(root) {
            if (root.memoizedInteractions != null) {
              return true;
            } else if (root.current != null && root.current.hasOwnProperty("treeBaseDuration")) {
              return true;
            } else {
              return false;
            }
          }
          function flushInitialOperations() {
            var localPendingOperationsQueue = pendingOperationsQueue;
            pendingOperationsQueue = null;
            if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {
              localPendingOperationsQueue.forEach(function(operations) {
                hook2.emit("operations", operations);
              });
            } else {
              if (trackedPath !== null) {
                mightBeOnTrackedPath = true;
              }
              hook2.getFiberRoots(rendererID).forEach(function(root) {
                currentRootID = getOrGenerateFiberID(root.current);
                setRootPseudoKey(currentRootID, root.current);
                if (isProfiling && rootSupportsProfiling(root)) {
                  currentCommitProfilingMetadata = {
                    changeDescriptions: recordChangeDescriptions ? /* @__PURE__ */ new Map() : null,
                    durations: [],
                    commitTime: renderer_getCurrentTime() - profilingStartTime,
                    maxActualDuration: 0,
                    priorityLevel: null,
                    updaters: getUpdatersList(root),
                    effectDuration: null,
                    passiveEffectDuration: null
                  };
                }
                mountFiberRecursively(root.current, null, false, false);
                flushPendingEvents(root);
                currentRootID = -1;
              });
            }
          }
          function getUpdatersList(root) {
            return root.memoizedUpdaters != null ? Array.from(root.memoizedUpdaters).filter(function(fiber) {
              return getFiberIDUnsafe(fiber) !== null;
            }).map(fiberToSerializedElement) : null;
          }
          function handleCommitFiberUnmount(fiber) {
            if (!untrackFibersSet.has(fiber)) {
              recordUnmount(fiber, false);
            }
          }
          function handlePostCommitFiberRoot(root) {
            if (isProfiling && rootSupportsProfiling(root)) {
              if (currentCommitProfilingMetadata !== null) {
                var _getEffectDurations = getEffectDurations(root), effectDuration = _getEffectDurations.effectDuration, passiveEffectDuration = _getEffectDurations.passiveEffectDuration;
                currentCommitProfilingMetadata.effectDuration = effectDuration;
                currentCommitProfilingMetadata.passiveEffectDuration = passiveEffectDuration;
              }
            }
          }
          function handleCommitFiberRoot(root, priorityLevel) {
            var current = root.current;
            var alternate = current.alternate;
            untrackFibers();
            currentRootID = getOrGenerateFiberID(current);
            if (trackedPath !== null) {
              mightBeOnTrackedPath = true;
            }
            if (traceUpdatesEnabled) {
              traceUpdatesForNodes.clear();
            }
            var isProfilingSupported = rootSupportsProfiling(root);
            if (isProfiling && isProfilingSupported) {
              currentCommitProfilingMetadata = {
                changeDescriptions: recordChangeDescriptions ? /* @__PURE__ */ new Map() : null,
                durations: [],
                commitTime: renderer_getCurrentTime() - profilingStartTime,
                maxActualDuration: 0,
                priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel),
                updaters: getUpdatersList(root),
                // Initialize to null; if new enough React version is running,
                // these values will be read during separate handlePostCommitFiberRoot() call.
                effectDuration: null,
                passiveEffectDuration: null
              };
            }
            if (alternate) {
              var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && // A dehydrated root is not considered mounted
              alternate.memoizedState.isDehydrated !== true;
              var isMounted = current.memoizedState != null && current.memoizedState.element != null && // A dehydrated root is not considered mounted
              current.memoizedState.isDehydrated !== true;
              if (!wasMounted && isMounted) {
                setRootPseudoKey(currentRootID, current);
                mountFiberRecursively(current, null, false, false);
              } else if (wasMounted && isMounted) {
                updateFiberRecursively(current, alternate, null, false);
              } else if (wasMounted && !isMounted) {
                removeRootPseudoKey(currentRootID);
                recordUnmount(current, false);
              }
            } else {
              setRootPseudoKey(currentRootID, current);
              mountFiberRecursively(current, null, false, false);
            }
            if (isProfiling && isProfilingSupported) {
              if (!shouldBailoutWithPendingOperations()) {
                var commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRootID);
                if (commitProfilingMetadata != null) {
                  commitProfilingMetadata.push(currentCommitProfilingMetadata);
                } else {
                  rootToCommitProfilingMetadataMap.set(currentRootID, [currentCommitProfilingMetadata]);
                }
              }
            }
            flushPendingEvents(root);
            if (traceUpdatesEnabled) {
              hook2.emit("traceUpdates", traceUpdatesForNodes);
            }
            currentRootID = -1;
          }
          function findAllCurrentHostFibers(id) {
            var fibers = [];
            var fiber = findCurrentFiberUsingSlowPathById(id);
            if (!fiber) {
              return fibers;
            }
            var node = fiber;
            while (true) {
              if (node.tag === HostComponent || node.tag === HostText) {
                fibers.push(node);
              } else if (node.child) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === fiber) {
                return fibers;
              }
              while (!node.sibling) {
                if (!node.return || node.return === fiber) {
                  return fibers;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return fibers;
          }
          function findNativeNodesForFiberID(id) {
            try {
              var _fiber3 = findCurrentFiberUsingSlowPathById(id);
              if (_fiber3 === null) {
                return null;
              }
              var hostFibers = findAllCurrentHostFibers(id);
              return hostFibers.map(function(hostFiber) {
                return hostFiber.stateNode;
              }).filter(Boolean);
            } catch (err) {
              return null;
            }
          }
          function getDisplayNameForFiberID(id) {
            var fiber = idToArbitraryFiberMap.get(id);
            return fiber != null ? getDisplayNameForFiber(fiber) : null;
          }
          function getFiberForNative(hostInstance) {
            return renderer.findFiberByHostInstance(hostInstance);
          }
          function getFiberIDForNative(hostInstance) {
            var findNearestUnfilteredAncestor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var fiber = renderer.findFiberByHostInstance(hostInstance);
            if (fiber != null) {
              if (findNearestUnfilteredAncestor) {
                while (fiber !== null && shouldFilterFiber(fiber)) {
                  fiber = fiber.return;
                }
              }
              return getFiberIDThrows(fiber);
            }
            return null;
          }
          function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
              throw new Error("Unable to find node on an unmounted component.");
            }
          }
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                var Placement = 2;
                var Hydrating = 4096;
                if ((node.flags & (Placement | Hydrating)) !== 0) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function findCurrentFiberUsingSlowPathById(id) {
            var fiber = idToArbitraryFiberMap.get(id);
            if (fiber == null) {
              console.warn('Could not find Fiber with id "'.concat(id, '"'));
              return null;
            }
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (nearestMounted === null) {
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a = fiber;
            var b = alternate;
            while (true) {
              var parentA = a.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a = b = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (a.return !== b.return) {
                a = parentA;
                b = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentA;
                    b = parentB;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentA;
                    a = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentB;
                      b = parentA;
                      break;
                    }
                    if (_child === b) {
                      didFindChild = true;
                      b = parentB;
                      a = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
              if (a.alternate !== b) {
                throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (a.tag !== HostRoot) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a.stateNode.current === a) {
              return fiber;
            }
            return alternate;
          }
          function prepareViewAttributeSource(id, path) {
            if (isMostRecentlyInspectedElement(id)) {
              window.$attribute = utils_getInObject(mostRecentlyInspectedElement, path);
            }
          }
          function prepareViewElementSource(id) {
            var fiber = idToArbitraryFiberMap.get(id);
            if (fiber == null) {
              console.warn('Could not find Fiber with id "'.concat(id, '"'));
              return;
            }
            var elementType = fiber.elementType, tag = fiber.tag, type = fiber.type;
            switch (tag) {
              case ClassComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
              case FunctionComponent:
                global2.$type = type;
                break;
              case ForwardRef:
                global2.$type = type.render;
                break;
              case MemoComponent:
              case SimpleMemoComponent:
                global2.$type = elementType != null && elementType.type != null ? elementType.type : type;
                break;
              default:
                global2.$type = null;
                break;
            }
          }
          function fiberToSerializedElement(fiber) {
            return {
              displayName: getDisplayNameForFiber(fiber) || "Anonymous",
              id: getFiberIDThrows(fiber),
              key: fiber.key,
              type: getElementTypeForFiber(fiber)
            };
          }
          function getOwnersList(id) {
            var fiber = findCurrentFiberUsingSlowPathById(id);
            if (fiber == null) {
              return null;
            }
            var _debugOwner = fiber._debugOwner;
            var owners = [fiberToSerializedElement(fiber)];
            if (_debugOwner) {
              var owner = _debugOwner;
              while (owner !== null) {
                owners.unshift(fiberToSerializedElement(owner));
                owner = owner._debugOwner || null;
              }
            }
            return owners;
          }
          function getInstanceAndStyle(id) {
            var instance = null;
            var style = null;
            var fiber = findCurrentFiberUsingSlowPathById(id);
            if (fiber !== null) {
              instance = fiber.stateNode;
              if (fiber.memoizedProps !== null) {
                style = fiber.memoizedProps.style;
              }
            }
            return {
              instance,
              style
            };
          }
          function isErrorBoundary(fiber) {
            var tag = fiber.tag, type = fiber.type;
            switch (tag) {
              case ClassComponent:
              case IncompleteClassComponent:
                var instance = fiber.stateNode;
                return typeof type.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function";
              default:
                return false;
            }
          }
          function getNearestErrorBoundaryID(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isErrorBoundary(parent)) {
                return getFiberIDUnsafe(parent);
              }
              parent = parent.return;
            }
            return null;
          }
          function inspectElementRaw(id) {
            var fiber = findCurrentFiberUsingSlowPathById(id);
            if (fiber == null) {
              return null;
            }
            var _debugOwner = fiber._debugOwner, _debugSource = fiber._debugSource, stateNode = fiber.stateNode, key = fiber.key, memoizedProps = fiber.memoizedProps, memoizedState = fiber.memoizedState, dependencies = fiber.dependencies, tag = fiber.tag, type = fiber.type;
            var elementType = getElementTypeForFiber(fiber);
            var usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies);
            var showState = !usesHooks && tag !== CacheComponent;
            var typeSymbol = getTypeSymbol(type);
            var canViewSource = false;
            var context = null;
            if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {
              canViewSource = true;
              if (stateNode && stateNode.context != null) {
                var shouldHideContext = elementType === types_ElementTypeClass && !(type.contextTypes || type.contextType);
                if (!shouldHideContext) {
                  context = stateNode.context;
                }
              }
            } else if (typeSymbol === CONTEXT_NUMBER || typeSymbol === CONTEXT_SYMBOL_STRING) {
              var consumerResolvedContext = type._context || type;
              context = consumerResolvedContext._currentValue || null;
              var _current = fiber.return;
              while (_current !== null) {
                var currentType = _current.type;
                var currentTypeSymbol = getTypeSymbol(currentType);
                if (currentTypeSymbol === PROVIDER_NUMBER || currentTypeSymbol === PROVIDER_SYMBOL_STRING) {
                  var providerResolvedContext = currentType._context || currentType.context;
                  if (providerResolvedContext === consumerResolvedContext) {
                    context = _current.memoizedProps.value;
                    break;
                  }
                }
                _current = _current.return;
              }
            }
            var hasLegacyContext = false;
            if (context !== null) {
              hasLegacyContext = !!type.contextTypes;
              context = {
                value: context
              };
            }
            var owners = null;
            if (_debugOwner) {
              owners = [];
              var owner = _debugOwner;
              while (owner !== null) {
                owners.push(fiberToSerializedElement(owner));
                owner = owner._debugOwner || null;
              }
            }
            var isTimedOutSuspense = tag === SuspenseComponent && memoizedState !== null;
            var hooks = null;
            if (usesHooks) {
              var originalConsoleMethods = {};
              for (var method2 in console) {
                try {
                  originalConsoleMethods[method2] = console[method2];
                  console[method2] = function() {
                  };
                } catch (error) {
                }
              }
              try {
                hooks = (0, react_debug_tools.inspectHooksOfFiber)(
                  fiber,
                  renderer.currentDispatcherRef,
                  true
                  // Include source location info for hooks
                );
              } finally {
                for (var _method in originalConsoleMethods) {
                  try {
                    console[_method] = originalConsoleMethods[_method];
                  } catch (error) {
                  }
                }
              }
            }
            var rootType = null;
            var current = fiber;
            while (current.return !== null) {
              current = current.return;
            }
            var fiberRoot = current.stateNode;
            if (fiberRoot != null && fiberRoot._debugRootType !== null) {
              rootType = fiberRoot._debugRootType;
            }
            var errors = fiberIDToErrorsMap.get(id) || /* @__PURE__ */ new Map();
            var warnings = fiberIDToWarningsMap.get(id) || /* @__PURE__ */ new Map();
            var isErrored = false;
            var targetErrorBoundaryID;
            if (isErrorBoundary(fiber)) {
              var DidCapture = 128;
              isErrored = (fiber.flags & DidCapture) !== 0 || forceErrorForFiberIDs.get(id) === true;
              targetErrorBoundaryID = isErrored ? id : getNearestErrorBoundaryID(fiber);
            } else {
              targetErrorBoundaryID = getNearestErrorBoundaryID(fiber);
            }
            var plugins = {
              stylex: null
            };
            if (enableStyleXFeatures) {
              if (memoizedProps != null && memoizedProps.hasOwnProperty("xstyle")) {
                plugins.stylex = getStyleXData(memoizedProps.xstyle);
              }
            }
            return {
              id,
              // Does the current renderer support editable hooks and function props?
              canEditHooks: typeof overrideHookState === "function",
              canEditFunctionProps: typeof overrideProps === "function",
              // Does the current renderer support advanced editing interface?
              canEditHooksAndDeletePaths: typeof overrideHookStateDeletePath === "function",
              canEditHooksAndRenamePaths: typeof overrideHookStateRenamePath === "function",
              canEditFunctionPropsDeletePaths: typeof overridePropsDeletePath === "function",
              canEditFunctionPropsRenamePaths: typeof overridePropsRenamePath === "function",
              canToggleError: supportsTogglingError && targetErrorBoundaryID != null,
              // Is this error boundary in error state.
              isErrored,
              targetErrorBoundaryID,
              canToggleSuspense: supportsTogglingSuspense && // If it's showing the real content, we can always flip fallback.
              (!isTimedOutSuspense || // If it's showing fallback because we previously forced it to,
              // allow toggling it back to remove the fallback override.
              forceFallbackForSuspenseIDs.has(id)),
              // Can view component source location.
              canViewSource,
              // Does the component have legacy context attached to it.
              hasLegacyContext,
              key: key != null ? key : null,
              displayName: getDisplayNameForFiber(fiber),
              type: elementType,
              // Inspectable properties.
              // TODO Review sanitization approach for the below inspectable values.
              context,
              hooks,
              props: memoizedProps,
              state: showState ? memoizedState : null,
              errors: Array.from(errors.entries()),
              warnings: Array.from(warnings.entries()),
              // List of owners
              owners,
              // Location of component in source code.
              source: _debugSource || null,
              rootType,
              rendererPackageName: renderer.rendererPackageName,
              rendererVersion: renderer.version,
              plugins
            };
          }
          var mostRecentlyInspectedElement = null;
          var hasElementUpdatedSinceLastInspected = false;
          var currentlyInspectedPaths = {};
          function isMostRecentlyInspectedElement(id) {
            return mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id;
          }
          function isMostRecentlyInspectedElementCurrent(id) {
            return isMostRecentlyInspectedElement(id) && !hasElementUpdatedSinceLastInspected;
          }
          function mergeInspectedPaths(path) {
            var current = currentlyInspectedPaths;
            path.forEach(function(key) {
              if (!current[key]) {
                current[key] = {};
              }
              current = current[key];
            });
          }
          function createIsPathAllowed(key, secondaryCategory) {
            return function isPathAllowed(path) {
              switch (secondaryCategory) {
                case "hooks":
                  if (path.length === 1) {
                    return true;
                  }
                  if (path[path.length - 2] === "hookSource" && path[path.length - 1] === "fileName") {
                    return true;
                  }
                  if (path[path.length - 1] === "subHooks" || path[path.length - 2] === "subHooks") {
                    return true;
                  }
                  break;
                default:
                  break;
              }
              var current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];
              if (!current) {
                return false;
              }
              for (var i = 0; i < path.length; i++) {
                current = current[path[i]];
                if (!current) {
                  return false;
                }
              }
              return true;
            };
          }
          function updateSelectedElement(inspectedElement) {
            var hooks = inspectedElement.hooks, id = inspectedElement.id, props = inspectedElement.props;
            var fiber = idToArbitraryFiberMap.get(id);
            if (fiber == null) {
              console.warn('Could not find Fiber with id "'.concat(id, '"'));
              return;
            }
            var elementType = fiber.elementType, stateNode = fiber.stateNode, tag = fiber.tag, type = fiber.type;
            switch (tag) {
              case ClassComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
                global2.$r = stateNode;
                break;
              case FunctionComponent:
                global2.$r = {
                  hooks,
                  props,
                  type
                };
                break;
              case ForwardRef:
                global2.$r = {
                  hooks,
                  props,
                  type: type.render
                };
                break;
              case MemoComponent:
              case SimpleMemoComponent:
                global2.$r = {
                  hooks,
                  props,
                  type: elementType != null && elementType.type != null ? elementType.type : type
                };
                break;
              default:
                global2.$r = null;
                break;
            }
          }
          function storeAsGlobal(id, path, count) {
            if (isMostRecentlyInspectedElement(id)) {
              var value = utils_getInObject(mostRecentlyInspectedElement, path);
              var key = "$reactTemp".concat(count);
              window[key] = value;
              console.log(key);
              console.log(value);
            }
          }
          function getSerializedElementValueByPath(id, path) {
            if (isMostRecentlyInspectedElement(id)) {
              var valueToCopy = utils_getInObject(mostRecentlyInspectedElement, path);
              return serializeToString(valueToCopy);
            }
          }
          function inspectElement(requestID, id, path, forceFullData) {
            if (path !== null) {
              mergeInspectedPaths(path);
            }
            if (isMostRecentlyInspectedElement(id) && !forceFullData) {
              if (!hasElementUpdatedSinceLastInspected) {
                if (path !== null) {
                  var secondaryCategory = null;
                  if (path[0] === "hooks") {
                    secondaryCategory = "hooks";
                  }
                  return {
                    id,
                    responseID: requestID,
                    type: "hydrated-path",
                    path,
                    value: cleanForBridge(utils_getInObject(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)
                  };
                } else {
                  return {
                    id,
                    responseID: requestID,
                    type: "no-change"
                  };
                }
              }
            } else {
              currentlyInspectedPaths = {};
            }
            hasElementUpdatedSinceLastInspected = false;
            try {
              mostRecentlyInspectedElement = inspectElementRaw(id);
            } catch (error) {
              if (error.name === "ReactDebugToolsRenderError") {
                var message = "Error rendering inspected element.";
                var stack;
                console.error(message + "\n\n", error);
                if (error.cause != null) {
                  var _fiber4 = findCurrentFiberUsingSlowPathById(id);
                  var componentName = _fiber4 != null ? getDisplayNameForFiber(_fiber4) : null;
                  console.error("React DevTools encountered an error while trying to inspect hooks. This is most likely caused by an error in current inspected component" + (componentName != null ? ': "'.concat(componentName, '".') : ".") + "\nThe error thrown in the component is: \n\n", error.cause);
                  if (error.cause instanceof Error) {
                    message = error.cause.message || message;
                    stack = error.cause.stack;
                  }
                }
                return {
                  type: "error",
                  errorType: "user",
                  id,
                  responseID: requestID,
                  message,
                  stack
                };
              }
              if (error.name === "ReactDebugToolsUnsupportedHookError") {
                return {
                  type: "error",
                  errorType: "unknown-hook",
                  id,
                  responseID: requestID,
                  message: "Unsupported hook in the react-debug-tools package: " + error.message
                };
              }
              console.error("Error inspecting element.\n\n", error);
              return {
                type: "error",
                errorType: "uncaught",
                id,
                responseID: requestID,
                message: error.message,
                stack: error.stack
              };
            }
            if (mostRecentlyInspectedElement === null) {
              return {
                id,
                responseID: requestID,
                type: "not-found"
              };
            }
            updateSelectedElement(mostRecentlyInspectedElement);
            var cleanedInspectedElement = renderer_objectSpread({}, mostRecentlyInspectedElement);
            cleanedInspectedElement.context = cleanForBridge(cleanedInspectedElement.context, createIsPathAllowed("context", null));
            cleanedInspectedElement.hooks = cleanForBridge(cleanedInspectedElement.hooks, createIsPathAllowed("hooks", "hooks"));
            cleanedInspectedElement.props = cleanForBridge(cleanedInspectedElement.props, createIsPathAllowed("props", null));
            cleanedInspectedElement.state = cleanForBridge(cleanedInspectedElement.state, createIsPathAllowed("state", null));
            return {
              id,
              responseID: requestID,
              type: "full-data",
              // $FlowFixMe[prop-missing] found when upgrading Flow
              value: cleanedInspectedElement
            };
          }
          function logElementToConsole(id) {
            var result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);
            if (result === null) {
              console.warn('Could not find Fiber with id "'.concat(id, '"'));
              return;
            }
            var supportsGroup = typeof console.groupCollapsed === "function";
            if (supportsGroup) {
              console.groupCollapsed(
                "[Click to expand] %c<".concat(result.displayName || "Component", " />"),
                // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.
                "color: var(--dom-tag-name-color); font-weight: normal;"
              );
            }
            if (result.props !== null) {
              console.log("Props:", result.props);
            }
            if (result.state !== null) {
              console.log("State:", result.state);
            }
            if (result.hooks !== null) {
              console.log("Hooks:", result.hooks);
            }
            var nativeNodes = findNativeNodesForFiberID(id);
            if (nativeNodes !== null) {
              console.log("Nodes:", nativeNodes);
            }
            if (result.source !== null) {
              console.log("Location:", result.source);
            }
            if (supportsGroup) {
              console.groupEnd();
            }
          }
          function deletePath(type, id, hookID, path) {
            var fiber = findCurrentFiberUsingSlowPathById(id);
            if (fiber !== null) {
              var instance = fiber.stateNode;
              switch (type) {
                case "context":
                  path = path.slice(1);
                  switch (fiber.tag) {
                    case ClassComponent:
                      if (path.length === 0) {
                      } else {
                        deletePathInObject(instance.context, path);
                      }
                      instance.forceUpdate();
                      break;
                    case FunctionComponent:
                      break;
                  }
                  break;
                case "hooks":
                  if (typeof overrideHookStateDeletePath === "function") {
                    overrideHookStateDeletePath(fiber, hookID, path);
                  }
                  break;
                case "props":
                  if (instance === null) {
                    if (typeof overridePropsDeletePath === "function") {
                      overridePropsDeletePath(fiber, path);
                    }
                  } else {
                    fiber.pendingProps = copyWithDelete(instance.props, path);
                    instance.forceUpdate();
                  }
                  break;
                case "state":
                  deletePathInObject(instance.state, path);
                  instance.forceUpdate();
                  break;
              }
            }
          }
          function renamePath(type, id, hookID, oldPath, newPath) {
            var fiber = findCurrentFiberUsingSlowPathById(id);
            if (fiber !== null) {
              var instance = fiber.stateNode;
              switch (type) {
                case "context":
                  oldPath = oldPath.slice(1);
                  newPath = newPath.slice(1);
                  switch (fiber.tag) {
                    case ClassComponent:
                      if (oldPath.length === 0) {
                      } else {
                        renamePathInObject(instance.context, oldPath, newPath);
                      }
                      instance.forceUpdate();
                      break;
                    case FunctionComponent:
                      break;
                  }
                  break;
                case "hooks":
                  if (typeof overrideHookStateRenamePath === "function") {
                    overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);
                  }
                  break;
                case "props":
                  if (instance === null) {
                    if (typeof overridePropsRenamePath === "function") {
                      overridePropsRenamePath(fiber, oldPath, newPath);
                    }
                  } else {
                    fiber.pendingProps = copyWithRename(instance.props, oldPath, newPath);
                    instance.forceUpdate();
                  }
                  break;
                case "state":
                  renamePathInObject(instance.state, oldPath, newPath);
                  instance.forceUpdate();
                  break;
              }
            }
          }
          function overrideValueAtPath(type, id, hookID, path, value) {
            var fiber = findCurrentFiberUsingSlowPathById(id);
            if (fiber !== null) {
              var instance = fiber.stateNode;
              switch (type) {
                case "context":
                  path = path.slice(1);
                  switch (fiber.tag) {
                    case ClassComponent:
                      if (path.length === 0) {
                        instance.context = value;
                      } else {
                        utils_setInObject(instance.context, path, value);
                      }
                      instance.forceUpdate();
                      break;
                    case FunctionComponent:
                      break;
                  }
                  break;
                case "hooks":
                  if (typeof overrideHookState === "function") {
                    overrideHookState(fiber, hookID, path, value);
                  }
                  break;
                case "props":
                  switch (fiber.tag) {
                    case ClassComponent:
                      fiber.pendingProps = copyWithSet(instance.props, path, value);
                      instance.forceUpdate();
                      break;
                    default:
                      if (typeof overrideProps === "function") {
                        overrideProps(fiber, path, value);
                      }
                      break;
                  }
                  break;
                case "state":
                  switch (fiber.tag) {
                    case ClassComponent:
                      utils_setInObject(instance.state, path, value);
                      instance.forceUpdate();
                      break;
                  }
                  break;
              }
            }
          }
          var currentCommitProfilingMetadata = null;
          var displayNamesByRootID = null;
          var idToContextsMap = null;
          var initialTreeBaseDurationsMap = null;
          var initialIDToRootMap = null;
          var isProfiling = false;
          var profilingStartTime = 0;
          var recordChangeDescriptions = false;
          var rootToCommitProfilingMetadataMap = null;
          function getProfilingData() {
            var dataForRoots = [];
            if (rootToCommitProfilingMetadataMap === null) {
              throw Error("getProfilingData() called before any profiling data was recorded");
            }
            rootToCommitProfilingMetadataMap.forEach(function(commitProfilingMetadata, rootID) {
              var commitData = [];
              var initialTreeBaseDurations = [];
              var displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || "Unknown";
              if (initialTreeBaseDurationsMap != null) {
                initialTreeBaseDurationsMap.forEach(function(treeBaseDuration, id) {
                  if (initialIDToRootMap != null && initialIDToRootMap.get(id) === rootID) {
                    initialTreeBaseDurations.push([id, treeBaseDuration]);
                  }
                });
              }
              commitProfilingMetadata.forEach(function(commitProfilingData, commitIndex) {
                var changeDescriptions = commitProfilingData.changeDescriptions, durations = commitProfilingData.durations, effectDuration = commitProfilingData.effectDuration, maxActualDuration = commitProfilingData.maxActualDuration, passiveEffectDuration = commitProfilingData.passiveEffectDuration, priorityLevel = commitProfilingData.priorityLevel, commitTime = commitProfilingData.commitTime, updaters = commitProfilingData.updaters;
                var fiberActualDurations = [];
                var fiberSelfDurations = [];
                for (var i = 0; i < durations.length; i += 3) {
                  var fiberID = durations[i];
                  fiberActualDurations.push([fiberID, durations[i + 1]]);
                  fiberSelfDurations.push([fiberID, durations[i + 2]]);
                }
                commitData.push({
                  changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,
                  duration: maxActualDuration,
                  effectDuration,
                  fiberActualDurations,
                  fiberSelfDurations,
                  passiveEffectDuration,
                  priorityLevel,
                  timestamp: commitTime,
                  updaters
                });
              });
              dataForRoots.push({
                commitData,
                displayName,
                initialTreeBaseDurations,
                rootID
              });
            });
            var timelineData = null;
            if (typeof getTimelineData === "function") {
              var currentTimelineData = getTimelineData();
              if (currentTimelineData) {
                var batchUIDToMeasuresMap = currentTimelineData.batchUIDToMeasuresMap, internalModuleSourceToRanges = currentTimelineData.internalModuleSourceToRanges, laneToLabelMap = currentTimelineData.laneToLabelMap, laneToReactMeasureMap = currentTimelineData.laneToReactMeasureMap, rest = _objectWithoutProperties(currentTimelineData, ["batchUIDToMeasuresMap", "internalModuleSourceToRanges", "laneToLabelMap", "laneToReactMeasureMap"]);
                timelineData = renderer_objectSpread(renderer_objectSpread({}, rest), {}, {
                  // Most of the data is safe to parse as-is,
                  // but we need to convert the nested Arrays back to Maps.
                  // Most of the data is safe to serialize as-is,
                  // but we need to convert the Maps to nested Arrays.
                  batchUIDToMeasuresKeyValueArray: Array.from(batchUIDToMeasuresMap.entries()),
                  internalModuleSourceToRanges: Array.from(internalModuleSourceToRanges.entries()),
                  laneToLabelKeyValueArray: Array.from(laneToLabelMap.entries()),
                  laneToReactMeasureKeyValueArray: Array.from(laneToReactMeasureMap.entries())
                });
              }
            }
            return {
              dataForRoots,
              rendererID,
              timelineData
            };
          }
          function startProfiling(shouldRecordChangeDescriptions) {
            if (isProfiling) {
              return;
            }
            recordChangeDescriptions = shouldRecordChangeDescriptions;
            displayNamesByRootID = /* @__PURE__ */ new Map();
            initialTreeBaseDurationsMap = new Map(idToTreeBaseDurationMap);
            initialIDToRootMap = new Map(idToRootMap);
            idToContextsMap = /* @__PURE__ */ new Map();
            hook2.getFiberRoots(rendererID).forEach(function(root) {
              var rootID = getFiberIDThrows(root.current);
              displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));
              if (shouldRecordChangeDescriptions) {
                crawlToInitializeContextsMap(root.current);
              }
            });
            isProfiling = true;
            profilingStartTime = renderer_getCurrentTime();
            rootToCommitProfilingMetadataMap = /* @__PURE__ */ new Map();
            if (toggleProfilingStatus !== null) {
              toggleProfilingStatus(true);
            }
          }
          function stopProfiling() {
            isProfiling = false;
            recordChangeDescriptions = false;
            if (toggleProfilingStatus !== null) {
              toggleProfilingStatus(false);
            }
          }
          if (sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === "true") {
            startProfiling(sessionStorageGetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === "true");
          }
          function shouldErrorFiberAlwaysNull() {
            return null;
          }
          var forceErrorForFiberIDs = /* @__PURE__ */ new Map();
          function shouldErrorFiberAccordingToMap(fiber) {
            if (typeof setErrorHandler !== "function") {
              throw new Error("Expected overrideError() to not get called for earlier React versions.");
            }
            var id = getFiberIDUnsafe(fiber);
            if (id === null) {
              return null;
            }
            var status = null;
            if (forceErrorForFiberIDs.has(id)) {
              status = forceErrorForFiberIDs.get(id);
              if (status === false) {
                forceErrorForFiberIDs.delete(id);
                if (forceErrorForFiberIDs.size === 0) {
                  setErrorHandler(shouldErrorFiberAlwaysNull);
                }
              }
            }
            return status;
          }
          function overrideError(id, forceError) {
            if (typeof setErrorHandler !== "function" || typeof scheduleUpdate !== "function") {
              throw new Error("Expected overrideError() to not get called for earlier React versions.");
            }
            forceErrorForFiberIDs.set(id, forceError);
            if (forceErrorForFiberIDs.size === 1) {
              setErrorHandler(shouldErrorFiberAccordingToMap);
            }
            var fiber = idToArbitraryFiberMap.get(id);
            if (fiber != null) {
              scheduleUpdate(fiber);
            }
          }
          function shouldSuspendFiberAlwaysFalse() {
            return false;
          }
          var forceFallbackForSuspenseIDs = /* @__PURE__ */ new Set();
          function shouldSuspendFiberAccordingToSet(fiber) {
            var maybeID = getFiberIDUnsafe(fiber);
            return maybeID !== null && forceFallbackForSuspenseIDs.has(maybeID);
          }
          function overrideSuspense(id, forceFallback) {
            if (typeof setSuspenseHandler !== "function" || typeof scheduleUpdate !== "function") {
              throw new Error("Expected overrideSuspense() to not get called for earlier React versions.");
            }
            if (forceFallback) {
              forceFallbackForSuspenseIDs.add(id);
              if (forceFallbackForSuspenseIDs.size === 1) {
                setSuspenseHandler(shouldSuspendFiberAccordingToSet);
              }
            } else {
              forceFallbackForSuspenseIDs.delete(id);
              if (forceFallbackForSuspenseIDs.size === 0) {
                setSuspenseHandler(shouldSuspendFiberAlwaysFalse);
              }
            }
            var fiber = idToArbitraryFiberMap.get(id);
            if (fiber != null) {
              scheduleUpdate(fiber);
            }
          }
          var trackedPath = null;
          var trackedPathMatchFiber = null;
          var trackedPathMatchDepth = -1;
          var mightBeOnTrackedPath = false;
          function setTrackedPath(path) {
            if (path === null) {
              trackedPathMatchFiber = null;
              trackedPathMatchDepth = -1;
              mightBeOnTrackedPath = false;
            }
            trackedPath = path;
          }
          function updateTrackedPathStateBeforeMount(fiber) {
            if (trackedPath === null || !mightBeOnTrackedPath) {
              return false;
            }
            var returnFiber = fiber.return;
            var returnAlternate = returnFiber !== null ? returnFiber.alternate : null;
            if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {
              var actualFrame = getPathFrame(fiber);
              var expectedFrame = trackedPath[trackedPathMatchDepth + 1];
              if (expectedFrame === void 0) {
                throw new Error("Expected to see a frame at the next depth.");
              }
              if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {
                trackedPathMatchFiber = fiber;
                trackedPathMatchDepth++;
                if (trackedPathMatchDepth === trackedPath.length - 1) {
                  mightBeOnTrackedPath = false;
                } else {
                  mightBeOnTrackedPath = true;
                }
                return false;
              }
            }
            mightBeOnTrackedPath = false;
            return true;
          }
          function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {
            mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;
          }
          var rootPseudoKeys = /* @__PURE__ */ new Map();
          var rootDisplayNameCounter = /* @__PURE__ */ new Map();
          function setRootPseudoKey(id, fiber) {
            var name = getDisplayNameForRoot(fiber);
            var counter = rootDisplayNameCounter.get(name) || 0;
            rootDisplayNameCounter.set(name, counter + 1);
            var pseudoKey = "".concat(name, ":").concat(counter);
            rootPseudoKeys.set(id, pseudoKey);
          }
          function removeRootPseudoKey(id) {
            var pseudoKey = rootPseudoKeys.get(id);
            if (pseudoKey === void 0) {
              throw new Error("Expected root pseudo key to be known.");
            }
            var name = pseudoKey.slice(0, pseudoKey.lastIndexOf(":"));
            var counter = rootDisplayNameCounter.get(name);
            if (counter === void 0) {
              throw new Error("Expected counter to be known.");
            }
            if (counter > 1) {
              rootDisplayNameCounter.set(name, counter - 1);
            } else {
              rootDisplayNameCounter.delete(name);
            }
            rootPseudoKeys.delete(id);
          }
          function getDisplayNameForRoot(fiber) {
            var preferredDisplayName = null;
            var fallbackDisplayName = null;
            var child = fiber.child;
            for (var i = 0; i < 3; i++) {
              if (child === null) {
                break;
              }
              var displayName = getDisplayNameForFiber(child);
              if (displayName !== null) {
                if (typeof child.type === "function") {
                  preferredDisplayName = displayName;
                } else if (fallbackDisplayName === null) {
                  fallbackDisplayName = displayName;
                }
              }
              if (preferredDisplayName !== null) {
                break;
              }
              child = child.child;
            }
            return preferredDisplayName || fallbackDisplayName || "Anonymous";
          }
          function getPathFrame(fiber) {
            var key = fiber.key;
            var displayName = getDisplayNameForFiber(fiber);
            var index = fiber.index;
            switch (fiber.tag) {
              case HostRoot:
                var id = getFiberIDThrows(fiber);
                var pseudoKey = rootPseudoKeys.get(id);
                if (pseudoKey === void 0) {
                  throw new Error("Expected mounted root to have known pseudo key.");
                }
                displayName = pseudoKey;
                break;
              case HostComponent:
                displayName = fiber.type;
                break;
              default:
                break;
            }
            return {
              displayName,
              key,
              index
            };
          }
          function getPathForElement(id) {
            var fiber = idToArbitraryFiberMap.get(id);
            if (fiber == null) {
              return null;
            }
            var keyPath = [];
            while (fiber !== null) {
              keyPath.push(getPathFrame(fiber));
              fiber = fiber.return;
            }
            keyPath.reverse();
            return keyPath;
          }
          function getBestMatchForTrackedPath() {
            if (trackedPath === null) {
              return null;
            }
            if (trackedPathMatchFiber === null) {
              return null;
            }
            var fiber = trackedPathMatchFiber;
            while (fiber !== null && shouldFilterFiber(fiber)) {
              fiber = fiber.return;
            }
            if (fiber === null) {
              return null;
            }
            return {
              id: getFiberIDThrows(fiber),
              // $FlowFixMe[incompatible-use] found when upgrading Flow
              isFullMatch: trackedPathMatchDepth === trackedPath.length - 1
            };
          }
          var formatPriorityLevel = function formatPriorityLevel2(priorityLevel) {
            if (priorityLevel == null) {
              return "Unknown";
            }
            switch (priorityLevel) {
              case ImmediatePriority:
                return "Immediate";
              case UserBlockingPriority:
                return "User-Blocking";
              case NormalPriority:
                return "Normal";
              case LowPriority:
                return "Low";
              case IdlePriority:
                return "Idle";
              case NoPriority:
              default:
                return "Unknown";
            }
          };
          function setTraceUpdatesEnabled(isEnabled2) {
            traceUpdatesEnabled = isEnabled2;
          }
          function hasFiberWithId(id) {
            return idToArbitraryFiberMap.has(id);
          }
          return {
            cleanup,
            clearErrorsAndWarnings,
            clearErrorsForFiberID,
            clearWarningsForFiberID,
            getSerializedElementValueByPath,
            deletePath,
            findNativeNodesForFiberID,
            flushInitialOperations,
            getBestMatchForTrackedPath,
            getDisplayNameForFiberID,
            getFiberForNative,
            getFiberIDForNative,
            getInstanceAndStyle,
            getOwnersList,
            getPathForElement,
            getProfilingData,
            handleCommitFiberRoot,
            handleCommitFiberUnmount,
            handlePostCommitFiberRoot,
            hasFiberWithId,
            inspectElement,
            logElementToConsole,
            patchConsoleForStrictMode: patchForStrictMode,
            prepareViewAttributeSource,
            prepareViewElementSource,
            overrideError,
            overrideSuspense,
            overrideValueAtPath,
            renamePath,
            renderer,
            setTraceUpdatesEnabled,
            setTrackedPath,
            startProfiling,
            stopProfiling,
            storeAsGlobal,
            unpatchConsoleForStrictMode: unpatchForStrictMode,
            updateComponentFilters
          };
        }
        ;
        function console_toConsumableArray(arr) {
          return console_arrayWithoutHoles(arr) || console_iterableToArray(arr) || console_unsupportedIterableToArray(arr) || console_nonIterableSpread();
        }
        function console_nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function console_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
            return Array.from(iter);
        }
        function console_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return console_arrayLikeToArray(arr);
        }
        function console_createForOfIteratorHelper(o, allowArrayLike) {
          var it;
          if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
            if (Array.isArray(o) || (it = console_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it)
                o = it;
              var i = 0;
              var F = function F2() {
              };
              return { s: F, n: function n() {
                if (i >= o.length)
                  return { done: true };
                return { done: false, value: o[i++] };
              }, e: function e(_e) {
                throw _e;
              }, f: F };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true, didErr = false, err;
          return { s: function s() {
            it = o[Symbol.iterator]();
          }, n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          }, e: function e(_e2) {
            didErr = true;
            err = _e2;
          }, f: function f() {
            try {
              if (!normalCompletion && it.return != null)
                it.return();
            } finally {
              if (didErr)
                throw err;
            }
          } };
        }
        function console_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return console_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return console_arrayLikeToArray(o, minLen);
        }
        function console_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        var OVERRIDE_CONSOLE_METHODS = ["error", "trace", "warn"];
        var DIMMED_NODE_CONSOLE_COLOR = "\x1B[2m%s\x1B[0m";
        var PREFIX_REGEX = /\s{4}(in|at)\s{1}/;
        var ROW_COLUMN_NUMBER_REGEX = /:\d+:\d+(\n|$)/;
        function isStringComponentStack(text) {
          return PREFIX_REGEX.test(text) || ROW_COLUMN_NUMBER_REGEX.test(text);
        }
        var STYLE_DIRECTIVE_REGEX = /^%c/;
        function isStrictModeOverride(args, method2) {
          return args.length >= 2 && STYLE_DIRECTIVE_REGEX.test(args[0]) && args[1] === "color: ".concat(getConsoleColor(method2) || "");
        }
        function getConsoleColor(method2) {
          switch (method2) {
            case "warn":
              return consoleSettingsRef.browserTheme === "light" ? "rgba(250, 180, 50, 0.75)" : "rgba(250, 180, 50, 0.5)";
            case "error":
              return consoleSettingsRef.browserTheme === "light" ? "rgba(250, 123, 130, 0.75)" : "rgba(250, 123, 130, 0.5)";
            case "log":
            default:
              return consoleSettingsRef.browserTheme === "light" ? "rgba(125, 125, 125, 0.75)" : "rgba(125, 125, 125, 0.5)";
          }
        }
        var injectedRenderers = /* @__PURE__ */ new Map();
        var targetConsole = console;
        var targetConsoleMethods = {};
        for (var method in console) {
          targetConsoleMethods[method] = console[method];
        }
        var unpatchFn = null;
        var isNode = false;
        try {
          isNode = void 0 === global;
        } catch (error) {
        }
        function dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {
          targetConsole = targetConsoleForTesting;
          targetConsoleMethods = {};
          for (var _method in targetConsole) {
            targetConsoleMethods[_method] = console[_method];
          }
        }
        function registerRenderer(renderer, onErrorOrWarning) {
          var currentDispatcherRef = renderer.currentDispatcherRef, getCurrentFiber = renderer.getCurrentFiber, findFiberByHostInstance = renderer.findFiberByHostInstance, version = renderer.version;
          if (typeof findFiberByHostInstance !== "function") {
            return;
          }
          if (currentDispatcherRef != null && typeof getCurrentFiber === "function") {
            var _getInternalReactCons = getInternalReactConstants(version), ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork;
            injectedRenderers.set(renderer, {
              currentDispatcherRef,
              getCurrentFiber,
              workTagMap: ReactTypeOfWork,
              onErrorOrWarning
            });
          }
        }
        var consoleSettingsRef = {
          appendComponentStack: false,
          breakOnConsoleErrors: false,
          showInlineWarningsAndErrors: false,
          hideConsoleLogsInStrictMode: false,
          browserTheme: "dark"
        };
        function patch(_ref) {
          var appendComponentStack = _ref.appendComponentStack, breakOnConsoleErrors = _ref.breakOnConsoleErrors, showInlineWarningsAndErrors = _ref.showInlineWarningsAndErrors, hideConsoleLogsInStrictMode = _ref.hideConsoleLogsInStrictMode, browserTheme = _ref.browserTheme;
          consoleSettingsRef.appendComponentStack = appendComponentStack;
          consoleSettingsRef.breakOnConsoleErrors = breakOnConsoleErrors;
          consoleSettingsRef.showInlineWarningsAndErrors = showInlineWarningsAndErrors;
          consoleSettingsRef.hideConsoleLogsInStrictMode = hideConsoleLogsInStrictMode;
          consoleSettingsRef.browserTheme = browserTheme;
          if (appendComponentStack || breakOnConsoleErrors || showInlineWarningsAndErrors) {
            if (unpatchFn !== null) {
              return;
            }
            var originalConsoleMethods = {};
            unpatchFn = function unpatchFn2() {
              for (var _method2 in originalConsoleMethods) {
                try {
                  targetConsole[_method2] = originalConsoleMethods[_method2];
                } catch (error) {
                }
              }
            };
            OVERRIDE_CONSOLE_METHODS.forEach(function(method2) {
              try {
                var originalMethod = originalConsoleMethods[method2] = targetConsole[method2].__REACT_DEVTOOLS_ORIGINAL_METHOD__ ? targetConsole[method2].__REACT_DEVTOOLS_ORIGINAL_METHOD__ : targetConsole[method2];
                var overrideMethod = function overrideMethod2() {
                  var shouldAppendWarningStack = false;
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  if (method2 !== "log") {
                    if (consoleSettingsRef.appendComponentStack) {
                      var lastArg = args.length > 0 ? args[args.length - 1] : null;
                      var alreadyHasComponentStack = typeof lastArg === "string" && isStringComponentStack(lastArg);
                      shouldAppendWarningStack = !alreadyHasComponentStack;
                    }
                  }
                  var shouldShowInlineWarningsAndErrors = consoleSettingsRef.showInlineWarningsAndErrors && (method2 === "error" || method2 === "warn");
                  var _iterator = console_createForOfIteratorHelper(injectedRenderers.values()), _step;
                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      var _step$value = _step.value, currentDispatcherRef = _step$value.currentDispatcherRef, getCurrentFiber = _step$value.getCurrentFiber, onErrorOrWarning = _step$value.onErrorOrWarning, workTagMap = _step$value.workTagMap;
                      var current = getCurrentFiber();
                      if (current != null) {
                        try {
                          if (shouldShowInlineWarningsAndErrors) {
                            if (typeof onErrorOrWarning === "function") {
                              onErrorOrWarning(
                                current,
                                method2,
                                // Copy args before we mutate them (e.g. adding the component stack)
                                args.slice()
                              );
                            }
                          }
                          if (shouldAppendWarningStack) {
                            var componentStack = getStackByFiberInDevAndProd(workTagMap, current, currentDispatcherRef);
                            if (componentStack !== "") {
                              if (isStrictModeOverride(args, method2)) {
                                args[0] = "".concat(args[0], " %s");
                                args.push(componentStack);
                              } else {
                                args.push(componentStack);
                              }
                            }
                          }
                        } catch (error) {
                          setTimeout(function() {
                            throw error;
                          }, 0);
                        } finally {
                          break;
                        }
                      }
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                  if (consoleSettingsRef.breakOnConsoleErrors) {
                    debugger;
                  }
                  originalMethod.apply(void 0, args);
                };
                overrideMethod.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = originalMethod;
                originalMethod.__REACT_DEVTOOLS_OVERRIDE_METHOD__ = overrideMethod;
                targetConsole[method2] = overrideMethod;
              } catch (error) {
              }
            });
          } else {
            unpatch();
          }
        }
        function unpatch() {
          if (unpatchFn !== null) {
            unpatchFn();
            unpatchFn = null;
          }
        }
        var unpatchForStrictModeFn = null;
        function patchForStrictMode() {
          if (consoleManagedByDevToolsDuringStrictMode) {
            var overrideConsoleMethods = ["error", "group", "groupCollapsed", "info", "log", "trace", "warn"];
            if (unpatchForStrictModeFn !== null) {
              return;
            }
            var originalConsoleMethods = {};
            unpatchForStrictModeFn = function unpatchForStrictModeFn2() {
              for (var _method3 in originalConsoleMethods) {
                try {
                  targetConsole[_method3] = originalConsoleMethods[_method3];
                } catch (error) {
                }
              }
            };
            overrideConsoleMethods.forEach(function(method2) {
              try {
                var originalMethod = originalConsoleMethods[method2] = targetConsole[method2].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method2].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method2];
                var overrideMethod = function overrideMethod2() {
                  if (!consoleSettingsRef.hideConsoleLogsInStrictMode) {
                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                      args[_key2] = arguments[_key2];
                    }
                    if (isNode) {
                      originalMethod(DIMMED_NODE_CONSOLE_COLOR, format.apply(void 0, args));
                    } else {
                      var color = getConsoleColor(method2);
                      if (color) {
                        originalMethod.apply(void 0, console_toConsumableArray(formatWithStyles(args, "color: ".concat(color))));
                      } else {
                        throw Error("Console color is not defined");
                      }
                    }
                  }
                };
                overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;
                originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;
                targetConsole[method2] = overrideMethod;
              } catch (error) {
              }
            });
          }
        }
        function unpatchForStrictMode() {
          if (consoleManagedByDevToolsDuringStrictMode) {
            if (unpatchForStrictModeFn !== null) {
              unpatchForStrictModeFn();
              unpatchForStrictModeFn = null;
            }
          }
        }
        function patchConsoleUsingWindowValues() {
          var _castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;
          var appendComponentStack = (_castBool = castBool(window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__)) !== null && _castBool !== void 0 ? _castBool : true;
          var breakOnConsoleErrors = (_castBool2 = castBool(window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__)) !== null && _castBool2 !== void 0 ? _castBool2 : false;
          var showInlineWarningsAndErrors = (_castBool3 = castBool(window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__)) !== null && _castBool3 !== void 0 ? _castBool3 : true;
          var hideConsoleLogsInStrictMode = (_castBool4 = castBool(window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__)) !== null && _castBool4 !== void 0 ? _castBool4 : false;
          var browserTheme = (_castBrowserTheme = castBrowserTheme(window.__REACT_DEVTOOLS_BROWSER_THEME__)) !== null && _castBrowserTheme !== void 0 ? _castBrowserTheme : "dark";
          patch({
            appendComponentStack,
            breakOnConsoleErrors,
            showInlineWarningsAndErrors,
            hideConsoleLogsInStrictMode,
            browserTheme
          });
        }
        function writeConsolePatchSettingsToWindow(settings) {
          window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = settings.appendComponentStack;
          window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = settings.breakOnConsoleErrors;
          window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ = settings.showInlineWarningsAndErrors;
          window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ = settings.hideConsoleLogsInStrictMode;
          window.__REACT_DEVTOOLS_BROWSER_THEME__ = settings.browserTheme;
        }
        function installConsoleFunctionsToWindow() {
          window.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__ = {
            patchConsoleUsingWindowValues,
            registerRendererWithConsole: registerRenderer
          };
        }
        ;
        function bridge_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            bridge_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            bridge_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return bridge_typeof(obj);
        }
        function bridge_toConsumableArray(arr) {
          return bridge_arrayWithoutHoles(arr) || bridge_iterableToArray(arr) || bridge_unsupportedIterableToArray(arr) || bridge_nonIterableSpread();
        }
        function bridge_nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function bridge_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return bridge_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return bridge_arrayLikeToArray(o, minLen);
        }
        function bridge_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
            return Array.from(iter);
        }
        function bridge_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return bridge_arrayLikeToArray(arr);
        }
        function bridge_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function bridge_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function bridge_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function bridge_createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            bridge_defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            bridge_defineProperties(Constructor, staticProps);
          return Constructor;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
          if (superClass)
            _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function _possibleConstructorReturn(self2, call) {
          if (call && (bridge_typeof(call) === "object" || typeof call === "function")) {
            return call;
          }
          return _assertThisInitialized(self2);
        }
        function _assertThisInitialized(self2) {
          if (self2 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            }));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return _getPrototypeOf(o);
        }
        function bridge_defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var BATCH_DURATION = 100;
        var BRIDGE_PROTOCOL = [
          // This version technically never existed,
          // but a backwards breaking change was added in 4.11,
          // so the safest guess to downgrade the frontend would be to version 4.10.
          {
            version: 0,
            minNpmVersion: '"<4.11.0"',
            maxNpmVersion: '"<4.11.0"'
          },
          // Versions 4.11.x  4.12.x contained the backwards breaking change,
          // but we didn't add the "fix" of checking the protocol version until 4.13,
          // so we don't recommend downgrading to 4.11 or 4.12.
          {
            version: 1,
            minNpmVersion: "4.13.0",
            maxNpmVersion: "4.21.0"
          },
          // Version 2 adds a StrictMode-enabled and supports-StrictMode bits to add-root operation.
          {
            version: 2,
            minNpmVersion: "4.22.0",
            maxNpmVersion: null
          }
        ];
        var currentBridgeProtocol = BRIDGE_PROTOCOL[BRIDGE_PROTOCOL.length - 1];
        var Bridge = /* @__PURE__ */ function(_EventEmitter) {
          _inherits(Bridge2, _EventEmitter);
          var _super = _createSuper(Bridge2);
          function Bridge2(wall) {
            var _this;
            bridge_classCallCheck(this, Bridge2);
            _this = _super.call(this);
            bridge_defineProperty(_assertThisInitialized(_this), "_isShutdown", false);
            bridge_defineProperty(_assertThisInitialized(_this), "_messageQueue", []);
            bridge_defineProperty(_assertThisInitialized(_this), "_timeoutID", null);
            bridge_defineProperty(_assertThisInitialized(_this), "_wallUnlisten", null);
            bridge_defineProperty(_assertThisInitialized(_this), "_flush", function() {
              if (_this._timeoutID !== null) {
                clearTimeout(_this._timeoutID);
                _this._timeoutID = null;
              }
              if (_this._messageQueue.length) {
                for (var i = 0; i < _this._messageQueue.length; i += 2) {
                  var _this$_wall;
                  (_this$_wall = _this._wall).send.apply(_this$_wall, [_this._messageQueue[i]].concat(bridge_toConsumableArray(_this._messageQueue[i + 1])));
                }
                _this._messageQueue.length = 0;
                _this._timeoutID = setTimeout(_this._flush, BATCH_DURATION);
              }
            });
            bridge_defineProperty(_assertThisInitialized(_this), "overrideValueAtPath", function(_ref) {
              var id = _ref.id, path = _ref.path, rendererID = _ref.rendererID, type = _ref.type, value = _ref.value;
              switch (type) {
                case "context":
                  _this.send("overrideContext", {
                    id,
                    path,
                    rendererID,
                    wasForwarded: true,
                    value
                  });
                  break;
                case "hooks":
                  _this.send("overrideHookState", {
                    id,
                    path,
                    rendererID,
                    wasForwarded: true,
                    value
                  });
                  break;
                case "props":
                  _this.send("overrideProps", {
                    id,
                    path,
                    rendererID,
                    wasForwarded: true,
                    value
                  });
                  break;
                case "state":
                  _this.send("overrideState", {
                    id,
                    path,
                    rendererID,
                    wasForwarded: true,
                    value
                  });
                  break;
              }
            });
            _this._wall = wall;
            _this._wallUnlisten = wall.listen(function(message) {
              if (message && message.event) {
                _assertThisInitialized(_this).emit(message.event, message.payload);
              }
            }) || null;
            _this.addListener("overrideValueAtPath", _this.overrideValueAtPath);
            return _this;
          }
          bridge_createClass(Bridge2, [{
            key: "send",
            value: function send(event) {
              if (this._isShutdown) {
                console.warn('Cannot send message "'.concat(event, '" through a Bridge that has been shutdown.'));
                return;
              }
              for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                payload[_key - 1] = arguments[_key];
              }
              this._messageQueue.push(event, payload);
              if (!this._timeoutID) {
                this._timeoutID = setTimeout(this._flush, 0);
              }
            }
          }, {
            key: "shutdown",
            value: function shutdown() {
              if (this._isShutdown) {
                console.warn("Bridge was already shutdown.");
                return;
              }
              this.emit("shutdown");
              this.send("shutdown");
              this._isShutdown = true;
              this.addListener = function() {
              };
              this.emit = function() {
              };
              this.removeAllListeners();
              var wallUnlisten = this._wallUnlisten;
              if (wallUnlisten) {
                wallUnlisten();
              }
              do {
                this._flush();
              } while (this._messageQueue.length);
              if (this._timeoutID !== null) {
                clearTimeout(this._timeoutID);
                this._timeoutID = null;
              }
            }
          }, {
            key: "wall",
            get: function get() {
              return this._wall;
            }
          }]);
          return Bridge2;
        }(EventEmitter);
        const src_bridge = Bridge;
        ;
        function agent_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            agent_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            agent_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return agent_typeof(obj);
        }
        function agent_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function agent_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function agent_createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            agent_defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            agent_defineProperties(Constructor, staticProps);
          return Constructor;
        }
        function agent_inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
          if (superClass)
            agent_setPrototypeOf(subClass, superClass);
        }
        function agent_setPrototypeOf(o, p) {
          agent_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return agent_setPrototypeOf(o, p);
        }
        function agent_createSuper(Derived) {
          var hasNativeReflectConstruct = agent_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = agent_getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = agent_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return agent_possibleConstructorReturn(this, result);
          };
        }
        function agent_possibleConstructorReturn(self2, call) {
          if (call && (agent_typeof(call) === "object" || typeof call === "function")) {
            return call;
          }
          return agent_assertThisInitialized(self2);
        }
        function agent_assertThisInitialized(self2) {
          if (self2 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function agent_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            }));
            return true;
          } catch (e) {
            return false;
          }
        }
        function agent_getPrototypeOf(o) {
          agent_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return agent_getPrototypeOf(o);
        }
        function agent_defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var debug = function debug2(methodName) {
          if (__DEBUG__) {
            var _console;
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            (_console = console).log.apply(_console, ["%cAgent %c".concat(methodName), "color: purple; font-weight: bold;", "font-weight: bold;"].concat(args));
          }
        };
        var Agent = /* @__PURE__ */ function(_EventEmitter) {
          agent_inherits(Agent2, _EventEmitter);
          var _super = agent_createSuper(Agent2);
          function Agent2(bridge) {
            var _this;
            agent_classCallCheck(this, Agent2);
            _this = _super.call(this);
            agent_defineProperty(agent_assertThisInitialized(_this), "_isProfiling", false);
            agent_defineProperty(agent_assertThisInitialized(_this), "_recordChangeDescriptions", false);
            agent_defineProperty(agent_assertThisInitialized(_this), "_rendererInterfaces", {});
            agent_defineProperty(agent_assertThisInitialized(_this), "_persistedSelection", null);
            agent_defineProperty(agent_assertThisInitialized(_this), "_persistedSelectionMatch", null);
            agent_defineProperty(agent_assertThisInitialized(_this), "_traceUpdatesEnabled", false);
            agent_defineProperty(agent_assertThisInitialized(_this), "clearErrorsAndWarnings", function(_ref) {
              var rendererID = _ref.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '"'));
              } else {
                renderer.clearErrorsAndWarnings();
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "clearErrorsForFiberID", function(_ref2) {
              var id = _ref2.id, rendererID = _ref2.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '"'));
              } else {
                renderer.clearErrorsForFiberID(id);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "clearWarningsForFiberID", function(_ref3) {
              var id = _ref3.id, rendererID = _ref3.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '"'));
              } else {
                renderer.clearWarningsForFiberID(id);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "copyElementPath", function(_ref4) {
              var id = _ref4.id, path = _ref4.path, rendererID = _ref4.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                var value = renderer.getSerializedElementValueByPath(id, path);
                if (value != null) {
                  _this._bridge.send("saveToClipboard", value);
                } else {
                  console.warn('Unable to obtain serialized value for element "'.concat(id, '"'));
                }
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "deletePath", function(_ref5) {
              var hookID = _ref5.hookID, id = _ref5.id, path = _ref5.path, rendererID = _ref5.rendererID, type = _ref5.type;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.deletePath(type, id, hookID, path);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "getBackendVersion", function() {
              var version = "4.28.4-5eda682f8";
              if (version) {
                _this._bridge.send("backendVersion", version);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "getBridgeProtocol", function() {
              _this._bridge.send("bridgeProtocol", currentBridgeProtocol);
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "getProfilingData", function(_ref6) {
              var rendererID = _ref6.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '"'));
              }
              _this._bridge.send("profilingData", renderer.getProfilingData());
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "getProfilingStatus", function() {
              _this._bridge.send("profilingStatus", _this._isProfiling);
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "getOwnersList", function(_ref7) {
              var id = _ref7.id, rendererID = _ref7.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                var owners = renderer.getOwnersList(id);
                _this._bridge.send("ownersList", {
                  id,
                  owners
                });
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "inspectElement", function(_ref8) {
              var forceFullData = _ref8.forceFullData, id = _ref8.id, path = _ref8.path, rendererID = _ref8.rendererID, requestID = _ref8.requestID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                _this._bridge.send("inspectedElement", renderer.inspectElement(requestID, id, path, forceFullData));
                if (_this._persistedSelectionMatch === null || _this._persistedSelectionMatch.id !== id) {
                  _this._persistedSelection = null;
                  _this._persistedSelectionMatch = null;
                  renderer.setTrackedPath(null);
                  _this._throttledPersistSelection(rendererID, id);
                }
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "logElementToConsole", function(_ref9) {
              var id = _ref9.id, rendererID = _ref9.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.logElementToConsole(id);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "overrideError", function(_ref10) {
              var id = _ref10.id, rendererID = _ref10.rendererID, forceError = _ref10.forceError;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.overrideError(id, forceError);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "overrideSuspense", function(_ref11) {
              var id = _ref11.id, rendererID = _ref11.rendererID, forceFallback = _ref11.forceFallback;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.overrideSuspense(id, forceFallback);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "overrideValueAtPath", function(_ref12) {
              var hookID = _ref12.hookID, id = _ref12.id, path = _ref12.path, rendererID = _ref12.rendererID, type = _ref12.type, value = _ref12.value;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.overrideValueAtPath(type, id, hookID, path, value);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "overrideContext", function(_ref13) {
              var id = _ref13.id, path = _ref13.path, rendererID = _ref13.rendererID, wasForwarded = _ref13.wasForwarded, value = _ref13.value;
              if (!wasForwarded) {
                _this.overrideValueAtPath({
                  id,
                  path,
                  rendererID,
                  type: "context",
                  value
                });
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "overrideHookState", function(_ref14) {
              var id = _ref14.id, hookID = _ref14.hookID, path = _ref14.path, rendererID = _ref14.rendererID, wasForwarded = _ref14.wasForwarded, value = _ref14.value;
              if (!wasForwarded) {
                _this.overrideValueAtPath({
                  id,
                  path,
                  rendererID,
                  type: "hooks",
                  value
                });
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "overrideProps", function(_ref15) {
              var id = _ref15.id, path = _ref15.path, rendererID = _ref15.rendererID, wasForwarded = _ref15.wasForwarded, value = _ref15.value;
              if (!wasForwarded) {
                _this.overrideValueAtPath({
                  id,
                  path,
                  rendererID,
                  type: "props",
                  value
                });
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "overrideState", function(_ref16) {
              var id = _ref16.id, path = _ref16.path, rendererID = _ref16.rendererID, wasForwarded = _ref16.wasForwarded, value = _ref16.value;
              if (!wasForwarded) {
                _this.overrideValueAtPath({
                  id,
                  path,
                  rendererID,
                  type: "state",
                  value
                });
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "reloadAndProfile", function(recordChangeDescriptions) {
              sessionStorageSetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY, "true");
              sessionStorageSetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, recordChangeDescriptions ? "true" : "false");
              _this._bridge.send("reloadAppForProfiling");
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "renamePath", function(_ref17) {
              var hookID = _ref17.hookID, id = _ref17.id, newPath = _ref17.newPath, oldPath = _ref17.oldPath, rendererID = _ref17.rendererID, type = _ref17.type;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.renamePath(type, id, hookID, oldPath, newPath);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "setTraceUpdatesEnabled", function(traceUpdatesEnabled) {
              _this._traceUpdatesEnabled = traceUpdatesEnabled;
              toggleEnabled(traceUpdatesEnabled);
              for (var rendererID in _this._rendererInterfaces) {
                var renderer = _this._rendererInterfaces[rendererID];
                renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "syncSelectionFromNativeElementsPanel", function() {
              var target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;
              if (target == null) {
                return;
              }
              _this.selectNode(target);
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "shutdown", function() {
              _this.emit("shutdown");
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "startProfiling", function(recordChangeDescriptions) {
              _this._recordChangeDescriptions = recordChangeDescriptions;
              _this._isProfiling = true;
              for (var rendererID in _this._rendererInterfaces) {
                var renderer = _this._rendererInterfaces[rendererID];
                renderer.startProfiling(recordChangeDescriptions);
              }
              _this._bridge.send("profilingStatus", _this._isProfiling);
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "stopProfiling", function() {
              _this._isProfiling = false;
              _this._recordChangeDescriptions = false;
              for (var rendererID in _this._rendererInterfaces) {
                var renderer = _this._rendererInterfaces[rendererID];
                renderer.stopProfiling();
              }
              _this._bridge.send("profilingStatus", _this._isProfiling);
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "stopInspectingNative", function(selected) {
              _this._bridge.send("stopInspectingNative", selected);
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "storeAsGlobal", function(_ref18) {
              var count = _ref18.count, id = _ref18.id, path = _ref18.path, rendererID = _ref18.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.storeAsGlobal(id, path, count);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "updateConsolePatchSettings", function(_ref19) {
              var appendComponentStack = _ref19.appendComponentStack, breakOnConsoleErrors = _ref19.breakOnConsoleErrors, showInlineWarningsAndErrors = _ref19.showInlineWarningsAndErrors, hideConsoleLogsInStrictMode = _ref19.hideConsoleLogsInStrictMode, browserTheme = _ref19.browserTheme;
              patch({
                appendComponentStack,
                breakOnConsoleErrors,
                showInlineWarningsAndErrors,
                hideConsoleLogsInStrictMode,
                browserTheme
              });
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "updateComponentFilters", function(componentFilters) {
              for (var rendererID in _this._rendererInterfaces) {
                var renderer = _this._rendererInterfaces[rendererID];
                renderer.updateComponentFilters(componentFilters);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "viewAttributeSource", function(_ref20) {
              var id = _ref20.id, path = _ref20.path, rendererID = _ref20.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.prepareViewAttributeSource(id, path);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "viewElementSource", function(_ref21) {
              var id = _ref21.id, rendererID = _ref21.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.prepareViewElementSource(id);
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "onTraceUpdates", function(nodes) {
              _this.emit("traceUpdates", nodes);
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "onFastRefreshScheduled", function() {
              if (__DEBUG__) {
                debug("onFastRefreshScheduled");
              }
              _this._bridge.send("fastRefreshScheduled");
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "onHookOperations", function(operations) {
              if (__DEBUG__) {
                debug("onHookOperations", "(".concat(operations.length, ") [").concat(operations.join(", "), "]"));
              }
              _this._bridge.send("operations", operations);
              if (_this._persistedSelection !== null) {
                var rendererID = operations[0];
                if (_this._persistedSelection.rendererID === rendererID) {
                  var renderer = _this._rendererInterfaces[rendererID];
                  if (renderer == null) {
                    console.warn('Invalid renderer id "'.concat(rendererID, '"'));
                  } else {
                    var prevMatch = _this._persistedSelectionMatch;
                    var nextMatch = renderer.getBestMatchForTrackedPath();
                    _this._persistedSelectionMatch = nextMatch;
                    var prevMatchID = prevMatch !== null ? prevMatch.id : null;
                    var nextMatchID = nextMatch !== null ? nextMatch.id : null;
                    if (prevMatchID !== nextMatchID) {
                      if (nextMatchID !== null) {
                        _this._bridge.send("selectFiber", nextMatchID);
                      }
                    }
                    if (nextMatch !== null && nextMatch.isFullMatch) {
                      _this._persistedSelection = null;
                      _this._persistedSelectionMatch = null;
                      renderer.setTrackedPath(null);
                    }
                  }
                }
              }
            });
            agent_defineProperty(agent_assertThisInitialized(_this), "_throttledPersistSelection", lodash_throttle_default()(function(rendererID, id) {
              var renderer = _this._rendererInterfaces[rendererID];
              var path = renderer != null ? renderer.getPathForElement(id) : null;
              if (path !== null) {
                sessionStorageSetItem(SESSION_STORAGE_LAST_SELECTION_KEY, JSON.stringify({
                  rendererID,
                  path
                }));
              } else {
                sessionStorageRemoveItem(SESSION_STORAGE_LAST_SELECTION_KEY);
              }
            }, 1e3));
            if (sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === "true") {
              _this._recordChangeDescriptions = sessionStorageGetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === "true";
              _this._isProfiling = true;
              sessionStorageRemoveItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY);
              sessionStorageRemoveItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY);
            }
            var persistedSelectionString = sessionStorageGetItem(SESSION_STORAGE_LAST_SELECTION_KEY);
            if (persistedSelectionString != null) {
              _this._persistedSelection = JSON.parse(persistedSelectionString);
            }
            _this._bridge = bridge;
            bridge.addListener("clearErrorsAndWarnings", _this.clearErrorsAndWarnings);
            bridge.addListener("clearErrorsForFiberID", _this.clearErrorsForFiberID);
            bridge.addListener("clearWarningsForFiberID", _this.clearWarningsForFiberID);
            bridge.addListener("copyElementPath", _this.copyElementPath);
            bridge.addListener("deletePath", _this.deletePath);
            bridge.addListener("getBackendVersion", _this.getBackendVersion);
            bridge.addListener("getBridgeProtocol", _this.getBridgeProtocol);
            bridge.addListener("getProfilingData", _this.getProfilingData);
            bridge.addListener("getProfilingStatus", _this.getProfilingStatus);
            bridge.addListener("getOwnersList", _this.getOwnersList);
            bridge.addListener("inspectElement", _this.inspectElement);
            bridge.addListener("logElementToConsole", _this.logElementToConsole);
            bridge.addListener("overrideError", _this.overrideError);
            bridge.addListener("overrideSuspense", _this.overrideSuspense);
            bridge.addListener("overrideValueAtPath", _this.overrideValueAtPath);
            bridge.addListener("reloadAndProfile", _this.reloadAndProfile);
            bridge.addListener("renamePath", _this.renamePath);
            bridge.addListener("setTraceUpdatesEnabled", _this.setTraceUpdatesEnabled);
            bridge.addListener("startProfiling", _this.startProfiling);
            bridge.addListener("stopProfiling", _this.stopProfiling);
            bridge.addListener("storeAsGlobal", _this.storeAsGlobal);
            bridge.addListener("syncSelectionFromNativeElementsPanel", _this.syncSelectionFromNativeElementsPanel);
            bridge.addListener("shutdown", _this.shutdown);
            bridge.addListener("updateConsolePatchSettings", _this.updateConsolePatchSettings);
            bridge.addListener("updateComponentFilters", _this.updateComponentFilters);
            bridge.addListener("viewAttributeSource", _this.viewAttributeSource);
            bridge.addListener("viewElementSource", _this.viewElementSource);
            bridge.addListener("overrideContext", _this.overrideContext);
            bridge.addListener("overrideHookState", _this.overrideHookState);
            bridge.addListener("overrideProps", _this.overrideProps);
            bridge.addListener("overrideState", _this.overrideState);
            if (_this._isProfiling) {
              bridge.send("profilingStatus", true);
            }
            var _version = "4.28.4-5eda682f8";
            if (_version) {
              _this._bridge.send("backendVersion", _version);
            }
            _this._bridge.send("bridgeProtocol", currentBridgeProtocol);
            var isBackendStorageAPISupported = false;
            try {
              localStorage.getItem("test");
              isBackendStorageAPISupported = true;
            } catch (error) {
            }
            bridge.send("isBackendStorageAPISupported", isBackendStorageAPISupported);
            bridge.send("isSynchronousXHRSupported", isSynchronousXHRSupported());
            setupHighlighter(bridge, agent_assertThisInitialized(_this));
            TraceUpdates_initialize(agent_assertThisInitialized(_this));
            return _this;
          }
          agent_createClass(Agent2, [{
            key: "getInstanceAndStyle",
            value: function getInstanceAndStyle(_ref22) {
              var id = _ref22.id, rendererID = _ref22.rendererID;
              var renderer = this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '"'));
                return null;
              }
              return renderer.getInstanceAndStyle(id);
            }
          }, {
            key: "getBestMatchingRendererInterface",
            value: function getBestMatchingRendererInterface(node) {
              var bestMatch = null;
              for (var rendererID in this._rendererInterfaces) {
                var renderer = this._rendererInterfaces[rendererID];
                var fiber = renderer.getFiberForNative(node);
                if (fiber !== null) {
                  if (fiber.stateNode === node) {
                    return renderer;
                  } else if (bestMatch === null) {
                    bestMatch = renderer;
                  }
                }
              }
              return bestMatch;
            }
          }, {
            key: "getIDForNode",
            value: function getIDForNode(node) {
              var rendererInterface = this.getBestMatchingRendererInterface(node);
              if (rendererInterface != null) {
                try {
                  return rendererInterface.getFiberIDForNative(node, true);
                } catch (error) {
                }
              }
              return null;
            }
          }, {
            key: "selectNode",
            value: function selectNode(target) {
              var id = this.getIDForNode(target);
              if (id !== null) {
                this._bridge.send("selectFiber", id);
              }
            }
          }, {
            key: "setRendererInterface",
            value: function setRendererInterface(rendererID, rendererInterface) {
              this._rendererInterfaces[rendererID] = rendererInterface;
              if (this._isProfiling) {
                rendererInterface.startProfiling(this._recordChangeDescriptions);
              }
              rendererInterface.setTraceUpdatesEnabled(this._traceUpdatesEnabled);
              var selection = this._persistedSelection;
              if (selection !== null && selection.rendererID === rendererID) {
                rendererInterface.setTrackedPath(selection.path);
              }
            }
          }, {
            key: "onUnsupportedRenderer",
            value: function onUnsupportedRenderer(rendererID) {
              this._bridge.send("unsupportedRendererVersion", rendererID);
            }
          }, {
            key: "rendererInterfaces",
            get: function get() {
              return this._rendererInterfaces;
            }
          }]);
          return Agent2;
        }(EventEmitter);
        ;
        function hook_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            hook_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            hook_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return hook_typeof(obj);
        }
        function hook_toConsumableArray(arr) {
          return hook_arrayWithoutHoles(arr) || hook_iterableToArray(arr) || hook_unsupportedIterableToArray(arr) || hook_nonIterableSpread();
        }
        function hook_nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function hook_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return hook_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return hook_arrayLikeToArray(o, minLen);
        }
        function hook_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
            return Array.from(iter);
        }
        function hook_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return hook_arrayLikeToArray(arr);
        }
        function hook_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function installHook(target) {
          if (target.hasOwnProperty("__REACT_DEVTOOLS_GLOBAL_HOOK__")) {
            return null;
          }
          var targetConsole2 = console;
          var targetConsoleMethods2 = {};
          for (var method2 in console) {
            targetConsoleMethods2[method2] = console[method2];
          }
          function dangerous_setTargetConsoleForTesting2(targetConsoleForTesting) {
            targetConsole2 = targetConsoleForTesting;
            targetConsoleMethods2 = {};
            for (var _method in targetConsole2) {
              targetConsoleMethods2[_method] = console[_method];
            }
          }
          function detectReactBuildType(renderer) {
            try {
              if (typeof renderer.version === "string") {
                if (renderer.bundleType > 0) {
                  return "development";
                }
                return "production";
              }
              var _toString = Function.prototype.toString;
              if (renderer.Mount && renderer.Mount._renderNewRootComponent) {
                var renderRootCode = _toString.call(renderer.Mount._renderNewRootComponent);
                if (renderRootCode.indexOf("function") !== 0) {
                  return "production";
                }
                if (renderRootCode.indexOf("storedMeasure") !== -1) {
                  return "development";
                }
                if (renderRootCode.indexOf("should be a pure function") !== -1) {
                  if (renderRootCode.indexOf("NODE_ENV") !== -1) {
                    return "development";
                  }
                  if (renderRootCode.indexOf("development") !== -1) {
                    return "development";
                  }
                  if (renderRootCode.indexOf("true") !== -1) {
                    return "development";
                  }
                  if (
                    // 0.13 to 15
                    renderRootCode.indexOf("nextElement") !== -1 || // 0.12
                    renderRootCode.indexOf("nextComponent") !== -1
                  ) {
                    return "unminified";
                  } else {
                    return "development";
                  }
                }
                if (
                  // 0.13 to 15
                  renderRootCode.indexOf("nextElement") !== -1 || // 0.12
                  renderRootCode.indexOf("nextComponent") !== -1
                ) {
                  return "unminified";
                }
                return "outdated";
              }
            } catch (err) {
            }
            return "production";
          }
          function checkDCE(fn) {
            try {
              var _toString2 = Function.prototype.toString;
              var code = _toString2.call(fn);
              if (code.indexOf("^_^") > -1) {
                hasDetectedBadDCE = true;
                setTimeout(function() {
                  throw new Error("React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://reactjs.org/link/perf-use-production-build");
                });
              }
            } catch (err) {
            }
          }
          function formatWithStyles2(inputArgs, style) {
            if (inputArgs === void 0 || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c
            typeof inputArgs[0] === "string" && inputArgs[0].match(/([^%]|^)(%c)/g) || style === void 0) {
              return inputArgs;
            }
            var REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;
            if (typeof inputArgs[0] === "string" && inputArgs[0].match(REGEXP)) {
              return ["%c".concat(inputArgs[0]), style].concat(hook_toConsumableArray(inputArgs.slice(1)));
            } else {
              var firstArg = inputArgs.reduce(function(formatStr, elem, i) {
                if (i > 0) {
                  formatStr += " ";
                }
                switch (hook_typeof(elem)) {
                  case "string":
                  case "boolean":
                  case "symbol":
                    return formatStr += "%s";
                  case "number":
                    var formatting = Number.isInteger(elem) ? "%i" : "%f";
                    return formatStr += formatting;
                  default:
                    return formatStr += "%o";
                }
              }, "%c");
              return [firstArg, style].concat(hook_toConsumableArray(inputArgs));
            }
          }
          var unpatchFn2 = null;
          function patchConsoleForInitialRenderInStrictMode(_ref) {
            var hideConsoleLogsInStrictMode = _ref.hideConsoleLogsInStrictMode, browserTheme = _ref.browserTheme;
            var overrideConsoleMethods = ["error", "group", "groupCollapsed", "info", "log", "trace", "warn"];
            if (unpatchFn2 !== null) {
              return;
            }
            var originalConsoleMethods = {};
            unpatchFn2 = function unpatchFn3() {
              for (var _method2 in originalConsoleMethods) {
                try {
                  targetConsole2[_method2] = originalConsoleMethods[_method2];
                } catch (error) {
                }
              }
            };
            overrideConsoleMethods.forEach(function(method3) {
              try {
                var originalMethod = originalConsoleMethods[method3] = targetConsole2[method3].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole2[method3].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole2[method3];
                var overrideMethod = function overrideMethod2() {
                  if (!hideConsoleLogsInStrictMode) {
                    var color;
                    switch (method3) {
                      case "warn":
                        color = browserTheme === "light" ? "rgba(250, 180, 50, 0.75)" : "rgba(250, 180, 50, 0.5)";
                        break;
                      case "error":
                        color = browserTheme === "light" ? "rgba(250, 123, 130, 0.75)" : "rgba(250, 123, 130, 0.5)";
                        break;
                      case "log":
                      default:
                        color = browserTheme === "light" ? "rgba(125, 125, 125, 0.75)" : "rgba(125, 125, 125, 0.5)";
                        break;
                    }
                    if (color) {
                      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                      }
                      originalMethod.apply(void 0, hook_toConsumableArray(formatWithStyles2(args, "color: ".concat(color))));
                    } else {
                      throw Error("Console color is not defined");
                    }
                  }
                };
                overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;
                originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;
                targetConsole2[method3] = overrideMethod;
              } catch (error) {
              }
            });
          }
          function unpatchConsoleForInitialRenderInStrictMode() {
            if (unpatchFn2 !== null) {
              unpatchFn2();
              unpatchFn2 = null;
            }
          }
          var uidCounter2 = 0;
          function inject(renderer) {
            var id = ++uidCounter2;
            renderers.set(id, renderer);
            var reactBuildType = hasDetectedBadDCE ? "deadcode" : detectReactBuildType(renderer);
            if (target.hasOwnProperty("__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__")) {
              var _target$__REACT_DEVTO = target.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__, registerRendererWithConsole = _target$__REACT_DEVTO.registerRendererWithConsole, patchConsoleUsingWindowValues2 = _target$__REACT_DEVTO.patchConsoleUsingWindowValues;
              if (typeof registerRendererWithConsole === "function" && typeof patchConsoleUsingWindowValues2 === "function") {
                registerRendererWithConsole(renderer);
                patchConsoleUsingWindowValues2();
              }
            }
            var attach2 = target.__REACT_DEVTOOLS_ATTACH__;
            if (typeof attach2 === "function") {
              var rendererInterface = attach2(hook2, id, renderer, target);
              hook2.rendererInterfaces.set(id, rendererInterface);
            }
            hook2.emit("renderer", {
              id,
              renderer,
              reactBuildType
            });
            return id;
          }
          var hasDetectedBadDCE = false;
          function sub(event, fn) {
            hook2.on(event, fn);
            return function() {
              return hook2.off(event, fn);
            };
          }
          function on(event, fn) {
            if (!listeners[event]) {
              listeners[event] = [];
            }
            listeners[event].push(fn);
          }
          function off(event, fn) {
            if (!listeners[event]) {
              return;
            }
            var index = listeners[event].indexOf(fn);
            if (index !== -1) {
              listeners[event].splice(index, 1);
            }
            if (!listeners[event].length) {
              delete listeners[event];
            }
          }
          function emit(event, data) {
            if (listeners[event]) {
              listeners[event].map(function(fn) {
                return fn(data);
              });
            }
          }
          function getFiberRoots(rendererID) {
            var roots = fiberRoots;
            if (!roots[rendererID]) {
              roots[rendererID] = /* @__PURE__ */ new Set();
            }
            return roots[rendererID];
          }
          function onCommitFiberUnmount(rendererID, fiber) {
            var rendererInterface = rendererInterfaces.get(rendererID);
            if (rendererInterface != null) {
              rendererInterface.handleCommitFiberUnmount(fiber);
            }
          }
          function onCommitFiberRoot(rendererID, root, priorityLevel) {
            var mountedRoots = hook2.getFiberRoots(rendererID);
            var current = root.current;
            var isKnownRoot = mountedRoots.has(root);
            var isUnmounting = current.memoizedState == null || current.memoizedState.element == null;
            if (!isKnownRoot && !isUnmounting) {
              mountedRoots.add(root);
            } else if (isKnownRoot && isUnmounting) {
              mountedRoots.delete(root);
            }
            var rendererInterface = rendererInterfaces.get(rendererID);
            if (rendererInterface != null) {
              rendererInterface.handleCommitFiberRoot(root, priorityLevel);
            }
          }
          function onPostCommitFiberRoot(rendererID, root) {
            var rendererInterface = rendererInterfaces.get(rendererID);
            if (rendererInterface != null) {
              rendererInterface.handlePostCommitFiberRoot(root);
            }
          }
          function setStrictMode(rendererID, isStrictMode) {
            var rendererInterface = rendererInterfaces.get(rendererID);
            if (rendererInterface != null) {
              if (isStrictMode) {
                rendererInterface.patchConsoleForStrictMode();
              } else {
                rendererInterface.unpatchConsoleForStrictMode();
              }
            } else {
              if (isStrictMode) {
                var hideConsoleLogsInStrictMode = window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ === true;
                var browserTheme = window.__REACT_DEVTOOLS_BROWSER_THEME__;
                patchConsoleForInitialRenderInStrictMode({
                  hideConsoleLogsInStrictMode,
                  browserTheme
                });
              } else {
                unpatchConsoleForInitialRenderInStrictMode();
              }
            }
          }
          var openModuleRangesStack = [];
          var moduleRanges = [];
          function getTopStackFrameString(error) {
            var frames = error.stack.split("\n");
            var frame = frames.length > 1 ? frames[1] : null;
            return frame;
          }
          function getInternalModuleRanges() {
            return moduleRanges;
          }
          function registerInternalModuleStart(error) {
            var startStackFrame = getTopStackFrameString(error);
            if (startStackFrame !== null) {
              openModuleRangesStack.push(startStackFrame);
            }
          }
          function registerInternalModuleStop(error) {
            if (openModuleRangesStack.length > 0) {
              var startStackFrame = openModuleRangesStack.pop();
              var stopStackFrame = getTopStackFrameString(error);
              if (stopStackFrame !== null) {
                moduleRanges.push([startStackFrame, stopStackFrame]);
              }
            }
          }
          var fiberRoots = {};
          var rendererInterfaces = /* @__PURE__ */ new Map();
          var listeners = {};
          var renderers = /* @__PURE__ */ new Map();
          var backends = /* @__PURE__ */ new Map();
          var hook2 = {
            rendererInterfaces,
            listeners,
            backends,
            // Fast Refresh for web relies on this.
            renderers,
            emit,
            getFiberRoots,
            inject,
            on,
            off,
            sub,
            // This is a legacy flag.
            // React v16 checks the hook for this to ensure DevTools is new enough.
            supportsFiber: true,
            // React calls these methods.
            checkDCE,
            onCommitFiberUnmount,
            onCommitFiberRoot,
            onPostCommitFiberRoot,
            setStrictMode,
            // Schedule Profiler runtime helpers.
            // These internal React modules to report their own boundaries
            // which in turn enables the profiler to dim or filter internal frames.
            getInternalModuleRanges,
            registerInternalModuleStart,
            registerInternalModuleStop
          };
          if (false) {
          }
          Object.defineProperty(target, "__REACT_DEVTOOLS_GLOBAL_HOOK__", {
            // This property needs to be configurable for the test environment,
            // else we won't be able to delete and recreate it between tests.
            configurable: false,
            enumerable: false,
            get: function get() {
              return hook2;
            }
          });
          return hook2;
        }
        ;
        function decorate(object, attr, fn) {
          var old = object[attr];
          object[attr] = function(instance) {
            return fn.call(this, old, arguments);
          };
          return old;
        }
        function decorateMany(source, fns) {
          var olds = {};
          for (var name in fns) {
            olds[name] = decorate(source, name, fns[name]);
          }
          return olds;
        }
        function restoreMany(source, olds) {
          for (var name in olds) {
            source[name] = olds[name];
          }
        }
        function forceUpdate(instance) {
          if (typeof instance.forceUpdate === "function") {
            instance.forceUpdate();
          } else if (instance.updater != null && typeof instance.updater.enqueueForceUpdate === "function") {
            instance.updater.enqueueForceUpdate(this, function() {
            }, "forceUpdate");
          }
        }
        ;
        function legacy_renderer_ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function legacy_renderer_objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              legacy_renderer_ownKeys(Object(source), true).forEach(function(key) {
                legacy_renderer_defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              legacy_renderer_ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function legacy_renderer_defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function legacy_renderer_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            legacy_renderer_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            legacy_renderer_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return legacy_renderer_typeof(obj);
        }
        function getData(internalInstance) {
          var displayName = null;
          var key = null;
          if (internalInstance._currentElement != null) {
            if (internalInstance._currentElement.key) {
              key = String(internalInstance._currentElement.key);
            }
            var elementType = internalInstance._currentElement.type;
            if (typeof elementType === "string") {
              displayName = elementType;
            } else if (typeof elementType === "function") {
              displayName = getDisplayName(elementType);
            }
          }
          return {
            displayName,
            key
          };
        }
        function getElementType(internalInstance) {
          if (internalInstance._currentElement != null) {
            var elementType = internalInstance._currentElement.type;
            if (typeof elementType === "function") {
              var publicInstance = internalInstance.getPublicInstance();
              if (publicInstance !== null) {
                return types_ElementTypeClass;
              } else {
                return types_ElementTypeFunction;
              }
            } else if (typeof elementType === "string") {
              return ElementTypeHostComponent;
            }
          }
          return ElementTypeOtherOrUnknown;
        }
        function getChildren(internalInstance) {
          var children = [];
          if (legacy_renderer_typeof(internalInstance) !== "object") {
          } else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {
          } else if (internalInstance._renderedComponent) {
            var child = internalInstance._renderedComponent;
            if (getElementType(child) !== ElementTypeOtherOrUnknown) {
              children.push(child);
            }
          } else if (internalInstance._renderedChildren) {
            var renderedChildren = internalInstance._renderedChildren;
            for (var name in renderedChildren) {
              var _child = renderedChildren[name];
              if (getElementType(_child) !== ElementTypeOtherOrUnknown) {
                children.push(_child);
              }
            }
          }
          return children;
        }
        function renderer_attach(hook2, rendererID, renderer, global2) {
          var idToInternalInstanceMap = /* @__PURE__ */ new Map();
          var internalInstanceToIDMap = /* @__PURE__ */ new WeakMap();
          var internalInstanceToRootIDMap = /* @__PURE__ */ new WeakMap();
          var getInternalIDForNative = null;
          var findNativeNodeForInternalID;
          var getFiberForNative = function getFiberForNative2(node) {
            return null;
          };
          if (renderer.ComponentTree) {
            getInternalIDForNative = function getInternalIDForNative2(node, findNearestUnfilteredAncestor) {
              var internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);
              return internalInstanceToIDMap.get(internalInstance) || null;
            };
            findNativeNodeForInternalID = function findNativeNodeForInternalID2(id) {
              var internalInstance = idToInternalInstanceMap.get(id);
              return renderer.ComponentTree.getNodeFromInstance(internalInstance);
            };
            getFiberForNative = function getFiberForNative2(node) {
              return renderer.ComponentTree.getClosestInstanceFromNode(node);
            };
          } else if (renderer.Mount.getID && renderer.Mount.getNode) {
            getInternalIDForNative = function getInternalIDForNative2(node, findNearestUnfilteredAncestor) {
              return null;
            };
            findNativeNodeForInternalID = function findNativeNodeForInternalID2(id) {
              return null;
            };
          }
          function getDisplayNameForFiberID(id) {
            var internalInstance = idToInternalInstanceMap.get(id);
            return internalInstance ? getData(internalInstance).displayName : null;
          }
          function getID(internalInstance) {
            if (legacy_renderer_typeof(internalInstance) !== "object" || internalInstance === null) {
              throw new Error("Invalid internal instance: " + internalInstance);
            }
            if (!internalInstanceToIDMap.has(internalInstance)) {
              var _id = getUID();
              internalInstanceToIDMap.set(internalInstance, _id);
              idToInternalInstanceMap.set(_id, internalInstance);
            }
            return internalInstanceToIDMap.get(internalInstance);
          }
          function areEqualArrays(a, b) {
            if (a.length !== b.length) {
              return false;
            }
            for (var i = 0; i < a.length; i++) {
              if (a[i] !== b[i]) {
                return false;
              }
            }
            return true;
          }
          var parentIDStack = [];
          var oldReconcilerMethods = null;
          if (renderer.Reconciler) {
            oldReconcilerMethods = decorateMany(renderer.Reconciler, {
              mountComponent: function mountComponent(fn, args) {
                var internalInstance = args[0];
                var hostContainerInfo = args[3];
                if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
                  return fn.apply(this, args);
                }
                if (hostContainerInfo._topLevelWrapper === void 0) {
                  return fn.apply(this, args);
                }
                var id = getID(internalInstance);
                var parentID = parentIDStack.length > 0 ? parentIDStack[parentIDStack.length - 1] : 0;
                recordMount(internalInstance, id, parentID);
                parentIDStack.push(id);
                internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));
                try {
                  var result = fn.apply(this, args);
                  parentIDStack.pop();
                  return result;
                } catch (err) {
                  parentIDStack = [];
                  throw err;
                } finally {
                  if (parentIDStack.length === 0) {
                    var rootID = internalInstanceToRootIDMap.get(internalInstance);
                    if (rootID === void 0) {
                      throw new Error("Expected to find root ID.");
                    }
                    flushPendingEvents(rootID);
                  }
                }
              },
              performUpdateIfNecessary: function performUpdateIfNecessary(fn, args) {
                var internalInstance = args[0];
                if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
                  return fn.apply(this, args);
                }
                var id = getID(internalInstance);
                parentIDStack.push(id);
                var prevChildren = getChildren(internalInstance);
                try {
                  var result = fn.apply(this, args);
                  var nextChildren = getChildren(internalInstance);
                  if (!areEqualArrays(prevChildren, nextChildren)) {
                    recordReorder(internalInstance, id, nextChildren);
                  }
                  parentIDStack.pop();
                  return result;
                } catch (err) {
                  parentIDStack = [];
                  throw err;
                } finally {
                  if (parentIDStack.length === 0) {
                    var rootID = internalInstanceToRootIDMap.get(internalInstance);
                    if (rootID === void 0) {
                      throw new Error("Expected to find root ID.");
                    }
                    flushPendingEvents(rootID);
                  }
                }
              },
              receiveComponent: function receiveComponent(fn, args) {
                var internalInstance = args[0];
                if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
                  return fn.apply(this, args);
                }
                var id = getID(internalInstance);
                parentIDStack.push(id);
                var prevChildren = getChildren(internalInstance);
                try {
                  var result = fn.apply(this, args);
                  var nextChildren = getChildren(internalInstance);
                  if (!areEqualArrays(prevChildren, nextChildren)) {
                    recordReorder(internalInstance, id, nextChildren);
                  }
                  parentIDStack.pop();
                  return result;
                } catch (err) {
                  parentIDStack = [];
                  throw err;
                } finally {
                  if (parentIDStack.length === 0) {
                    var rootID = internalInstanceToRootIDMap.get(internalInstance);
                    if (rootID === void 0) {
                      throw new Error("Expected to find root ID.");
                    }
                    flushPendingEvents(rootID);
                  }
                }
              },
              unmountComponent: function unmountComponent(fn, args) {
                var internalInstance = args[0];
                if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
                  return fn.apply(this, args);
                }
                var id = getID(internalInstance);
                parentIDStack.push(id);
                try {
                  var result = fn.apply(this, args);
                  parentIDStack.pop();
                  recordUnmount(internalInstance, id);
                  return result;
                } catch (err) {
                  parentIDStack = [];
                  throw err;
                } finally {
                  if (parentIDStack.length === 0) {
                    var rootID = internalInstanceToRootIDMap.get(internalInstance);
                    if (rootID === void 0) {
                      throw new Error("Expected to find root ID.");
                    }
                    flushPendingEvents(rootID);
                  }
                }
              }
            });
          }
          function cleanup() {
            if (oldReconcilerMethods !== null) {
              if (renderer.Component) {
                restoreMany(renderer.Component.Mixin, oldReconcilerMethods);
              } else {
                restoreMany(renderer.Reconciler, oldReconcilerMethods);
              }
            }
            oldReconcilerMethods = null;
          }
          function recordMount(internalInstance, id, parentID) {
            var isRoot = parentID === 0;
            if (__DEBUG__) {
              console.log("%crecordMount()", "color: green; font-weight: bold;", id, getData(internalInstance).displayName);
            }
            if (isRoot) {
              var hasOwnerMetadata = internalInstance._currentElement != null && internalInstance._currentElement._owner != null;
              pushOperation(TREE_OPERATION_ADD);
              pushOperation(id);
              pushOperation(ElementTypeRoot);
              pushOperation(0);
              pushOperation(0);
              pushOperation(0);
              pushOperation(hasOwnerMetadata ? 1 : 0);
            } else {
              var type = getElementType(internalInstance);
              var _getData = getData(internalInstance), displayName = _getData.displayName, key = _getData.key;
              var ownerID = internalInstance._currentElement != null && internalInstance._currentElement._owner != null ? getID(internalInstance._currentElement._owner) : 0;
              var displayNameStringID = getStringID(displayName);
              var keyStringID = getStringID(key);
              pushOperation(TREE_OPERATION_ADD);
              pushOperation(id);
              pushOperation(type);
              pushOperation(parentID);
              pushOperation(ownerID);
              pushOperation(displayNameStringID);
              pushOperation(keyStringID);
            }
          }
          function recordReorder(internalInstance, id, nextChildren) {
            pushOperation(TREE_OPERATION_REORDER_CHILDREN);
            pushOperation(id);
            var nextChildIDs = nextChildren.map(getID);
            pushOperation(nextChildIDs.length);
            for (var i = 0; i < nextChildIDs.length; i++) {
              pushOperation(nextChildIDs[i]);
            }
          }
          function recordUnmount(internalInstance, id) {
            pendingUnmountedIDs.push(id);
            idToInternalInstanceMap.delete(id);
          }
          function crawlAndRecordInitialMounts(id, parentID, rootID) {
            if (__DEBUG__) {
              console.group("crawlAndRecordInitialMounts() id:", id);
            }
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance != null) {
              internalInstanceToRootIDMap.set(internalInstance, rootID);
              recordMount(internalInstance, id, parentID);
              getChildren(internalInstance).forEach(function(child) {
                return crawlAndRecordInitialMounts(getID(child), id, rootID);
              });
            }
            if (__DEBUG__) {
              console.groupEnd();
            }
          }
          function flushInitialOperations() {
            var roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;
            for (var key in roots) {
              var internalInstance = roots[key];
              var _id2 = getID(internalInstance);
              crawlAndRecordInitialMounts(_id2, 0, _id2);
              flushPendingEvents(_id2);
            }
          }
          var pendingOperations = [];
          var pendingStringTable = /* @__PURE__ */ new Map();
          var pendingUnmountedIDs = [];
          var pendingStringTableLength = 0;
          var pendingUnmountedRootID = null;
          function flushPendingEvents(rootID) {
            if (pendingOperations.length === 0 && pendingUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {
              return;
            }
            var numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
            var operations = new Array(
              // Identify which renderer this update is coming from.
              2 + // [rendererID, rootFiberID]
              // How big is the string table?
              1 + // [stringTableLength]
              // Then goes the actual string table.
              pendingStringTableLength + // All unmounts are batched in a single message.
              // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
              (numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Mount operations
              pendingOperations.length
            );
            var i = 0;
            operations[i++] = rendererID;
            operations[i++] = rootID;
            operations[i++] = pendingStringTableLength;
            pendingStringTable.forEach(function(value, key) {
              operations[i++] = key.length;
              var encodedKey = utfEncodeString(key);
              for (var j2 = 0; j2 < encodedKey.length; j2++) {
                operations[i + j2] = encodedKey[j2];
              }
              i += key.length;
            });
            if (numUnmountIDs > 0) {
              operations[i++] = TREE_OPERATION_REMOVE;
              operations[i++] = numUnmountIDs;
              for (var j = 0; j < pendingUnmountedIDs.length; j++) {
                operations[i++] = pendingUnmountedIDs[j];
              }
              if (pendingUnmountedRootID !== null) {
                operations[i] = pendingUnmountedRootID;
                i++;
              }
            }
            for (var _j = 0; _j < pendingOperations.length; _j++) {
              operations[i + _j] = pendingOperations[_j];
            }
            i += pendingOperations.length;
            if (__DEBUG__) {
              printOperationsArray(operations);
            }
            hook2.emit("operations", operations);
            pendingOperations.length = 0;
            pendingUnmountedIDs = [];
            pendingUnmountedRootID = null;
            pendingStringTable.clear();
            pendingStringTableLength = 0;
          }
          function pushOperation(op) {
            if (false) {
            }
            pendingOperations.push(op);
          }
          function getStringID(str) {
            if (str === null) {
              return 0;
            }
            var existingID = pendingStringTable.get(str);
            if (existingID !== void 0) {
              return existingID;
            }
            var stringID = pendingStringTable.size + 1;
            pendingStringTable.set(str, stringID);
            pendingStringTableLength += str.length + 1;
            return stringID;
          }
          var currentlyInspectedElementID = null;
          var currentlyInspectedPaths = {};
          function mergeInspectedPaths(path) {
            var current = currentlyInspectedPaths;
            path.forEach(function(key) {
              if (!current[key]) {
                current[key] = {};
              }
              current = current[key];
            });
          }
          function createIsPathAllowed(key) {
            return function isPathAllowed(path) {
              var current = currentlyInspectedPaths[key];
              if (!current) {
                return false;
              }
              for (var i = 0; i < path.length; i++) {
                current = current[path[i]];
                if (!current) {
                  return false;
                }
              }
              return true;
            };
          }
          function getInstanceAndStyle(id) {
            var instance = null;
            var style = null;
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance != null) {
              instance = internalInstance._instance || null;
              var element = internalInstance._currentElement;
              if (element != null && element.props != null) {
                style = element.props.style || null;
              }
            }
            return {
              instance,
              style
            };
          }
          function updateSelectedElement(id) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance == null) {
              console.warn('Could not find instance with id "'.concat(id, '"'));
              return;
            }
            switch (getElementType(internalInstance)) {
              case types_ElementTypeClass:
                global2.$r = internalInstance._instance;
                break;
              case types_ElementTypeFunction:
                var element = internalInstance._currentElement;
                if (element == null) {
                  console.warn('Could not find element with id "'.concat(id, '"'));
                  return;
                }
                global2.$r = {
                  props: element.props,
                  type: element.type
                };
                break;
              default:
                global2.$r = null;
                break;
            }
          }
          function storeAsGlobal(id, path, count) {
            var inspectedElement = inspectElementRaw(id);
            if (inspectedElement !== null) {
              var value = utils_getInObject(inspectedElement, path);
              var key = "$reactTemp".concat(count);
              window[key] = value;
              console.log(key);
              console.log(value);
            }
          }
          function getSerializedElementValueByPath(id, path) {
            var inspectedElement = inspectElementRaw(id);
            if (inspectedElement !== null) {
              var valueToCopy = utils_getInObject(inspectedElement, path);
              return serializeToString(valueToCopy);
            }
          }
          function inspectElement(requestID, id, path, forceFullData) {
            if (forceFullData || currentlyInspectedElementID !== id) {
              currentlyInspectedElementID = id;
              currentlyInspectedPaths = {};
            }
            var inspectedElement = inspectElementRaw(id);
            if (inspectedElement === null) {
              return {
                id,
                responseID: requestID,
                type: "not-found"
              };
            }
            if (path !== null) {
              mergeInspectedPaths(path);
            }
            updateSelectedElement(id);
            inspectedElement.context = cleanForBridge(inspectedElement.context, createIsPathAllowed("context"));
            inspectedElement.props = cleanForBridge(inspectedElement.props, createIsPathAllowed("props"));
            inspectedElement.state = cleanForBridge(inspectedElement.state, createIsPathAllowed("state"));
            return {
              id,
              responseID: requestID,
              type: "full-data",
              value: inspectedElement
            };
          }
          function inspectElementRaw(id) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance == null) {
              return null;
            }
            var _getData2 = getData(internalInstance), displayName = _getData2.displayName, key = _getData2.key;
            var type = getElementType(internalInstance);
            var context = null;
            var owners = null;
            var props = null;
            var state = null;
            var source = null;
            var element = internalInstance._currentElement;
            if (element !== null) {
              props = element.props;
              source = element._source != null ? element._source : null;
              var owner = element._owner;
              if (owner) {
                owners = [];
                while (owner != null) {
                  owners.push({
                    displayName: getData(owner).displayName || "Unknown",
                    id: getID(owner),
                    key: element.key,
                    type: getElementType(owner)
                  });
                  if (owner._currentElement) {
                    owner = owner._currentElement._owner;
                  }
                }
              }
            }
            var publicInstance = internalInstance._instance;
            if (publicInstance != null) {
              context = publicInstance.context || null;
              state = publicInstance.state || null;
            }
            var errors = [];
            var warnings = [];
            return {
              id,
              // Does the current renderer support editable hooks and function props?
              canEditHooks: false,
              canEditFunctionProps: false,
              // Does the current renderer support advanced editing interface?
              canEditHooksAndDeletePaths: false,
              canEditHooksAndRenamePaths: false,
              canEditFunctionPropsDeletePaths: false,
              canEditFunctionPropsRenamePaths: false,
              // Toggle error boundary did not exist in legacy versions
              canToggleError: false,
              isErrored: false,
              targetErrorBoundaryID: null,
              // Suspense did not exist in legacy versions
              canToggleSuspense: false,
              // Can view component source location.
              canViewSource: type === types_ElementTypeClass || type === types_ElementTypeFunction,
              // Only legacy context exists in legacy versions.
              hasLegacyContext: true,
              displayName,
              type,
              key: key != null ? key : null,
              // Inspectable properties.
              context,
              hooks: null,
              props,
              state,
              errors,
              warnings,
              // List of owners
              owners,
              // Location of component in source code.
              source,
              rootType: null,
              rendererPackageName: null,
              rendererVersion: null,
              plugins: {
                stylex: null
              }
            };
          }
          function logElementToConsole(id) {
            var result = inspectElementRaw(id);
            if (result === null) {
              console.warn('Could not find element with id "'.concat(id, '"'));
              return;
            }
            var supportsGroup = typeof console.groupCollapsed === "function";
            if (supportsGroup) {
              console.groupCollapsed(
                "[Click to expand] %c<".concat(result.displayName || "Component", " />"),
                // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.
                "color: var(--dom-tag-name-color); font-weight: normal;"
              );
            }
            if (result.props !== null) {
              console.log("Props:", result.props);
            }
            if (result.state !== null) {
              console.log("State:", result.state);
            }
            if (result.context !== null) {
              console.log("Context:", result.context);
            }
            var nativeNode = findNativeNodeForInternalID(id);
            if (nativeNode !== null) {
              console.log("Node:", nativeNode);
            }
            if (supportsGroup) {
              console.groupEnd();
            }
          }
          function prepareViewAttributeSource(id, path) {
            var inspectedElement = inspectElementRaw(id);
            if (inspectedElement !== null) {
              window.$attribute = utils_getInObject(inspectedElement, path);
            }
          }
          function prepareViewElementSource(id) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance == null) {
              console.warn('Could not find instance with id "'.concat(id, '"'));
              return;
            }
            var element = internalInstance._currentElement;
            if (element == null) {
              console.warn('Could not find element with id "'.concat(id, '"'));
              return;
            }
            global2.$type = element.type;
          }
          function deletePath(type, id, hookID, path) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance != null) {
              var publicInstance = internalInstance._instance;
              if (publicInstance != null) {
                switch (type) {
                  case "context":
                    deletePathInObject(publicInstance.context, path);
                    forceUpdate(publicInstance);
                    break;
                  case "hooks":
                    throw new Error("Hooks not supported by this renderer");
                  case "props":
                    var element = internalInstance._currentElement;
                    internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
                      props: copyWithDelete(element.props, path)
                    });
                    forceUpdate(publicInstance);
                    break;
                  case "state":
                    deletePathInObject(publicInstance.state, path);
                    forceUpdate(publicInstance);
                    break;
                }
              }
            }
          }
          function renamePath(type, id, hookID, oldPath, newPath) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance != null) {
              var publicInstance = internalInstance._instance;
              if (publicInstance != null) {
                switch (type) {
                  case "context":
                    renamePathInObject(publicInstance.context, oldPath, newPath);
                    forceUpdate(publicInstance);
                    break;
                  case "hooks":
                    throw new Error("Hooks not supported by this renderer");
                  case "props":
                    var element = internalInstance._currentElement;
                    internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
                      props: copyWithRename(element.props, oldPath, newPath)
                    });
                    forceUpdate(publicInstance);
                    break;
                  case "state":
                    renamePathInObject(publicInstance.state, oldPath, newPath);
                    forceUpdate(publicInstance);
                    break;
                }
              }
            }
          }
          function overrideValueAtPath(type, id, hookID, path, value) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance != null) {
              var publicInstance = internalInstance._instance;
              if (publicInstance != null) {
                switch (type) {
                  case "context":
                    utils_setInObject(publicInstance.context, path, value);
                    forceUpdate(publicInstance);
                    break;
                  case "hooks":
                    throw new Error("Hooks not supported by this renderer");
                  case "props":
                    var element = internalInstance._currentElement;
                    internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
                      props: copyWithSet(element.props, path, value)
                    });
                    forceUpdate(publicInstance);
                    break;
                  case "state":
                    utils_setInObject(publicInstance.state, path, value);
                    forceUpdate(publicInstance);
                    break;
                }
              }
            }
          }
          var getProfilingData = function getProfilingData2() {
            throw new Error("getProfilingData not supported by this renderer");
          };
          var handleCommitFiberRoot = function handleCommitFiberRoot2() {
            throw new Error("handleCommitFiberRoot not supported by this renderer");
          };
          var handleCommitFiberUnmount = function handleCommitFiberUnmount2() {
            throw new Error("handleCommitFiberUnmount not supported by this renderer");
          };
          var handlePostCommitFiberRoot = function handlePostCommitFiberRoot2() {
            throw new Error("handlePostCommitFiberRoot not supported by this renderer");
          };
          var overrideError = function overrideError2() {
            throw new Error("overrideError not supported by this renderer");
          };
          var overrideSuspense = function overrideSuspense2() {
            throw new Error("overrideSuspense not supported by this renderer");
          };
          var startProfiling = function startProfiling2() {
          };
          var stopProfiling = function stopProfiling2() {
          };
          function getBestMatchForTrackedPath() {
            return null;
          }
          function getPathForElement(id) {
            return null;
          }
          function updateComponentFilters(componentFilters) {
          }
          function setTraceUpdatesEnabled(enabled) {
          }
          function setTrackedPath(path) {
          }
          function getOwnersList(id) {
            return null;
          }
          function clearErrorsAndWarnings() {
          }
          function clearErrorsForFiberID(id) {
          }
          function clearWarningsForFiberID(id) {
          }
          function patchConsoleForStrictMode() {
          }
          function unpatchConsoleForStrictMode() {
          }
          function hasFiberWithId(id) {
            return idToInternalInstanceMap.has(id);
          }
          return {
            clearErrorsAndWarnings,
            clearErrorsForFiberID,
            clearWarningsForFiberID,
            cleanup,
            getSerializedElementValueByPath,
            deletePath,
            flushInitialOperations,
            getBestMatchForTrackedPath,
            getDisplayNameForFiberID,
            getFiberForNative,
            getFiberIDForNative: getInternalIDForNative,
            getInstanceAndStyle,
            findNativeNodesForFiberID: function findNativeNodesForFiberID(id) {
              var nativeNode = findNativeNodeForInternalID(id);
              return nativeNode == null ? null : [nativeNode];
            },
            getOwnersList,
            getPathForElement,
            getProfilingData,
            handleCommitFiberRoot,
            handleCommitFiberUnmount,
            handlePostCommitFiberRoot,
            hasFiberWithId,
            inspectElement,
            logElementToConsole,
            overrideError,
            overrideSuspense,
            overrideValueAtPath,
            renamePath,
            patchConsoleForStrictMode,
            prepareViewAttributeSource,
            prepareViewElementSource,
            renderer,
            setTraceUpdatesEnabled,
            setTrackedPath,
            startProfiling,
            stopProfiling,
            storeAsGlobal,
            unpatchConsoleForStrictMode,
            updateComponentFilters
          };
        }
        ;
        function isMatchingRender(version) {
          return !hasAssignedBackend(version);
        }
        function initBackend(hook2, agent2, global2) {
          if (hook2 == null) {
            return function() {
            };
          }
          var subs = [
            hook2.sub("renderer-attached", function(_ref) {
              var id = _ref.id, renderer = _ref.renderer, rendererInterface = _ref.rendererInterface;
              agent2.setRendererInterface(id, rendererInterface);
              rendererInterface.flushInitialOperations();
            }),
            hook2.sub("unsupported-renderer-version", function(id) {
              agent2.onUnsupportedRenderer(id);
            }),
            hook2.sub("fastRefreshScheduled", agent2.onFastRefreshScheduled),
            hook2.sub("operations", agent2.onHookOperations),
            hook2.sub("traceUpdates", agent2.onTraceUpdates)
            // TODO Add additional subscriptions required for profiling mode
          ];
          var attachRenderer = function attachRenderer2(id, renderer) {
            if (!isMatchingRender(renderer.reconcilerVersion || renderer.version)) {
              return;
            }
            var rendererInterface = hook2.rendererInterfaces.get(id);
            if (rendererInterface == null) {
              if (typeof renderer.findFiberByHostInstance === "function") {
                rendererInterface = attach(hook2, id, renderer, global2);
              } else if (renderer.ComponentTree) {
                rendererInterface = renderer_attach(hook2, id, renderer, global2);
              } else {
              }
              if (rendererInterface != null) {
                hook2.rendererInterfaces.set(id, rendererInterface);
              }
            }
            if (rendererInterface != null) {
              hook2.emit("renderer-attached", {
                id,
                renderer,
                rendererInterface
              });
            } else {
              hook2.emit("unsupported-renderer-version", id);
            }
          };
          hook2.renderers.forEach(function(renderer, id) {
            attachRenderer(id, renderer);
          });
          subs.push(hook2.sub("renderer", function(_ref2) {
            var id = _ref2.id, renderer = _ref2.renderer;
            attachRenderer(id, renderer);
          }));
          hook2.emit("react-devtools", agent2);
          hook2.reactDevtoolsAgent = agent2;
          var onAgentShutdown = function onAgentShutdown2() {
            subs.forEach(function(fn) {
              return fn();
            });
            hook2.rendererInterfaces.forEach(function(rendererInterface) {
              rendererInterface.cleanup();
            });
            hook2.reactDevtoolsAgent = null;
          };
          agent2.addListener("shutdown", onAgentShutdown);
          subs.push(function() {
            agent2.removeListener("shutdown", onAgentShutdown);
          });
          return function() {
            subs.forEach(function(fn) {
              return fn();
            });
          };
        }
        ;
        function resolveBoxStyle(prefix2, style) {
          var hasParts = false;
          var result = {
            bottom: 0,
            left: 0,
            right: 0,
            top: 0
          };
          var styleForAll = style[prefix2];
          if (styleForAll != null) {
            for (var _i = 0, _Object$keys = Object.keys(result); _i < _Object$keys.length; _i++) {
              var key = _Object$keys[_i];
              result[key] = styleForAll;
            }
            hasParts = true;
          }
          var styleForHorizontal = style[prefix2 + "Horizontal"];
          if (styleForHorizontal != null) {
            result.left = styleForHorizontal;
            result.right = styleForHorizontal;
            hasParts = true;
          } else {
            var styleForLeft = style[prefix2 + "Left"];
            if (styleForLeft != null) {
              result.left = styleForLeft;
              hasParts = true;
            }
            var styleForRight = style[prefix2 + "Right"];
            if (styleForRight != null) {
              result.right = styleForRight;
              hasParts = true;
            }
            var styleForEnd = style[prefix2 + "End"];
            if (styleForEnd != null) {
              result.right = styleForEnd;
              hasParts = true;
            }
            var styleForStart = style[prefix2 + "Start"];
            if (styleForStart != null) {
              result.left = styleForStart;
              hasParts = true;
            }
          }
          var styleForVertical = style[prefix2 + "Vertical"];
          if (styleForVertical != null) {
            result.bottom = styleForVertical;
            result.top = styleForVertical;
            hasParts = true;
          } else {
            var styleForBottom = style[prefix2 + "Bottom"];
            if (styleForBottom != null) {
              result.bottom = styleForBottom;
              hasParts = true;
            }
            var styleForTop = style[prefix2 + "Top"];
            if (styleForTop != null) {
              result.top = styleForTop;
              hasParts = true;
            }
          }
          return hasParts ? result : null;
        }
        ;
        function setupNativeStyleEditor_typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            setupNativeStyleEditor_typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            setupNativeStyleEditor_typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return setupNativeStyleEditor_typeof(obj);
        }
        function setupNativeStyleEditor_defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function setupNativeStyleEditor(bridge, agent2, resolveNativeStyle, validAttributes) {
          bridge.addListener("NativeStyleEditor_measure", function(_ref) {
            var id = _ref.id, rendererID = _ref.rendererID;
            measureStyle(agent2, bridge, resolveNativeStyle, id, rendererID);
          });
          bridge.addListener("NativeStyleEditor_renameAttribute", function(_ref2) {
            var id = _ref2.id, rendererID = _ref2.rendererID, oldName = _ref2.oldName, newName = _ref2.newName, value = _ref2.value;
            renameStyle(agent2, id, rendererID, oldName, newName, value);
            setTimeout(function() {
              return measureStyle(agent2, bridge, resolveNativeStyle, id, rendererID);
            });
          });
          bridge.addListener("NativeStyleEditor_setValue", function(_ref3) {
            var id = _ref3.id, rendererID = _ref3.rendererID, name = _ref3.name, value = _ref3.value;
            setStyle(agent2, id, rendererID, name, value);
            setTimeout(function() {
              return measureStyle(agent2, bridge, resolveNativeStyle, id, rendererID);
            });
          });
          bridge.send("isNativeStyleEditorSupported", {
            isSupported: true,
            validAttributes
          });
        }
        var EMPTY_BOX_STYLE = {
          top: 0,
          left: 0,
          right: 0,
          bottom: 0
        };
        var componentIDToStyleOverrides = /* @__PURE__ */ new Map();
        function measureStyle(agent2, bridge, resolveNativeStyle, id, rendererID) {
          var data = agent2.getInstanceAndStyle({
            id,
            rendererID
          });
          if (!data || !data.style) {
            bridge.send("NativeStyleEditor_styleAndLayout", {
              id,
              layout: null,
              style: null
            });
            return;
          }
          var instance = data.instance, style = data.style;
          var resolvedStyle = resolveNativeStyle(style);
          var styleOverrides = componentIDToStyleOverrides.get(id);
          if (styleOverrides != null) {
            resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);
          }
          if (!instance || typeof instance.measure !== "function") {
            bridge.send("NativeStyleEditor_styleAndLayout", {
              id,
              layout: null,
              style: resolvedStyle || null
            });
            return;
          }
          instance.measure(function(x, y, width, height, left, top) {
            if (typeof x !== "number") {
              bridge.send("NativeStyleEditor_styleAndLayout", {
                id,
                layout: null,
                style: resolvedStyle || null
              });
              return;
            }
            var margin = resolvedStyle != null && resolveBoxStyle("margin", resolvedStyle) || EMPTY_BOX_STYLE;
            var padding = resolvedStyle != null && resolveBoxStyle("padding", resolvedStyle) || EMPTY_BOX_STYLE;
            bridge.send("NativeStyleEditor_styleAndLayout", {
              id,
              layout: {
                x,
                y,
                width,
                height,
                left,
                top,
                margin,
                padding
              },
              style: resolvedStyle || null
            });
          });
        }
        function shallowClone(object) {
          var cloned = {};
          for (var n in object) {
            cloned[n] = object[n];
          }
          return cloned;
        }
        function renameStyle(agent2, id, rendererID, oldName, newName, value) {
          var _ref4;
          var data = agent2.getInstanceAndStyle({
            id,
            rendererID
          });
          if (!data || !data.style) {
            return;
          }
          var instance = data.instance, style = data.style;
          var newStyle = newName ? (_ref4 = {}, setupNativeStyleEditor_defineProperty(_ref4, oldName, void 0), setupNativeStyleEditor_defineProperty(_ref4, newName, value), _ref4) : setupNativeStyleEditor_defineProperty({}, oldName, void 0);
          var customStyle;
          if (instance !== null && typeof instance.setNativeProps === "function") {
            var styleOverrides = componentIDToStyleOverrides.get(id);
            if (!styleOverrides) {
              componentIDToStyleOverrides.set(id, newStyle);
            } else {
              Object.assign(styleOverrides, newStyle);
            }
            instance.setNativeProps({
              style: newStyle
            });
          } else if (src_isArray(style)) {
            var lastIndex = style.length - 1;
            if (setupNativeStyleEditor_typeof(style[lastIndex]) === "object" && !src_isArray(style[lastIndex])) {
              customStyle = shallowClone(style[lastIndex]);
              delete customStyle[oldName];
              if (newName) {
                customStyle[newName] = value;
              } else {
                customStyle[oldName] = void 0;
              }
              agent2.overrideValueAtPath({
                type: "props",
                id,
                rendererID,
                path: ["style", lastIndex],
                value: customStyle
              });
            } else {
              agent2.overrideValueAtPath({
                type: "props",
                id,
                rendererID,
                path: ["style"],
                value: style.concat([newStyle])
              });
            }
          } else if (setupNativeStyleEditor_typeof(style) === "object") {
            customStyle = shallowClone(style);
            delete customStyle[oldName];
            if (newName) {
              customStyle[newName] = value;
            } else {
              customStyle[oldName] = void 0;
            }
            agent2.overrideValueAtPath({
              type: "props",
              id,
              rendererID,
              path: ["style"],
              value: customStyle
            });
          } else {
            agent2.overrideValueAtPath({
              type: "props",
              id,
              rendererID,
              path: ["style"],
              value: [style, newStyle]
            });
          }
          agent2.emit("hideNativeHighlight");
        }
        function setStyle(agent2, id, rendererID, name, value) {
          var data = agent2.getInstanceAndStyle({
            id,
            rendererID
          });
          if (!data || !data.style) {
            return;
          }
          var instance = data.instance, style = data.style;
          var newStyle = setupNativeStyleEditor_defineProperty({}, name, value);
          if (instance !== null && typeof instance.setNativeProps === "function") {
            var styleOverrides = componentIDToStyleOverrides.get(id);
            if (!styleOverrides) {
              componentIDToStyleOverrides.set(id, newStyle);
            } else {
              Object.assign(styleOverrides, newStyle);
            }
            instance.setNativeProps({
              style: newStyle
            });
          } else if (src_isArray(style)) {
            var lastLength = style.length - 1;
            if (setupNativeStyleEditor_typeof(style[lastLength]) === "object" && !src_isArray(style[lastLength])) {
              agent2.overrideValueAtPath({
                type: "props",
                id,
                rendererID,
                path: ["style", lastLength, name],
                value
              });
            } else {
              agent2.overrideValueAtPath({
                type: "props",
                id,
                rendererID,
                path: ["style"],
                value: style.concat([newStyle])
              });
            }
          } else {
            agent2.overrideValueAtPath({
              type: "props",
              id,
              rendererID,
              path: ["style"],
              value: [style, newStyle]
            });
          }
          agent2.emit("hideNativeHighlight");
        }
        ;
        function initializeUsingCachedSettings(devToolsSettingsManager) {
          initializeConsolePatchSettings(devToolsSettingsManager);
        }
        function initializeConsolePatchSettings(devToolsSettingsManager) {
          if (devToolsSettingsManager.getConsolePatchSettings == null) {
            return;
          }
          var consolePatchSettingsString = devToolsSettingsManager.getConsolePatchSettings();
          if (consolePatchSettingsString == null) {
            return;
          }
          var parsedConsolePatchSettings = parseConsolePatchSettings(consolePatchSettingsString);
          if (parsedConsolePatchSettings == null) {
            return;
          }
          writeConsolePatchSettingsToWindow(parsedConsolePatchSettings);
        }
        function parseConsolePatchSettings(consolePatchSettingsString) {
          var _castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;
          var parsedValue = JSON.parse(consolePatchSettingsString !== null && consolePatchSettingsString !== void 0 ? consolePatchSettingsString : "{}");
          var appendComponentStack = parsedValue.appendComponentStack, breakOnConsoleErrors = parsedValue.breakOnConsoleErrors, showInlineWarningsAndErrors = parsedValue.showInlineWarningsAndErrors, hideConsoleLogsInStrictMode = parsedValue.hideConsoleLogsInStrictMode, browserTheme = parsedValue.browserTheme;
          return {
            appendComponentStack: (_castBool = castBool(appendComponentStack)) !== null && _castBool !== void 0 ? _castBool : true,
            breakOnConsoleErrors: (_castBool2 = castBool(breakOnConsoleErrors)) !== null && _castBool2 !== void 0 ? _castBool2 : false,
            showInlineWarningsAndErrors: (_castBool3 = castBool(showInlineWarningsAndErrors)) !== null && _castBool3 !== void 0 ? _castBool3 : true,
            hideConsoleLogsInStrictMode: (_castBool4 = castBool(hideConsoleLogsInStrictMode)) !== null && _castBool4 !== void 0 ? _castBool4 : false,
            browserTheme: (_castBrowserTheme = castBrowserTheme(browserTheme)) !== null && _castBrowserTheme !== void 0 ? _castBrowserTheme : "dark"
          };
        }
        function cacheConsolePatchSettings(devToolsSettingsManager, value) {
          if (devToolsSettingsManager.setConsolePatchSettings == null) {
            return;
          }
          devToolsSettingsManager.setConsolePatchSettings(JSON.stringify(value));
        }
        ;
        installConsoleFunctionsToWindow();
        installHook(window);
        var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
        var savedComponentFilters = getDefaultComponentFilters();
        function backend_debug(methodName) {
          if (__DEBUG__) {
            var _console;
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            (_console = console).log.apply(_console, ["%c[core/backend] %c".concat(methodName), "color: teal; font-weight: bold;", "font-weight: bold;"].concat(args));
          }
        }
        function connectToDevTools(options) {
          if (hook == null) {
            return;
          }
          var _ref = options || {}, _ref$host = _ref.host, host = _ref$host === void 0 ? "localhost" : _ref$host, nativeStyleEditorValidAttributes = _ref.nativeStyleEditorValidAttributes, _ref$useHttps = _ref.useHttps, useHttps = _ref$useHttps === void 0 ? false : _ref$useHttps, _ref$port = _ref.port, port = _ref$port === void 0 ? 8097 : _ref$port, websocket = _ref.websocket, _ref$resolveRNStyle = _ref.resolveRNStyle, resolveRNStyle = _ref$resolveRNStyle === void 0 ? null : _ref$resolveRNStyle, _ref$retryConnectionD = _ref.retryConnectionDelay, retryConnectionDelay = _ref$retryConnectionD === void 0 ? 2e3 : _ref$retryConnectionD, _ref$isAppActive = _ref.isAppActive, isAppActive = _ref$isAppActive === void 0 ? function() {
            return true;
          } : _ref$isAppActive, devToolsSettingsManager = _ref.devToolsSettingsManager;
          var protocol = useHttps ? "wss" : "ws";
          var retryTimeoutID = null;
          function scheduleRetry() {
            if (retryTimeoutID === null) {
              retryTimeoutID = setTimeout(function() {
                return connectToDevTools(options);
              }, retryConnectionDelay);
            }
          }
          if (devToolsSettingsManager != null) {
            try {
              initializeUsingCachedSettings(devToolsSettingsManager);
            } catch (e) {
              console.error(e);
            }
          }
          if (!isAppActive()) {
            scheduleRetry();
            return;
          }
          var bridge = null;
          var messageListeners = [];
          var uri = protocol + "://" + host + ":" + port;
          var ws = websocket ? websocket : new (require_websocket())(uri);
          ws.onclose = handleClose;
          ws.onerror = handleFailed;
          ws.onmessage = handleMessage;
          ws.onopen = function() {
            bridge = new src_bridge({
              listen: function listen(fn) {
                messageListeners.push(fn);
                return function() {
                  var index = messageListeners.indexOf(fn);
                  if (index >= 0) {
                    messageListeners.splice(index, 1);
                  }
                };
              },
              send: function send(event, payload, transferable) {
                if (ws.readyState === ws.OPEN) {
                  if (__DEBUG__) {
                    backend_debug("wall.send()", event, payload);
                  }
                  ws.send(JSON.stringify({
                    event,
                    payload
                  }));
                } else {
                  if (__DEBUG__) {
                    backend_debug("wall.send()", "Shutting down bridge because of closed WebSocket connection");
                  }
                  if (bridge !== null) {
                    bridge.shutdown();
                  }
                  scheduleRetry();
                }
              }
            });
            bridge.addListener("updateComponentFilters", function(componentFilters) {
              savedComponentFilters = componentFilters;
            });
            if (devToolsSettingsManager != null && bridge != null) {
              bridge.addListener("updateConsolePatchSettings", function(consolePatchSettings) {
                return cacheConsolePatchSettings(devToolsSettingsManager, consolePatchSettings);
              });
            }
            if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == null) {
              bridge.send("overrideComponentFilters", savedComponentFilters);
            }
            var agent2 = new Agent(bridge);
            agent2.addListener("shutdown", function() {
              hook.emit("shutdown");
            });
            initBackend(hook, agent2, window);
            if (resolveRNStyle != null || hook.resolveRNStyle != null) {
              setupNativeStyleEditor(
                // $FlowFixMe[incompatible-call] found when upgrading Flow
                bridge,
                agent2,
                resolveRNStyle || hook.resolveRNStyle,
                nativeStyleEditorValidAttributes || hook.nativeStyleEditorValidAttributes || null
              );
            } else {
              var lazyResolveRNStyle;
              var lazyNativeStyleEditorValidAttributes;
              var initAfterTick = function initAfterTick2() {
                if (bridge !== null) {
                  setupNativeStyleEditor(bridge, agent2, lazyResolveRNStyle, lazyNativeStyleEditorValidAttributes);
                }
              };
              if (!hook.hasOwnProperty("resolveRNStyle")) {
                Object.defineProperty(hook, "resolveRNStyle", {
                  enumerable: false,
                  get: function get() {
                    return lazyResolveRNStyle;
                  },
                  set: function set(value) {
                    lazyResolveRNStyle = value;
                    initAfterTick();
                  }
                });
              }
              if (!hook.hasOwnProperty("nativeStyleEditorValidAttributes")) {
                Object.defineProperty(hook, "nativeStyleEditorValidAttributes", {
                  enumerable: false,
                  get: function get() {
                    return lazyNativeStyleEditorValidAttributes;
                  },
                  set: function set(value) {
                    lazyNativeStyleEditorValidAttributes = value;
                    initAfterTick();
                  }
                });
              }
            }
          };
          function handleClose() {
            if (__DEBUG__) {
              backend_debug("WebSocket.onclose");
            }
            if (bridge !== null) {
              bridge.emit("shutdown");
            }
            scheduleRetry();
          }
          function handleFailed() {
            if (__DEBUG__) {
              backend_debug("WebSocket.onerror");
            }
            scheduleRetry();
          }
          function handleMessage(event) {
            var data;
            try {
              if (typeof event.data === "string") {
                data = JSON.parse(event.data);
                if (__DEBUG__) {
                  backend_debug("WebSocket.onmessage", data);
                }
              } else {
                throw Error();
              }
            } catch (e) {
              console.error("[React DevTools] Failed to parse JSON: " + event.data);
              return;
            }
            messageListeners.forEach(function(fn) {
              try {
                fn(data);
              } catch (error) {
                console.log("[React DevTools] Error calling listener", data);
                console.log("error:", error);
                throw error;
              }
            });
          }
        }
      })();
      return __webpack_exports__;
    })()
  );
});
/*! Bundled license information:

react-devtools-core/dist/backend.js:
  (**
   * @license React
   * react-debug-tools.production.min.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
